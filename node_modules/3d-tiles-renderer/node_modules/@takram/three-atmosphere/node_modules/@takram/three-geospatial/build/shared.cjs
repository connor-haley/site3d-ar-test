"use strict";var P=Object.defineProperty;var j=(p,t,e)=>t in p?P(p,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):p[t]=e;var g=(p,t,e)=>j(p,typeof t!="symbol"?t+"":t,e);const s=require("three"),W=new s.Vector3;function G(p,t,e=new s.Vector3,r){const{x:i,y:n,z:c}=p,o=t.x,a=t.y,y=t.z,d=i*i*o,u=n*n*a,m=c*c*y,l=d+u+m,h=Math.sqrt(1/l);if(!Number.isFinite(h))return;const f=W.copy(p).multiplyScalar(h);if(l<((r==null?void 0:r.centerTolerance)??.1))return e.copy(f);const A=f.multiply(t).multiplyScalar(2);let M=(1-h)*p.length()/(A.length()/2),z=0,w,x,V,E;do{M-=z,w=1/(1+M*o),x=1/(1+M*a),V=1/(1+M*y);const v=w*w,L=x*x,T=V*V,B=v*w,C=L*x,D=T*V;E=d*v+u*L+m*T-1,z=E/((d*B*o+u*C*a+m*D*y)*-2)}while(Math.abs(E)>1e-12);return e.set(i*w,n*x,c*V)}const b=new s.Vector3,U=new s.Vector3,O=new s.Vector3,S=class S{constructor(t,e,r){g(this,"radii");this.radii=new s.Vector3(t,e,r)}get minimumRadius(){return Math.min(this.radii.x,this.radii.y,this.radii.z)}get maximumRadius(){return Math.max(this.radii.x,this.radii.y,this.radii.z)}reciprocalRadii(t=new s.Vector3){const{x:e,y:r,z:i}=this.radii;return t.set(1/e,1/r,1/i)}reciprocalRadiiSquared(t=new s.Vector3){const{x:e,y:r,z:i}=this.radii;return t.set(1/e**2,1/r**2,1/i**2)}projectOnSurface(t,e=new s.Vector3,r){return G(t,this.reciprocalRadiiSquared(),e,r)}getSurfaceNormal(t,e=new s.Vector3){return e.multiplyVectors(this.reciprocalRadiiSquared(b),t).normalize()}getEastNorthUpVectors(t,e=new s.Vector3,r=new s.Vector3,i=new s.Vector3){this.getSurfaceNormal(t,i),e.set(-t.y,t.x,0).normalize(),r.crossVectors(i,e).normalize()}getEastNorthUpFrame(t,e=new s.Matrix4){const r=b,i=U,n=O;return this.getEastNorthUpVectors(t,r,i,n),e.makeBasis(r,i,n).setPosition(t)}getIntersection(t,e=new s.Vector3){const r=this.reciprocalRadii(b),i=U.copy(r).multiply(t.origin),n=O.copy(r).multiply(t.direction),c=i.lengthSq(),o=n.lengthSq(),a=i.dot(n),y=a**2-o*(c-1);if(c===1)return e.copy(t.origin);if(c>1){if(a>=0||y<0)return;const d=Math.sqrt(y),u=(-a-d)/o,m=(-a+d)/o;return t.at(Math.min(u,m),e)}if(c<1){const d=a**2-o*(c-1),u=Math.sqrt(d),m=(-a+u)/o;return t.at(m,e)}if(a<0)return t.at(-a/o,e)}getOsculatingSphereCenter(t,e,r=new s.Vector3){const i=this.radii.x**2,n=b.set(t.x/i,t.y/i,t.z/this.radii.z**2).normalize();return r.copy(n.multiplyScalar(-e).add(t))}};g(S,"WGS84",new S(6378137,6378137,6356752314245179e-9));let q=S;class $ extends s.BufferGeometry{constructor(e=new s.Vector3(1,1,1),r=32,i=16){super();g(this,"type","EllipsoidGeometry");g(this,"parameters");this.parameters={radii:e,longitudeSegments:r,latitudeSegments:i},r=Math.max(3,Math.floor(r)),i=Math.max(2,Math.floor(i));const n=(r+1)*(i+1),c=new s.Vector3,o=new s.Vector3,a=new Float32Array(n*3),y=new Float32Array(n*3),d=new Float32Array(n*2),u=[],m=[];for(let l=0,h=0,f=0,A=0;l<=i;++l){const M=[],z=l/i,w=z*Math.PI;let x=0;l===0?x=.5/r:l===i&&(x=-.5/r);for(let V=0;V<=r;++V,h+=3,f+=2,++A){const E=V/r,v=E*Math.PI*2;c.x=e.x*Math.cos(v)*Math.sin(w),c.y=e.y*Math.sin(v)*Math.sin(w),c.z=e.z*Math.cos(w),a[h]=c.x,a[h+1]=c.y,a[h+2]=c.z,o.copy(c).normalize(),y[h]=o.x,y[h+1]=o.y,y[h+2]=o.z,d[f]=E+x,d[f+1]=1-z,M.push(A)}u.push(M)}for(let l=0;l<i;++l)for(let h=0;h<r;++h){const f=u[l][h+1],A=u[l][h],M=u[l+1][h],z=u[l+1][h+1];l!==0&&m.push(f,A,z),l!==i-1&&m.push(A,M,z)}this.setIndex(m),this.setAttribute("position",new s.BufferAttribute(a,3)),this.setAttribute("normal",new s.BufferAttribute(y,3)),this.setAttribute("uv",new s.BufferAttribute(d,2))}copy(e){return super.copy(e),this.parameters={...e.parameters},this}}const N=new s.Vector3,R=new s.Vector3,I=class I{constructor(t=0,e=0,r=0){this.longitude=t,this.latitude=e,this.height=r}set(t,e,r){return this.longitude=t,this.latitude=e,r!=null&&(this.height=r),this}clone(){return new I(this.longitude,this.latitude,this.height)}copy(t){return this.longitude=t.longitude,this.latitude=t.latitude,this.height=t.height,this}equals(t){return t.longitude===this.longitude&&t.latitude===this.latitude&&t.height===this.height}setLongitude(t){return this.longitude=t,this}setLatitude(t){return this.latitude=t,this}setHeight(t){return this.height=t,this}normalize(){return this.longitude<I.MIN_LONGITUDE&&(this.longitude+=Math.PI*2),this}setFromECEF(t,e){const i=((e==null?void 0:e.ellipsoid)??q.WGS84).reciprocalRadiiSquared(N),n=G(t,i,R,e);if(n==null)throw new Error(`Could not project position to ellipsoid surface: ${t.toArray()}`);const c=N.multiplyVectors(n,i).normalize();this.longitude=Math.atan2(c.y,c.x),this.latitude=Math.asin(c.z);const o=N.subVectors(t,n);return this.height=Math.sign(o.dot(t))*o.length(),this}toECEF(t=new s.Vector3,e){const r=(e==null?void 0:e.ellipsoid)??q.WGS84,i=N.multiplyVectors(r.radii,r.radii),n=Math.cos(this.latitude),c=R.set(n*Math.cos(this.longitude),n*Math.sin(this.longitude),Math.sin(this.latitude)).normalize();return t.multiplyVectors(i,c),t.divideScalar(Math.sqrt(c.dot(t))).add(c.multiplyScalar(this.height))}fromArray(t,e=0){return this.longitude=t[e],this.latitude=t[e+1],this.height=t[e+2],this}toArray(t=[],e=0){return t[e]=this.longitude,t[e+1]=this.latitude,t[e+2]=this.height,t}*[Symbol.iterator](){yield this.longitude,yield this.latitude,yield this.height}};g(I,"MIN_LONGITUDE",-Math.PI),g(I,"MAX_LONGITUDE",Math.PI),g(I,"MIN_LATITUDE",-Math.PI/2),g(I,"MAX_LATITUDE",Math.PI/2);let F=I;exports.Ellipsoid=q;exports.EllipsoidGeometry=$;exports.Geodetic=F;
//# sourceMappingURL=shared.cjs.map
