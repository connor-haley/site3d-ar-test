import { Loader as Vt, FileLoader as _i, BufferGeometry as bi, BufferAttribute as Zr, Box3 as Ni, Vector3 as Re, Sphere as Oi, ByteType as Ui, UnsignedByteType as Hr, ShortType as mi, UnsignedShortType as Ci, IntType as Ri, UnsignedIntType as xi, HalfFloatType as lt, FloatType as ft, LinearFilter as kt, RGBAFormat as hn, Data3DTexture as fn, DataTexture as Fi, MathUtils as ye, Material as Jt, REVISION as Li, DataTextureLoader as Pi, RedFormat as vn, DataUtils as Gr, Quaternion as Mi, Matrix4 as Di, Ray as Bi, RepeatWrapping as or, NearestFilter as Wr, Vector2 as yn } from "three";
import { E as Xr, G as st } from "./shared.js";
import { a as la } from "./shared.js";
var zi = process.env.NODE_ENV === "production", Yr = "Invariant failed";
function _r(r, e) {
  if (!r) {
    if (zi)
      throw new Error(Yr);
    var i = Yr;
    throw new Error(i);
  }
}
class ki extends Vt {
  load(e, i, s, o) {
    const c = new _i(this.manager);
    c.setResponseType("arraybuffer"), c.setRequestHeader(this.requestHeader), c.setPath(this.path), c.setWithCredentials(this.withCredentials), c.load(
      e,
      (l) => {
        _r(l instanceof ArrayBuffer);
        try {
          i(l);
        } catch (v) {
          o != null ? o(v) : console.error(v), this.manager.itemError(e);
        }
      },
      s,
      o
    );
  }
}
function To(r) {
}
function Eo(r) {
  var c;
  const { attributes: e, index: i, boundingBox: s, boundingSphere: o } = r;
  return [
    { attributes: e, index: i, boundingBox: s, boundingSphere: o },
    [
      ...Object.values(r.attributes).map(
        (l) => l.array.buffer
      ),
      (c = r.index) == null ? void 0 : c.array.buffer
    ].filter((l) => l != null)
  ];
}
function Io(r, e = new bi()) {
  for (const [i, s] of Object.entries(r.attributes))
    e.setAttribute(
      i,
      new Zr(
        s.array,
        s.itemSize,
        s.normalized
      )
    );
  if (e.index = r.index != null ? new Zr(
    r.index.array,
    r.index.itemSize,
    r.index.normalized
  ) : null, r.boundingBox != null) {
    const { min: i, max: s } = r.boundingBox;
    e.boundingBox = new Ni(
      new Re(i.x, i.y, i.z),
      new Re(s.x, s.y, s.z)
    );
  }
  if (r.boundingSphere != null) {
    const { center: i, radius: s } = r.boundingSphere;
    e.boundingSphere = new Oi(
      new Re(i.x, i.y, i.z),
      s
    );
  }
  return e;
}
const Zi = 128, Hi = 128, Gi = 64, _o = "https://media.githubusercontent.com/media/takram-design-engineering/three-geospatial/9627216cc50057994c98a2118f3c4a23765d43b9/packages/core/assets/stbn.bin", Wi = "This is not an object", Xi = "This is not a Float16Array object", qr = "This constructor is not a subclass of Float16Array", pn = "The constructor property value is not an object", Yi = "Species constructor didn't return TypedArray object", qi = "Derived constructor created TypedArray object which was too small length", vt = "Attempting to access detached ArrayBuffer", pr = "Cannot convert undefined or null to object", dr = "Cannot mix BigInt and other types, use explicit conversions", Vr = "@@iterator property is not callable", Jr = "Reduce of empty array with no initial value", Vi = "The comparison function must be either a function or undefined", ar = "Offset is out of bounds";
function Z(r) {
  return (e, ...i) => ie(r, e, i);
}
function $e(r, e) {
  return Z(
    Ye(
      r,
      e
    ).get
  );
}
const {
  apply: ie,
  construct: ut,
  defineProperty: $r,
  get: cr,
  getOwnPropertyDescriptor: Ye,
  getPrototypeOf: At,
  has: wr,
  ownKeys: dn,
  set: Qr,
  setPrototypeOf: wn
} = Reflect, Ji = Proxy, {
  EPSILON: $i,
  MAX_SAFE_INTEGER: jr,
  isFinite: An,
  isNaN: qe
} = Number, {
  iterator: Ie,
  species: Qi,
  toStringTag: br,
  for: ji
} = Symbol, Ve = Object, {
  create: $t,
  defineProperty: gt,
  freeze: Ki,
  is: Kr
} = Ve, Ar = Ve.prototype, es = (
  /** @type {any} */
  Ar.__lookupGetter__ ? Z(
    /** @type {any} */
    Ar.__lookupGetter__
  ) : (r, e) => {
    if (r == null)
      throw X(
        pr
      );
    let i = Ve(r);
    do {
      const s = Ye(i, e);
      if (s !== void 0)
        return Ce(s, "get") ? s.get : void 0;
    } while ((i = At(i)) !== null);
  }
), Ce = (
  /** @type {any} */
  Ve.hasOwn || Z(Ar.hasOwnProperty)
), gn = Array, Sn = gn.isArray, Qt = gn.prototype, ts = Z(Qt.join), rs = Z(Qt.push), ns = Z(
  Qt.toLocaleString
), Nr = Qt[Ie], is = Z(Nr), {
  abs: ss,
  trunc: Tn
} = Math, jt = ArrayBuffer, os = jt.isView, En = jt.prototype, as = Z(En.slice), cs = $e(En, "byteLength"), gr = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : null, ls = gr && $e(gr.prototype, "byteLength"), Or = At(Uint8Array), us = Or.from, Q = Or.prototype, hs = Q[Ie], fs = Z(Q.keys), vs = Z(
  Q.values
), ys = Z(
  Q.entries
), ps = Z(Q.set), en = Z(
  Q.reverse
), ds = Z(Q.fill), ws = Z(
  Q.copyWithin
), tn = Z(Q.sort), ot = Z(Q.slice), As = Z(
  Q.subarray
), $ = $e(
  Q,
  "buffer"
), Be = $e(
  Q,
  "byteOffset"
), x = $e(
  Q,
  "length"
), In = $e(
  Q,
  br
), gs = Uint8Array, ce = Uint16Array, rn = (...r) => ie(us, ce, r), Ur = Uint32Array, Ss = Float32Array, ze = At([][Ie]()), Kt = Z(ze.next), Ts = Z(function* () {
}().next), Es = At(ze), Is = DataView.prototype, _s = Z(
  Is.getUint16
), X = TypeError, lr = RangeError, _n = WeakSet, bn = _n.prototype, bs = Z(bn.add), Ns = Z(bn.has), er = WeakMap, mr = er.prototype, Zt = Z(mr.get), Os = Z(mr.has), Cr = Z(mr.set), Nn = new er(), Us = $t(null, {
  next: {
    value: function() {
      const e = Zt(Nn, this);
      return Kt(e);
    }
  },
  [Ie]: {
    value: function() {
      return this;
    }
  }
});
function ht(r) {
  if (r[Ie] === Nr && ze.next === Kt)
    return r;
  const e = $t(Us);
  return Cr(Nn, e, is(r)), e;
}
const On = new er(), Un = $t(Es, {
  next: {
    value: function() {
      const e = Zt(On, this);
      return Ts(e);
    },
    writable: !0,
    configurable: !0
  }
});
for (const r of dn(ze))
  r !== "next" && gt(Un, r, Ye(ze, r));
function nn(r) {
  const e = $t(Un);
  return Cr(On, e, r), e;
}
function Ht(r) {
  return r !== null && typeof r == "object" || typeof r == "function";
}
function sn(r) {
  return r !== null && typeof r == "object";
}
function Gt(r) {
  return In(r) !== void 0;
}
function Sr(r) {
  const e = In(r);
  return e === "BigInt64Array" || e === "BigUint64Array";
}
function ms(r) {
  try {
    return Sn(r) ? !1 : (cs(
      /** @type {any} */
      r
    ), !0);
  } catch {
    return !1;
  }
}
function mn(r) {
  if (gr === null)
    return !1;
  try {
    return ls(
      /** @type {any} */
      r
    ), !0;
  } catch {
    return !1;
  }
}
function Cs(r) {
  return ms(r) || mn(r);
}
function on(r) {
  return Sn(r) ? r[Ie] === Nr && ze.next === Kt : !1;
}
function Rs(r) {
  return Gt(r) ? r[Ie] === hs && ze.next === Kt : !1;
}
function Ft(r) {
  if (typeof r != "string")
    return !1;
  const e = +r;
  return r !== e + "" || !An(e) ? !1 : e === Tn(e);
}
const Wt = ji("__Float16Array__");
function xs(r) {
  if (!sn(r))
    return !1;
  const e = At(r);
  if (!sn(e))
    return !1;
  const i = e.constructor;
  if (i === void 0)
    return !1;
  if (!Ht(i))
    throw X(pn);
  return wr(i, Wt);
}
const Tr = 1 / $i;
function Fs(r) {
  return r + Tr - Tr;
}
const Cn = 6103515625e-14, Ls = 65504, Rn = 9765625e-10, an = Rn * Cn, Ps = Rn * Tr;
function Ms(r) {
  const e = +r;
  if (!An(e) || e === 0)
    return e;
  const i = e > 0 ? 1 : -1, s = ss(e);
  if (s < Cn)
    return i * Fs(s / an) * an;
  const o = (1 + Ps) * s, c = o - (o - s);
  return c > Ls || qe(c) ? i * (1 / 0) : i * c;
}
const xn = new jt(4), Fn = new Ss(xn), Ln = new Ur(xn), we = new ce(512), Ae = new gs(512);
for (let r = 0; r < 256; ++r) {
  const e = r - 127;
  e < -24 ? (we[r] = 0, we[r | 256] = 32768, Ae[r] = 24, Ae[r | 256] = 24) : e < -14 ? (we[r] = 1024 >> -e - 14, we[r | 256] = 1024 >> -e - 14 | 32768, Ae[r] = -e - 1, Ae[r | 256] = -e - 1) : e <= 15 ? (we[r] = e + 15 << 10, we[r | 256] = e + 15 << 10 | 32768, Ae[r] = 13, Ae[r | 256] = 13) : e < 128 ? (we[r] = 31744, we[r | 256] = 64512, Ae[r] = 24, Ae[r | 256] = 24) : (we[r] = 31744, we[r | 256] = 64512, Ae[r] = 13, Ae[r | 256] = 13);
}
function Ee(r) {
  Fn[0] = Ms(r);
  const e = Ln[0], i = e >> 23 & 511;
  return we[i] + ((e & 8388607) >> Ae[i]);
}
const Rr = new Ur(2048);
for (let r = 1; r < 1024; ++r) {
  let e = r << 13, i = 0;
  for (; !(e & 8388608); )
    e <<= 1, i -= 8388608;
  e &= -8388609, i += 947912704, Rr[r] = e | i;
}
for (let r = 1024; r < 2048; ++r)
  Rr[r] = 939524096 + (r - 1024 << 13);
const Qe = new Ur(64);
for (let r = 1; r < 31; ++r)
  Qe[r] = r << 23;
Qe[31] = 1199570944;
Qe[32] = 2147483648;
for (let r = 33; r < 63; ++r)
  Qe[r] = 2147483648 + (r - 32 << 23);
Qe[63] = 3347054592;
const Pn = new ce(64);
for (let r = 1; r < 64; ++r)
  r !== 32 && (Pn[r] = 1024);
function L(r) {
  const e = r >> 10;
  return Ln[0] = Rr[Pn[e] + (r & 1023)] + Qe[e], Fn[0];
}
function me(r) {
  const e = +r;
  return qe(e) || e === 0 ? 0 : Tn(e);
}
function ur(r) {
  const e = me(r);
  return e < 0 ? 0 : e < jr ? e : jr;
}
function Lt(r, e) {
  if (!Ht(r))
    throw X(Wi);
  const i = r.constructor;
  if (i === void 0)
    return e;
  if (!Ht(i))
    throw X(pn);
  const s = i[Qi];
  return s ?? e;
}
function yt(r) {
  if (mn(r))
    return !1;
  try {
    return as(r, 0, 0), !1;
  } catch {
  }
  return !0;
}
function cn(r, e) {
  const i = qe(r), s = qe(e);
  if (i && s)
    return 0;
  if (i)
    return 1;
  if (s || r < e)
    return -1;
  if (r > e)
    return 1;
  if (r === 0 && e === 0) {
    const o = Kr(r, 0), c = Kr(e, 0);
    if (!o && c)
      return -1;
    if (o && !c)
      return 1;
  }
  return 0;
}
const xr = 2, Xt = new er();
function Xe(r) {
  return Os(Xt, r) || !os(r) && xs(r);
}
function R(r) {
  if (!Xe(r))
    throw X(Xi);
}
function Pt(r, e) {
  const i = Xe(r), s = Gt(r);
  if (!i && !s)
    throw X(Yi);
  if (typeof e == "number") {
    let o;
    if (i) {
      const c = O(r);
      o = x(c);
    } else
      o = x(r);
    if (o < e)
      throw X(
        qi
      );
  }
  if (Sr(r))
    throw X(dr);
}
function O(r) {
  const e = Zt(Xt, r);
  if (e !== void 0) {
    const o = $(e);
    if (yt(o))
      throw X(vt);
    return e;
  }
  const i = (
    /** @type {any} */
    r.buffer
  );
  if (yt(i))
    throw X(vt);
  const s = ut(P, [
    i,
    /** @type {any} */
    r.byteOffset,
    /** @type {any} */
    r.length
  ], r.constructor);
  return Zt(Xt, s);
}
function ln(r) {
  const e = x(r), i = [];
  for (let s = 0; s < e; ++s)
    i[s] = L(r[s]);
  return i;
}
const Mn = new _n();
for (const r of dn(Q)) {
  if (r === br)
    continue;
  const e = Ye(Q, r);
  Ce(e, "get") && typeof e.get == "function" && bs(Mn, e.get);
}
const Ds = Ki(
  /** @type {ProxyHandler<Float16BitsArray>} */
  {
    get(r, e, i) {
      return Ft(e) && Ce(r, e) ? L(cr(r, e)) : Ns(Mn, es(r, e)) ? cr(r, e) : cr(r, e, i);
    },
    set(r, e, i, s) {
      return Ft(e) && Ce(r, e) ? Qr(r, e, Ee(i)) : Qr(r, e, i, s);
    },
    getOwnPropertyDescriptor(r, e) {
      if (Ft(e) && Ce(r, e)) {
        const i = Ye(r, e);
        return i.value = L(i.value), i;
      }
      return Ye(r, e);
    },
    defineProperty(r, e, i) {
      return Ft(e) && Ce(r, e) && Ce(i, "value") && (i.value = Ee(i.value)), $r(r, e, i);
    }
  }
);
class P {
  /** @see https://tc39.es/ecma262/#sec-typedarray */
  constructor(e, i, s) {
    let o;
    if (Xe(e))
      o = ut(ce, [O(e)], new.target);
    else if (Ht(e) && !Cs(e)) {
      let l, v;
      if (Gt(e)) {
        l = e, v = x(e);
        const y = $(e);
        if (yt(y))
          throw X(vt);
        if (Sr(e))
          throw X(dr);
        const E = new jt(
          v * xr
        );
        o = ut(ce, [E], new.target);
      } else {
        const y = e[Ie];
        if (y != null && typeof y != "function")
          throw X(Vr);
        y != null ? on(e) ? (l = e, v = e.length) : (l = [.../** @type {Iterable<unknown>} */
        e], v = l.length) : (l = /** @type {ArrayLike<unknown>} */
        e, v = ur(l.length)), o = ut(ce, [v], new.target);
      }
      for (let y = 0; y < v; ++y)
        o[y] = Ee(l[y]);
    } else
      o = ut(ce, arguments, new.target);
    const c = (
      /** @type {any} */
      new Ji(o, Ds)
    );
    return Cr(Xt, c, o), c;
  }
  /**
   * limitation: `Object.getOwnPropertyNames(Float16Array)` or `Reflect.ownKeys(Float16Array)` include this key
   * @see https://tc39.es/ecma262/#sec-%typedarray%.from
   */
  static from(e, ...i) {
    const s = this;
    if (!wr(s, Wt))
      throw X(
        qr
      );
    if (s === P) {
      if (Xe(e) && i.length === 0) {
        const b = O(e), m = new ce(
          $(b),
          Be(b),
          x(b)
        );
        return new P(
          $(ot(m))
        );
      }
      if (i.length === 0)
        return new P(
          $(
            rn(e, Ee)
          )
        );
      const y = i[0], E = i[1];
      return new P(
        $(
          rn(e, function(b, ...m) {
            return Ee(
              ie(y, this, [b, ...ht(m)])
            );
          }, E)
        )
      );
    }
    let o, c;
    const l = e[Ie];
    if (l != null && typeof l != "function")
      throw X(Vr);
    if (l != null)
      on(e) ? (o = e, c = e.length) : Rs(e) ? (o = e, c = x(e)) : (o = [...e], c = o.length);
    else {
      if (e == null)
        throw X(
          pr
        );
      o = Ve(e), c = ur(o.length);
    }
    const v = new s(c);
    if (i.length === 0)
      for (let y = 0; y < c; ++y)
        v[y] = /** @type {number} */
        o[y];
    else {
      const y = i[0], E = i[1];
      for (let b = 0; b < c; ++b)
        v[b] = ie(y, E, [o[b], b]);
    }
    return v;
  }
  /**
   * limitation: `Object.getOwnPropertyNames(Float16Array)` or `Reflect.ownKeys(Float16Array)` include this key
   * @see https://tc39.es/ecma262/#sec-%typedarray%.of
   */
  static of(...e) {
    const i = this;
    if (!wr(i, Wt))
      throw X(
        qr
      );
    const s = e.length;
    if (i === P) {
      const c = new P(s), l = O(c);
      for (let v = 0; v < s; ++v)
        l[v] = Ee(e[v]);
      return c;
    }
    const o = new i(s);
    for (let c = 0; c < s; ++c)
      o[c] = e[c];
    return o;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.keys */
  keys() {
    R(this);
    const e = O(this);
    return fs(e);
  }
  /**
   * limitation: returns a object whose prototype is not `%ArrayIteratorPrototype%`
   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.values
   */
  values() {
    R(this);
    const e = O(this);
    return nn(function* () {
      for (const i of vs(e))
        yield L(i);
    }());
  }
  /**
   * limitation: returns a object whose prototype is not `%ArrayIteratorPrototype%`
   * @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.entries
   */
  entries() {
    R(this);
    const e = O(this);
    return nn(function* () {
      for (const [i, s] of ys(e))
        yield (
          /** @type {[number, number]} */
          [i, L(s)]
        );
    }());
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.at */
  at(e) {
    R(this);
    const i = O(this), s = x(i), o = me(e), c = o >= 0 ? o : s + o;
    if (!(c < 0 || c >= s))
      return L(i[c]);
  }
  /** @see https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.with */
  with(e, i) {
    R(this);
    const s = O(this), o = x(s), c = me(e), l = c >= 0 ? c : o + c, v = +i;
    if (l < 0 || l >= o)
      throw lr(ar);
    const y = new ce(
      $(s),
      Be(s),
      x(s)
    ), E = new P(
      $(
        ot(y)
      )
    ), b = O(E);
    return b[l] = Ee(v), E;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.map */
  map(e, ...i) {
    R(this);
    const s = O(this), o = x(s), c = i[0], l = Lt(s, P);
    if (l === P) {
      const y = new P(o), E = O(y);
      for (let b = 0; b < o; ++b) {
        const m = L(s[b]);
        E[b] = Ee(
          ie(e, c, [m, b, this])
        );
      }
      return y;
    }
    const v = new l(o);
    Pt(v, o);
    for (let y = 0; y < o; ++y) {
      const E = L(s[y]);
      v[y] = ie(e, c, [E, y, this]);
    }
    return (
      /** @type {any} */
      v
    );
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.filter */
  filter(e, ...i) {
    R(this);
    const s = O(this), o = x(s), c = i[0], l = [];
    for (let E = 0; E < o; ++E) {
      const b = L(s[E]);
      ie(e, c, [b, E, this]) && rs(l, b);
    }
    const v = Lt(s, P), y = new v(l);
    return Pt(y), /** @type {any} */
    y;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduce */
  reduce(e, ...i) {
    R(this);
    const s = O(this), o = x(s);
    if (o === 0 && i.length === 0)
      throw X(Jr);
    let c, l;
    i.length === 0 ? (c = L(s[0]), l = 1) : (c = i[0], l = 0);
    for (let v = l; v < o; ++v)
      c = e(
        c,
        L(s[v]),
        v,
        this
      );
    return c;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduceright */
  reduceRight(e, ...i) {
    R(this);
    const s = O(this), o = x(s);
    if (o === 0 && i.length === 0)
      throw X(Jr);
    let c, l;
    i.length === 0 ? (c = L(s[o - 1]), l = o - 2) : (c = i[0], l = o - 1);
    for (let v = l; v >= 0; --v)
      c = e(
        c,
        L(s[v]),
        v,
        this
      );
    return c;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.foreach */
  forEach(e, ...i) {
    R(this);
    const s = O(this), o = x(s), c = i[0];
    for (let l = 0; l < o; ++l)
      ie(e, c, [
        L(s[l]),
        l,
        this
      ]);
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.find */
  find(e, ...i) {
    R(this);
    const s = O(this), o = x(s), c = i[0];
    for (let l = 0; l < o; ++l) {
      const v = L(s[l]);
      if (ie(e, c, [v, l, this]))
        return v;
    }
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.findindex */
  findIndex(e, ...i) {
    R(this);
    const s = O(this), o = x(s), c = i[0];
    for (let l = 0; l < o; ++l) {
      const v = L(s[l]);
      if (ie(e, c, [v, l, this]))
        return l;
    }
    return -1;
  }
  /** @see https://tc39.es/proposal-array-find-from-last/index.html#sec-%typedarray%.prototype.findlast */
  findLast(e, ...i) {
    R(this);
    const s = O(this), o = x(s), c = i[0];
    for (let l = o - 1; l >= 0; --l) {
      const v = L(s[l]);
      if (ie(e, c, [v, l, this]))
        return v;
    }
  }
  /** @see https://tc39.es/proposal-array-find-from-last/index.html#sec-%typedarray%.prototype.findlastindex */
  findLastIndex(e, ...i) {
    R(this);
    const s = O(this), o = x(s), c = i[0];
    for (let l = o - 1; l >= 0; --l) {
      const v = L(s[l]);
      if (ie(e, c, [v, l, this]))
        return l;
    }
    return -1;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.every */
  every(e, ...i) {
    R(this);
    const s = O(this), o = x(s), c = i[0];
    for (let l = 0; l < o; ++l)
      if (!ie(e, c, [
        L(s[l]),
        l,
        this
      ]))
        return !1;
    return !0;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.some */
  some(e, ...i) {
    R(this);
    const s = O(this), o = x(s), c = i[0];
    for (let l = 0; l < o; ++l)
      if (ie(e, c, [
        L(s[l]),
        l,
        this
      ]))
        return !0;
    return !1;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.set */
  set(e, ...i) {
    R(this);
    const s = O(this), o = me(i[0]);
    if (o < 0)
      throw lr(ar);
    if (e == null)
      throw X(
        pr
      );
    if (Sr(e))
      throw X(
        dr
      );
    if (Xe(e))
      return ps(
        O(this),
        O(e),
        o
      );
    if (Gt(e)) {
      const y = $(e);
      if (yt(y))
        throw X(vt);
    }
    const c = x(s), l = Ve(e), v = ur(l.length);
    if (o === 1 / 0 || v + o > c)
      throw lr(ar);
    for (let y = 0; y < v; ++y)
      s[y + o] = Ee(l[y]);
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.reverse */
  reverse() {
    R(this);
    const e = O(this);
    return en(e), this;
  }
  /** @see https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.toReversed */
  toReversed() {
    R(this);
    const e = O(this), i = new ce(
      $(e),
      Be(e),
      x(e)
    ), s = new P(
      $(
        ot(i)
      )
    ), o = O(s);
    return en(o), s;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill */
  fill(e, ...i) {
    R(this);
    const s = O(this);
    return ds(
      s,
      Ee(e),
      ...ht(i)
    ), this;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.copywithin */
  copyWithin(e, i, ...s) {
    R(this);
    const o = O(this);
    return ws(o, e, i, ...ht(s)), this;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort */
  sort(e) {
    R(this);
    const i = O(this), s = e !== void 0 ? e : cn;
    return tn(i, (o, c) => s(L(o), L(c))), this;
  }
  /** @see https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.toSorted */
  toSorted(e) {
    R(this);
    const i = O(this);
    if (e !== void 0 && typeof e != "function")
      throw new X(Vi);
    const s = e !== void 0 ? e : cn, o = new ce(
      $(i),
      Be(i),
      x(i)
    ), c = new P(
      $(
        ot(o)
      )
    ), l = O(c);
    return tn(l, (v, y) => s(L(v), L(y))), c;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice */
  slice(e, i) {
    R(this);
    const s = O(this), o = Lt(s, P);
    if (o === P) {
      const Ze = new ce(
        $(s),
        Be(s),
        x(s)
      );
      return new P(
        $(
          ot(Ze, e, i)
        )
      );
    }
    const c = x(s), l = me(e), v = i === void 0 ? c : me(i);
    let y;
    l === -1 / 0 ? y = 0 : l < 0 ? y = c + l > 0 ? c + l : 0 : y = c < l ? c : l;
    let E;
    v === -1 / 0 ? E = 0 : v < 0 ? E = c + v > 0 ? c + v : 0 : E = c < v ? c : v;
    const b = E - y > 0 ? E - y : 0, m = new o(b);
    if (Pt(m, b), b === 0)
      return m;
    const q = $(s);
    if (yt(q))
      throw X(vt);
    let se = 0;
    for (; y < E; )
      m[se] = L(s[y]), ++y, ++se;
    return (
      /** @type {any} */
      m
    );
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.subarray */
  subarray(e, i) {
    R(this);
    const s = O(this), o = Lt(s, P), c = new ce(
      $(s),
      Be(s),
      x(s)
    ), l = As(c, e, i), v = new o(
      $(l),
      Be(l),
      x(l)
    );
    return Pt(v), /** @type {any} */
    v;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.indexof */
  indexOf(e, ...i) {
    R(this);
    const s = O(this), o = x(s);
    let c = me(i[0]);
    if (c === 1 / 0)
      return -1;
    c < 0 && (c += o, c < 0 && (c = 0));
    for (let l = c; l < o; ++l)
      if (Ce(s, l) && L(s[l]) === e)
        return l;
    return -1;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.lastindexof */
  lastIndexOf(e, ...i) {
    R(this);
    const s = O(this), o = x(s);
    let c = i.length >= 1 ? me(i[0]) : o - 1;
    if (c === -1 / 0)
      return -1;
    c >= 0 ? c = c < o - 1 ? c : o - 1 : c += o;
    for (let l = c; l >= 0; --l)
      if (Ce(s, l) && L(s[l]) === e)
        return l;
    return -1;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.includes */
  includes(e, ...i) {
    R(this);
    const s = O(this), o = x(s);
    let c = me(i[0]);
    if (c === 1 / 0)
      return !1;
    c < 0 && (c += o, c < 0 && (c = 0));
    const l = qe(e);
    for (let v = c; v < o; ++v) {
      const y = L(s[v]);
      if (l && qe(y) || y === e)
        return !0;
    }
    return !1;
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.join */
  join(e) {
    R(this);
    const i = O(this), s = ln(i);
    return ts(s, e);
  }
  /** @see https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring */
  toLocaleString(...e) {
    R(this);
    const i = O(this), s = ln(i);
    return ns(s, ...ht(e));
  }
  /** @see https://tc39.es/ecma262/#sec-get-%typedarray%.prototype-@@tostringtag */
  get [br]() {
    if (Xe(this))
      return (
        /** @type {any} */
        "Float16Array"
      );
  }
}
gt(P, "BYTES_PER_ELEMENT", {
  value: xr
});
gt(P, Wt, {});
wn(P, Or);
const Yt = P.prototype;
gt(Yt, "BYTES_PER_ELEMENT", {
  value: xr
});
gt(Yt, Ie, {
  value: Yt.values,
  writable: !0,
  configurable: !0
});
wn(Yt, Q);
function Bs(r, e, ...i) {
  return L(
    _s(r, e, ...ht(i))
  );
}
function bo(r) {
  const e = r instanceof Int8Array ? "int8" : r instanceof Uint8Array || r instanceof Uint8ClampedArray ? "uint8" : r instanceof Int16Array ? "int16" : r instanceof Uint16Array ? "uint16" : r instanceof Int32Array ? "int32" : r instanceof Uint32Array ? "uint32" : r instanceof P ? "float16" : r instanceof Float32Array ? "float32" : r instanceof Float64Array ? "float64" : null;
  return _r(e != null), e;
}
function No(r) {
  return r instanceof Int8Array || r instanceof Uint8Array || r instanceof Uint8ClampedArray || r instanceof Int16Array || r instanceof Uint16Array || r instanceof Int32Array || r instanceof Uint32Array || r instanceof P || r instanceof Float32Array || r instanceof Float64Array;
}
let Mt;
function zs() {
  if (Mt != null)
    return Mt;
  const r = new Uint32Array([268435456]);
  return Mt = new Uint8Array(r.buffer, r.byteOffset, r.byteLength)[0] === 0, Mt;
}
function ke(r, e, i, s = !0) {
  if (s === zs())
    return new e(r);
  const o = Object.assign(new DataView(r), {
    getFloat16(l, v) {
      return Bs(this, l, v);
    }
  }), c = new e(o.byteLength / e.BYTES_PER_ELEMENT);
  for (let l = 0, v = 0; l < c.length; ++l, v += e.BYTES_PER_ELEMENT)
    c[l] = o[i](v, s);
  return c;
}
const ks = (r) => new Uint8Array(r), Oo = (r) => new Int8Array(r), Zs = (r, e) => ke(r, Uint16Array, "getUint16", e), Hs = (r, e) => ke(r, Int16Array, "getInt16", e), Uo = (r, e) => ke(r, Int32Array, "getInt32", e), mo = (r, e) => ke(r, Uint32Array, "getUint32", e), Co = (r, e) => ke(r, P, "getFloat16", e), Gs = (r, e) => ke(r, Float32Array, "getFloat32", e), Ro = (r, e) => ke(r, Float64Array, "getFloat64", e);
class Ws extends Vt {
  load(e, i, s, o) {
    const c = new ki(this.manager);
    c.setRequestHeader(this.requestHeader), c.setPath(this.path), c.setWithCredentials(this.withCredentials), c.load(
      e,
      (l) => {
        try {
          i(this.parseTypedArray(l));
        } catch (v) {
          o != null ? o(v) : console.error(v), this.manager.itemError(e);
        }
      },
      s,
      o
    );
  }
}
function St(r) {
  return class extends Ws {
    constructor() {
      super(...arguments), this.parseTypedArray = r;
    }
  };
}
function xo(r) {
  return new (St(r))();
}
const Fo = /* @__PURE__ */ St(Hs), Lo = /* @__PURE__ */ St(Zs), Po = /* @__PURE__ */ St(Gs);
function Xs(r) {
  const e = r instanceof Int8Array ? Ui : r instanceof Uint8Array ? Hr : r instanceof Uint8ClampedArray ? Hr : r instanceof Int16Array ? mi : r instanceof Uint16Array ? Ci : r instanceof Int32Array ? Ri : r instanceof Uint32Array ? xi : r instanceof P ? lt : r instanceof Float32Array ? ft : r instanceof Float64Array ? ft : null;
  return _r(e != null), e;
}
const Ys = {
  format: hn,
  minFilter: kt,
  magFilter: kt
};
class qs extends Vt {
  constructor() {
    super(...arguments), this.parameters = {};
  }
  load(e, i, s, o) {
    const c = new this.Texture(), l = new this.TypedArrayLoader(this.manager);
    l.setRequestHeader(this.requestHeader), l.setPath(this.path), l.setWithCredentials(this.withCredentials), l.load(
      e,
      (v) => {
        c.image.data = v instanceof P ? new Uint16Array(v.buffer) : v;
        const { width: y, height: E, depth: b, ...m } = this.parameters;
        y != null && (c.image.width = y), E != null && (c.image.height = E), "depth" in c.image && b != null && (c.image.depth = b), c.type = Xs(v), Object.assign(c, m), c.needsUpdate = !0, i(c);
      },
      s,
      o
    );
  }
}
function Dn(r, e, i) {
  return class extends qs {
    constructor() {
      super(...arguments), this.Texture = r, this.TypedArrayLoader = St(e), this.parameters = {
        ...Ys,
        ...i
      };
    }
  };
}
function Bn(r, e) {
  return Dn(fn, r, e);
}
function Vs(r, e) {
  return Dn(Fi, r, e);
}
function Mo(r, e) {
  return new (Bn(r, e))();
}
function Do(r, e) {
  return new (Vs(r, e))();
}
const Je = ye.clamp, Bo = ye.euclideanModulo, zo = ye.inverseLerp, ko = ye.lerp, Zo = ye.degToRad, Ho = ye.radToDeg, Go = ye.isPowerOfTwo, Wo = ye.ceilPowerOfTwo, Xo = ye.floorPowerOfTwo, Yo = ye.normalize;
function qo(r, e, i, s = 0, o = 1) {
  return ye.mapLinear(r, e, i, s, o);
}
function Vo(r, e, i, s = 0, o = 1) {
  return Je(ye.mapLinear(r, e, i, s, o), s, o);
}
function Jo(r, e, i) {
  return i <= r ? 0 : i >= e ? 1 : (i = (i - r) / (e - r), i * i * (3 - 2 * i));
}
function $o(r) {
  return Math.min(Math.max(r, 0), 1);
}
function Qo(r, e, i, s = i) {
  const o = Math.abs(r - e);
  return o <= s || o <= i * Math.max(Math.abs(r), Math.abs(e));
}
function jo(r) {
  return (e, i) => {
    e instanceof Jt ? Object.defineProperty(e, i, {
      enumerable: !0,
      get() {
        var s;
        return ((s = this.defines) == null ? void 0 : s[r]) != null;
      },
      set(s) {
        var o;
        s !== this[i] && (s ? (this.defines ?? (this.defines = {}), this.defines[r] = "1") : (o = this.defines) == null || delete o[r], this.needsUpdate = !0);
      }
    }) : Object.defineProperty(e, i, {
      enumerable: !0,
      get() {
        return this.defines.has(r);
      },
      set(s) {
        s !== this[i] && (s ? this.defines.set(r, "1") : this.defines.delete(r), this.setChanged());
      }
    });
  };
}
function Ko(r, {
  min: e = Number.MIN_SAFE_INTEGER,
  max: i = Number.MAX_SAFE_INTEGER
} = {}) {
  return (s, o) => {
    s instanceof Jt ? Object.defineProperty(s, o, {
      enumerable: !0,
      get() {
        var l;
        const c = (l = this.defines) == null ? void 0 : l[r];
        return c != null ? parseInt(c) : 0;
      },
      set(c) {
        const l = this[o];
        c !== l && (this.defines ?? (this.defines = {}), this.defines[r] = Je(c, e, i).toFixed(0), this.needsUpdate = !0);
      }
    }) : Object.defineProperty(s, o, {
      enumerable: !0,
      get() {
        const c = this.defines.get(r);
        return c != null ? parseInt(c) : 0;
      },
      set(c) {
        const l = this[o];
        c !== l && (this.defines.set(r, Je(c, e, i).toFixed(0)), this.setChanged());
      }
    });
  };
}
function ea(r, {
  min: e = -1 / 0,
  max: i = 1 / 0,
  precision: s = 7
} = {}) {
  return (o, c) => {
    o instanceof Jt ? Object.defineProperty(o, c, {
      enumerable: !0,
      get() {
        var v;
        const l = (v = this.defines) == null ? void 0 : v[r];
        return l != null ? parseFloat(l) : 0;
      },
      set(l) {
        const v = this[c];
        l !== v && (this.defines ?? (this.defines = {}), this.defines[r] = Je(l, e, i).toFixed(s), this.needsUpdate = !0);
      }
    }) : Object.defineProperty(o, c, {
      enumerable: !0,
      get() {
        const l = this.defines.get(r);
        return l != null ? parseFloat(l) : 0;
      },
      set(l) {
        const v = this[c];
        l !== v && (this.defines.set(r, Je(l, e, i).toFixed(s)), this.setChanged());
      }
    });
  };
}
function ta(r, { validate: e } = {}) {
  return (i, s) => {
    i instanceof Jt ? Object.defineProperty(i, s, {
      enumerable: !0,
      get() {
        var o;
        return ((o = this.defines) == null ? void 0 : o[r]) ?? "";
      },
      set(o) {
        if (o !== this[s]) {
          if ((e == null ? void 0 : e(o)) === !1) {
            console.error(`Expression validation failed: ${o}`);
            return;
          }
          this.defines ?? (this.defines = {}), this.defines[r] = o, this.needsUpdate = !0;
        }
      }
    }) : Object.defineProperty(i, s, {
      enumerable: !0,
      get() {
        return this.defines.get(r) ?? "";
      },
      set(o) {
        if (o !== this[s]) {
          if ((e == null ? void 0 : e(o)) === !1) {
            console.error(`Expression validation failed: ${o}`);
            return;
          }
          this.defines.set(r, o), this.setChanged();
        }
      }
    });
  };
}
function ra(r, ...e) {
  const i = {};
  for (let s = 0; s < e.length; s += 2) {
    const o = e[s], c = e[s + 1];
    for (const l of c)
      i[l] = {
        enumerable: !0,
        get: () => o[l],
        set: (v) => {
          o[l] = v;
        }
      };
  }
  return Object.defineProperties(r, i), r;
}
function na(r, e, i) {
  const s = {};
  for (const o of i)
    s[o] = {
      enumerable: !0,
      get: () => e.uniforms[o].value,
      set: (c) => {
        e.uniforms[o].value = c;
      }
    };
  return Object.defineProperties(r, s), r;
}
const Js = parseInt(Li.replace(/\D+/g, ""));
var ve = Uint8Array, Le = Uint16Array, Er = Uint32Array, zn = new ve([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), kn = new ve([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), $s = new ve([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Zn = function(r, e) {
  for (var i = new Le(31), s = 0; s < 31; ++s)
    i[s] = e += 1 << r[s - 1];
  for (var o = new Er(i[30]), s = 1; s < 30; ++s)
    for (var c = i[s]; c < i[s + 1]; ++c)
      o[c] = c - i[s] << 5 | s;
  return [i, o];
}, Hn = Zn(zn, 2), Gn = Hn[0], Qs = Hn[1];
Gn[28] = 258, Qs[258] = 28;
var js = Zn(kn, 0), Ks = js[0], Ir = new Le(32768);
for (var G = 0; G < 32768; ++G) {
  var Fe = (G & 43690) >>> 1 | (G & 21845) << 1;
  Fe = (Fe & 52428) >>> 2 | (Fe & 13107) << 2, Fe = (Fe & 61680) >>> 4 | (Fe & 3855) << 4, Ir[G] = ((Fe & 65280) >>> 8 | (Fe & 255) << 8) >>> 1;
}
var pt = function(r, e, i) {
  for (var s = r.length, o = 0, c = new Le(e); o < s; ++o)
    ++c[r[o] - 1];
  var l = new Le(e);
  for (o = 0; o < e; ++o)
    l[o] = l[o - 1] + c[o - 1] << 1;
  var v;
  if (i) {
    v = new Le(1 << e);
    var y = 15 - e;
    for (o = 0; o < s; ++o)
      if (r[o])
        for (var E = o << 4 | r[o], b = e - r[o], m = l[r[o] - 1]++ << b, q = m | (1 << b) - 1; m <= q; ++m)
          v[Ir[m] >>> y] = E;
  } else
    for (v = new Le(s), o = 0; o < s; ++o)
      r[o] && (v[o] = Ir[l[r[o] - 1]++] >>> 15 - r[o]);
  return v;
}, Tt = new ve(288);
for (var G = 0; G < 144; ++G)
  Tt[G] = 8;
for (var G = 144; G < 256; ++G)
  Tt[G] = 9;
for (var G = 256; G < 280; ++G)
  Tt[G] = 7;
for (var G = 280; G < 288; ++G)
  Tt[G] = 8;
var Wn = new ve(32);
for (var G = 0; G < 32; ++G)
  Wn[G] = 5;
var eo = /* @__PURE__ */ pt(Tt, 9, 1), to = /* @__PURE__ */ pt(Wn, 5, 1), hr = function(r) {
  for (var e = r[0], i = 1; i < r.length; ++i)
    r[i] > e && (e = r[i]);
  return e;
}, de = function(r, e, i) {
  var s = e / 8 | 0;
  return (r[s] | r[s + 1] << 8) >> (e & 7) & i;
}, fr = function(r, e) {
  var i = e / 8 | 0;
  return (r[i] | r[i + 1] << 8 | r[i + 2] << 16) >> (e & 7);
}, ro = function(r) {
  return (r / 8 | 0) + (r & 7 && 1);
}, no = function(r, e, i) {
  (i == null || i > r.length) && (i = r.length);
  var s = new (r instanceof Le ? Le : r instanceof Er ? Er : ve)(i - e);
  return s.set(r.subarray(e, i)), s;
}, io = function(r, e, i) {
  var s = r.length;
  if (!s || i && !i.l && s < 5)
    return e || new ve(0);
  var o = !e || i, c = !i || i.i;
  i || (i = {}), e || (e = new ve(s * 3));
  var l = function(M) {
    var be = e.length;
    if (M > be) {
      var Ne = new ve(Math.max(be * 2, M));
      Ne.set(e), e = Ne;
    }
  }, v = i.f || 0, y = i.p || 0, E = i.b || 0, b = i.l, m = i.d, q = i.m, se = i.n, Ze = s * 8;
  do {
    if (!b) {
      i.f = v = de(r, y, 1);
      var Et = de(r, y + 1, 3);
      if (y += 3, Et)
        if (Et == 1)
          b = eo, m = to, q = 9, se = 5;
        else if (Et == 2) {
          var bt = de(r, y, 31) + 257, tr = de(r, y + 10, 15) + 4, rr = bt + de(r, y + 5, 31) + 1;
          y += 14;
          for (var He = new ve(rr), Nt = new ve(19), oe = 0; oe < tr; ++oe)
            Nt[$s[oe]] = de(r, y + oe * 3, 7);
          y += tr * 3;
          for (var Ot = hr(Nt), nr = (1 << Ot) - 1, ir = pt(Nt, Ot, 1), oe = 0; oe < rr; ) {
            var le = ir[de(r, y, nr)];
            y += le & 15;
            var pe = le >>> 4;
            if (pe < 16)
              He[oe++] = pe;
            else {
              var _e = 0, ge = 0;
              for (pe == 16 ? (ge = 3 + de(r, y, 3), y += 2, _e = He[oe - 1]) : pe == 17 ? (ge = 3 + de(r, y, 7), y += 3) : pe == 18 && (ge = 11 + de(r, y, 127), y += 7); ge--; )
                He[oe++] = _e;
            }
          }
          var Ut = He.subarray(0, bt), Se = He.subarray(bt);
          q = hr(Ut), se = hr(Se), b = pt(Ut, q, 1), m = pt(Se, se, 1);
        } else
          throw "invalid block type";
      else {
        var pe = ro(y) + 4, It = r[pe - 4] | r[pe - 3] << 8, _t = pe + It;
        if (_t > s) {
          if (c)
            throw "unexpected EOF";
          break;
        }
        o && l(E + It), e.set(r.subarray(pe, _t), E), i.b = E += It, i.p = y = _t * 8;
        continue;
      }
      if (y > Ze) {
        if (c)
          throw "unexpected EOF";
        break;
      }
    }
    o && l(E + 131072);
    for (var mt = (1 << q) - 1, Ct = (1 << se) - 1, je = y; ; je = y) {
      var _e = b[fr(r, y) & mt], ee = _e >>> 4;
      if (y += _e & 15, y > Ze) {
        if (c)
          throw "unexpected EOF";
        break;
      }
      if (!_e)
        throw "invalid length/literal";
      if (ee < 256)
        e[E++] = ee;
      else if (ee == 256) {
        je = y, b = null;
        break;
      } else {
        var Ge = ee - 254;
        if (ee > 264) {
          var oe = ee - 257, re = zn[oe];
          Ge = de(r, y, (1 << re) - 1) + Gn[oe], y += re;
        }
        var Pe = m[fr(r, y) & Ct], Me = Pe >>> 4;
        if (!Pe)
          throw "invalid distance";
        y += Pe & 15;
        var Se = Ks[Me];
        if (Me > 3) {
          var re = kn[Me];
          Se += fr(r, y) & (1 << re) - 1, y += re;
        }
        if (y > Ze) {
          if (c)
            throw "unexpected EOF";
          break;
        }
        o && l(E + 131072);
        for (var Ke = E + Ge; E < Ke; E += 4)
          e[E] = e[E - Se], e[E + 1] = e[E + 1 - Se], e[E + 2] = e[E + 2 - Se], e[E + 3] = e[E + 3 - Se];
        E = Ke;
      }
    }
    i.l = b, i.p = je, i.b = E, b && (v = 1, i.m = q, i.d = m, i.n = se);
  } while (!v);
  return E == e.length ? e : no(e, 0, E);
}, so = /* @__PURE__ */ new ve(0), oo = function(r) {
  if ((r[0] & 15) != 8 || r[0] >>> 4 > 7 || (r[0] << 8 | r[1]) % 31)
    throw "invalid zlib data";
  if (r[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function Dt(r, e) {
  return io((oo(r), r.subarray(2, -4)), e);
}
var ao = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), co = 0;
try {
  ao.decode(so, { stream: !0 }), co = 1;
} catch {
}
const at = Js >= 152;
class lo extends Pi {
  constructor(e) {
    super(e), this.type = lt;
  }
  parse(e) {
    const Ot = Math.pow(2.7182818, 2.2);
    function nr(t, n) {
      for (var a = 0, u = 0; u < 65536; ++u)
        (u == 0 || t[u >> 3] & 1 << (u & 7)) && (n[a++] = u);
      for (var h = a - 1; a < 65536; )
        n[a++] = 0;
      return h;
    }
    function ir(t) {
      for (var n = 0; n < 16384; n++)
        t[n] = {}, t[n].len = 0, t[n].lit = 0, t[n].p = null;
    }
    const le = { l: 0, c: 0, lc: 0 };
    function _e(t, n, a, u, h) {
      for (; a < t; )
        n = n << 8 | zr(u, h), a += 8;
      a -= t, le.l = n >> a & (1 << t) - 1, le.c = n, le.lc = a;
    }
    const ge = new Array(59);
    function Ut(t) {
      for (var n = 0; n <= 58; ++n)
        ge[n] = 0;
      for (var n = 0; n < 65537; ++n)
        ge[t[n]] += 1;
      for (var a = 0, n = 58; n > 0; --n) {
        var u = a + ge[n] >> 1;
        ge[n] = a, a = u;
      }
      for (var n = 0; n < 65537; ++n) {
        var h = t[n];
        h > 0 && (t[n] = h | ge[h]++ << 6);
      }
    }
    function Se(t, n, a, u, h, f, d) {
      for (var p = a, g = 0, A = 0; h <= f; h++) {
        if (p.value - a.value > u)
          return !1;
        _e(6, g, A, t, p);
        var S = le.l;
        if (g = le.c, A = le.lc, d[h] = S, S == 63) {
          if (p.value - a.value > u)
            throw "Something wrong with hufUnpackEncTable";
          _e(8, g, A, t, p);
          var w = le.l + 6;
          if (g = le.c, A = le.lc, h + w > f + 1)
            throw "Something wrong with hufUnpackEncTable";
          for (; w--; )
            d[h++] = 0;
          h--;
        } else if (S >= 59) {
          var w = S - 59 + 2;
          if (h + w > f + 1)
            throw "Something wrong with hufUnpackEncTable";
          for (; w--; )
            d[h++] = 0;
          h--;
        }
      }
      Ut(d);
    }
    function mt(t) {
      return t & 63;
    }
    function Ct(t) {
      return t >> 6;
    }
    function je(t, n, a, u) {
      for (; n <= a; n++) {
        var h = Ct(t[n]), f = mt(t[n]);
        if (h >> f)
          throw "Invalid table entry";
        if (f > 14) {
          var d = u[h >> f - 14];
          if (d.len)
            throw "Invalid table entry";
          if (d.lit++, d.p) {
            var p = d.p;
            d.p = new Array(d.lit);
            for (var g = 0; g < d.lit - 1; ++g)
              d.p[g] = p[g];
          } else
            d.p = new Array(1);
          d.p[d.lit - 1] = n;
        } else if (f)
          for (var A = 0, g = 1 << 14 - f; g > 0; g--) {
            var d = u[(h << 14 - f) + A];
            if (d.len || d.p)
              throw "Invalid table entry";
            d.len = f, d.lit = n, A++;
          }
      }
      return !0;
    }
    const ee = { c: 0, lc: 0 };
    function Ge(t, n, a, u) {
      t = t << 8 | zr(a, u), n += 8, ee.c = t, ee.lc = n;
    }
    const re = { c: 0, lc: 0 };
    function Pe(t, n, a, u, h, f, d, p, g, A) {
      if (t == n) {
        u < 8 && (Ge(a, u, h, d), a = ee.c, u = ee.lc), u -= 8;
        var S = a >> u, S = new Uint8Array([S])[0];
        if (g.value + S > A)
          return !1;
        for (var w = p[g.value - 1]; S-- > 0; )
          p[g.value++] = w;
      } else if (g.value < A)
        p[g.value++] = t;
      else
        return !1;
      re.c = a, re.lc = u;
    }
    function Me(t) {
      return t & 65535;
    }
    function Ke(t) {
      var n = Me(t);
      return n > 32767 ? n - 65536 : n;
    }
    const M = { a: 0, b: 0 };
    function be(t, n) {
      var a = Ke(t), u = Ke(n), h = u, f = a + (h & 1) + (h >> 1), d = f, p = f - h;
      M.a = d, M.b = p;
    }
    function Ne(t, n) {
      var a = Me(t), u = Me(n), h = a - (u >> 1) & 65535, f = u + h - 32768 & 65535;
      M.a = f, M.b = h;
    }
    function Vn(t, n, a, u, h, f, d) {
      for (var p = d < 16384, g = a > h ? h : a, A = 1, S; A <= g; )
        A <<= 1;
      for (A >>= 1, S = A, A >>= 1; A >= 1; ) {
        for (var w = 0, Y = w + f * (h - S), I = f * A, _ = f * S, N = u * A, U = u * S, D, z, V, te; w <= Y; w += _) {
          for (var k = w, Te = w + u * (a - S); k <= Te; k += U) {
            var H = k + N, J = k + I, Oe = J + N;
            p ? (be(t[k + n], t[J + n]), D = M.a, V = M.b, be(t[H + n], t[Oe + n]), z = M.a, te = M.b, be(D, z), t[k + n] = M.a, t[H + n] = M.b, be(V, te), t[J + n] = M.a, t[Oe + n] = M.b) : (Ne(t[k + n], t[J + n]), D = M.a, V = M.b, Ne(t[H + n], t[Oe + n]), z = M.a, te = M.b, Ne(D, z), t[k + n] = M.a, t[H + n] = M.b, Ne(V, te), t[J + n] = M.a, t[Oe + n] = M.b);
          }
          if (a & A) {
            var J = k + I;
            p ? be(t[k + n], t[J + n]) : Ne(t[k + n], t[J + n]), D = M.a, t[J + n] = M.b, t[k + n] = D;
          }
        }
        if (h & A)
          for (var k = w, Te = w + u * (a - S); k <= Te; k += U) {
            var H = k + N;
            p ? be(t[k + n], t[H + n]) : Ne(t[k + n], t[H + n]), D = M.a, t[H + n] = M.b, t[k + n] = D;
          }
        S = A, A >>= 1;
      }
      return w;
    }
    function Jn(t, n, a, u, h, f, d, p, g, A) {
      for (var S = 0, w = 0, Y = p, I = Math.trunc(h.value + (f + 7) / 8); h.value < I; )
        for (Ge(S, w, a, h), S = ee.c, w = ee.lc; w >= 14; ) {
          var _ = S >> w - 14 & 16383, N = n[_];
          if (N.len)
            w -= N.len, Pe(N.lit, d, S, w, a, u, h, g, A, Y), S = re.c, w = re.lc;
          else {
            if (!N.p)
              throw "hufDecode issues";
            var U;
            for (U = 0; U < N.lit; U++) {
              for (var D = mt(t[N.p[U]]); w < D && h.value < I; )
                Ge(S, w, a, h), S = ee.c, w = ee.lc;
              if (w >= D && Ct(t[N.p[U]]) == (S >> w - D & (1 << D) - 1)) {
                w -= D, Pe(
                  N.p[U],
                  d,
                  S,
                  w,
                  a,
                  u,
                  h,
                  g,
                  A,
                  Y
                ), S = re.c, w = re.lc;
                break;
              }
            }
            if (U == N.lit)
              throw "hufDecode issues";
          }
        }
      var z = 8 - f & 7;
      for (S >>= z, w -= z; w > 0; ) {
        var N = n[S << 14 - w & 16383];
        if (N.len)
          w -= N.len, Pe(N.lit, d, S, w, a, u, h, g, A, Y), S = re.c, w = re.lc;
        else
          throw "hufDecode issues";
      }
      return !0;
    }
    function Fr(t, n, a, u, h, f) {
      var d = { value: 0 }, p = a.value, g = ne(n, a), A = ne(n, a);
      a.value += 4;
      var S = ne(n, a);
      if (a.value += 4, g < 0 || g >= 65537 || A < 0 || A >= 65537)
        throw "Something wrong with HUF_ENCSIZE";
      var w = new Array(65537), Y = new Array(16384);
      ir(Y);
      var I = u - (a.value - p);
      if (Se(t, n, a, I, g, A, w), S > 8 * (u - (a.value - p)))
        throw "Something wrong with hufUncompress";
      je(w, g, A, Y), Jn(w, Y, t, n, a, S, A, f, h, d);
    }
    function $n(t, n, a) {
      for (var u = 0; u < a; ++u)
        n[u] = t[n[u]];
    }
    function Lr(t) {
      for (var n = 1; n < t.length; n++) {
        var a = t[n - 1] + t[n] - 128;
        t[n] = a;
      }
    }
    function Pr(t, n) {
      for (var a = 0, u = Math.floor((t.length + 1) / 2), h = 0, f = t.length - 1; !(h > f || (n[h++] = t[a++], h > f)); )
        n[h++] = t[u++];
    }
    function Mr(t) {
      for (var n = t.byteLength, a = new Array(), u = 0, h = new DataView(t); n > 0; ) {
        var f = h.getInt8(u++);
        if (f < 0) {
          var d = -f;
          n -= d + 1;
          for (var p = 0; p < d; p++)
            a.push(h.getUint8(u++));
        } else {
          var d = f;
          n -= 2;
          for (var g = h.getUint8(u++), p = 0; p < d + 1; p++)
            a.push(g);
        }
      }
      return a;
    }
    function Qn(t, n, a, u, h, f) {
      var H = new DataView(f.buffer), d = a[t.idx[0]].width, p = a[t.idx[0]].height, g = 3, A = Math.floor(d / 8), S = Math.ceil(d / 8), w = Math.ceil(p / 8), Y = d - (S - 1) * 8, I = p - (w - 1) * 8, _ = { value: 0 }, N = new Array(g), U = new Array(g), D = new Array(g), z = new Array(g), V = new Array(g);
      for (let B = 0; B < g; ++B)
        V[B] = n[t.idx[B]], N[B] = B < 1 ? 0 : N[B - 1] + S * w, U[B] = new Float32Array(64), D[B] = new Uint16Array(64), z[B] = new Uint16Array(S * 64);
      for (let B = 0; B < w; ++B) {
        var te = 8;
        B == w - 1 && (te = I);
        var k = 8;
        for (let W = 0; W < S; ++W) {
          W == S - 1 && (k = Y);
          for (let F = 0; F < g; ++F)
            D[F].fill(0), D[F][0] = h[N[F]++], jn(_, u, D[F]), Kn(D[F], U[F]), ei(U[F]);
          ti(U);
          for (let F = 0; F < g; ++F)
            ri(U[F], z[F], W * 64);
        }
        let K = 0;
        for (let W = 0; W < g; ++W) {
          const F = a[t.idx[W]].type;
          for (let fe = 8 * B; fe < 8 * B + te; ++fe) {
            K = V[W][fe];
            for (let De = 0; De < A; ++De) {
              const ae = De * 64 + (fe & 7) * 8;
              H.setUint16(K + 0 * 2 * F, z[W][ae + 0], !0), H.setUint16(K + 1 * 2 * F, z[W][ae + 1], !0), H.setUint16(K + 2 * 2 * F, z[W][ae + 2], !0), H.setUint16(K + 3 * 2 * F, z[W][ae + 3], !0), H.setUint16(K + 4 * 2 * F, z[W][ae + 4], !0), H.setUint16(K + 5 * 2 * F, z[W][ae + 5], !0), H.setUint16(K + 6 * 2 * F, z[W][ae + 6], !0), H.setUint16(K + 7 * 2 * F, z[W][ae + 7], !0), K += 8 * 2 * F;
            }
          }
          if (A != S)
            for (let fe = 8 * B; fe < 8 * B + te; ++fe) {
              const De = V[W][fe] + 8 * A * 2 * F, ae = A * 64 + (fe & 7) * 8;
              for (let xe = 0; xe < k; ++xe)
                H.setUint16(De + xe * 2 * F, z[W][ae + xe], !0);
            }
        }
      }
      for (var Te = new Uint16Array(d), H = new DataView(f.buffer), J = 0; J < g; ++J) {
        a[t.idx[J]].decoded = !0;
        var Oe = a[t.idx[J]].type;
        if (a[J].type == 2)
          for (var it = 0; it < p; ++it) {
            const B = V[J][it];
            for (var he = 0; he < d; ++he)
              Te[he] = H.getUint16(B + he * 2 * Oe, !0);
            for (var he = 0; he < d; ++he)
              H.setFloat32(B + he * 2 * Oe, T(Te[he]), !0);
          }
      }
    }
    function jn(t, n, a) {
      for (var u, h = 1; h < 64; )
        u = n[t.value], u == 65280 ? h = 64 : u >> 8 == 255 ? h += u & 255 : (a[h] = u, h++), t.value++;
    }
    function Kn(t, n) {
      n[0] = T(t[0]), n[1] = T(t[1]), n[2] = T(t[5]), n[3] = T(t[6]), n[4] = T(t[14]), n[5] = T(t[15]), n[6] = T(t[27]), n[7] = T(t[28]), n[8] = T(t[2]), n[9] = T(t[4]), n[10] = T(t[7]), n[11] = T(t[13]), n[12] = T(t[16]), n[13] = T(t[26]), n[14] = T(t[29]), n[15] = T(t[42]), n[16] = T(t[3]), n[17] = T(t[8]), n[18] = T(t[12]), n[19] = T(t[17]), n[20] = T(t[25]), n[21] = T(t[30]), n[22] = T(t[41]), n[23] = T(t[43]), n[24] = T(t[9]), n[25] = T(t[11]), n[26] = T(t[18]), n[27] = T(t[24]), n[28] = T(t[31]), n[29] = T(t[40]), n[30] = T(t[44]), n[31] = T(t[53]), n[32] = T(t[10]), n[33] = T(t[19]), n[34] = T(t[23]), n[35] = T(t[32]), n[36] = T(t[39]), n[37] = T(t[45]), n[38] = T(t[52]), n[39] = T(t[54]), n[40] = T(t[20]), n[41] = T(t[22]), n[42] = T(t[33]), n[43] = T(t[38]), n[44] = T(t[46]), n[45] = T(t[51]), n[46] = T(t[55]), n[47] = T(t[60]), n[48] = T(t[21]), n[49] = T(t[34]), n[50] = T(t[37]), n[51] = T(t[47]), n[52] = T(t[50]), n[53] = T(t[56]), n[54] = T(t[59]), n[55] = T(t[61]), n[56] = T(t[35]), n[57] = T(t[36]), n[58] = T(t[48]), n[59] = T(t[49]), n[60] = T(t[57]), n[61] = T(t[58]), n[62] = T(t[62]), n[63] = T(t[63]);
    }
    function ei(t) {
      const n = 0.5 * Math.cos(0.7853975), a = 0.5 * Math.cos(3.14159 / 16), u = 0.5 * Math.cos(3.14159 / 8), h = 0.5 * Math.cos(3 * 3.14159 / 16), f = 0.5 * Math.cos(5 * 3.14159 / 16), d = 0.5 * Math.cos(3 * 3.14159 / 8), p = 0.5 * Math.cos(7 * 3.14159 / 16);
      for (var g = new Array(4), A = new Array(4), S = new Array(4), w = new Array(4), Y = 0; Y < 8; ++Y) {
        var I = Y * 8;
        g[0] = u * t[I + 2], g[1] = d * t[I + 2], g[2] = u * t[I + 6], g[3] = d * t[I + 6], A[0] = a * t[I + 1] + h * t[I + 3] + f * t[I + 5] + p * t[I + 7], A[1] = h * t[I + 1] - p * t[I + 3] - a * t[I + 5] - f * t[I + 7], A[2] = f * t[I + 1] - a * t[I + 3] + p * t[I + 5] + h * t[I + 7], A[3] = p * t[I + 1] - f * t[I + 3] + h * t[I + 5] - a * t[I + 7], S[0] = n * (t[I + 0] + t[I + 4]), S[3] = n * (t[I + 0] - t[I + 4]), S[1] = g[0] + g[3], S[2] = g[1] - g[2], w[0] = S[0] + S[1], w[1] = S[3] + S[2], w[2] = S[3] - S[2], w[3] = S[0] - S[1], t[I + 0] = w[0] + A[0], t[I + 1] = w[1] + A[1], t[I + 2] = w[2] + A[2], t[I + 3] = w[3] + A[3], t[I + 4] = w[3] - A[3], t[I + 5] = w[2] - A[2], t[I + 6] = w[1] - A[1], t[I + 7] = w[0] - A[0];
      }
      for (var _ = 0; _ < 8; ++_)
        g[0] = u * t[16 + _], g[1] = d * t[16 + _], g[2] = u * t[48 + _], g[3] = d * t[48 + _], A[0] = a * t[8 + _] + h * t[24 + _] + f * t[40 + _] + p * t[56 + _], A[1] = h * t[8 + _] - p * t[24 + _] - a * t[40 + _] - f * t[56 + _], A[2] = f * t[8 + _] - a * t[24 + _] + p * t[40 + _] + h * t[56 + _], A[3] = p * t[8 + _] - f * t[24 + _] + h * t[40 + _] - a * t[56 + _], S[0] = n * (t[_] + t[32 + _]), S[3] = n * (t[_] - t[32 + _]), S[1] = g[0] + g[3], S[2] = g[1] - g[2], w[0] = S[0] + S[1], w[1] = S[3] + S[2], w[2] = S[3] - S[2], w[3] = S[0] - S[1], t[0 + _] = w[0] + A[0], t[8 + _] = w[1] + A[1], t[16 + _] = w[2] + A[2], t[24 + _] = w[3] + A[3], t[32 + _] = w[3] - A[3], t[40 + _] = w[2] - A[2], t[48 + _] = w[1] - A[1], t[56 + _] = w[0] - A[0];
    }
    function ti(t) {
      for (var n = 0; n < 64; ++n) {
        var a = t[0][n], u = t[1][n], h = t[2][n];
        t[0][n] = a + 1.5747 * h, t[1][n] = a - 0.1873 * u - 0.4682 * h, t[2][n] = a + 1.8556 * u;
      }
    }
    function ri(t, n, a) {
      for (var u = 0; u < 64; ++u)
        n[a + u] = Gr.toHalfFloat(ni(t[u]));
    }
    function ni(t) {
      return t <= 1 ? Math.sign(t) * Math.pow(Math.abs(t), 2.2) : Math.sign(t) * Math.pow(Ot, Math.abs(t) - 1);
    }
    function Dr(t) {
      return new DataView(t.array.buffer, t.offset.value, t.size);
    }
    function ii(t) {
      var n = t.viewer.buffer.slice(t.offset.value, t.offset.value + t.size), a = new Uint8Array(Mr(n)), u = new Uint8Array(a.length);
      return Lr(a), Pr(a, u), new DataView(u.buffer);
    }
    function sr(t) {
      var n = t.array.slice(t.offset.value, t.offset.value + t.size), a = Dt(n), u = new Uint8Array(a.length);
      return Lr(a), Pr(a, u), new DataView(u.buffer);
    }
    function si(t) {
      for (var n = t.viewer, a = { value: t.offset.value }, u = new Uint16Array(t.width * t.scanlineBlockSize * (t.channels * t.type)), h = new Uint8Array(8192), f = 0, d = new Array(t.channels), p = 0; p < t.channels; p++)
        d[p] = {}, d[p].start = f, d[p].end = d[p].start, d[p].nx = t.width, d[p].ny = t.lines, d[p].size = t.type, f += d[p].nx * d[p].ny * d[p].size;
      var g = tt(n, a), A = tt(n, a);
      if (A >= 8192)
        throw "Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";
      if (g <= A)
        for (var p = 0; p < A - g + 1; p++)
          h[p + g] = We(n, a);
      var S = new Uint16Array(65536), w = nr(h, S), Y = ne(n, a);
      Fr(t.array, n, a, Y, u, f);
      for (var p = 0; p < t.channels; ++p)
        for (var I = d[p], _ = 0; _ < d[p].size; ++_)
          Vn(u, I.start + _, I.nx, I.size, I.ny, I.nx * I.size, w);
      $n(S, u, f);
      for (var N = 0, U = new Uint8Array(u.buffer.byteLength), D = 0; D < t.lines; D++)
        for (var z = 0; z < t.channels; z++) {
          var I = d[z], V = I.nx * I.size, te = new Uint8Array(u.buffer, I.end * 2, V * 2);
          U.set(te, N), N += V * 2, I.end += V;
        }
      return new DataView(U.buffer);
    }
    function oi(t) {
      var n = t.array.slice(t.offset.value, t.offset.value + t.size), a = Dt(n);
      const u = t.lines * t.channels * t.width, h = t.type == 1 ? new Uint16Array(u) : new Uint32Array(u);
      let f = 0, d = 0;
      const p = new Array(4);
      for (let g = 0; g < t.lines; g++)
        for (let A = 0; A < t.channels; A++) {
          let S = 0;
          switch (t.type) {
            case 1:
              p[0] = f, p[1] = p[0] + t.width, f = p[1] + t.width;
              for (let w = 0; w < t.width; ++w) {
                const Y = a[p[0]++] << 8 | a[p[1]++];
                S += Y, h[d] = S, d++;
              }
              break;
            case 2:
              p[0] = f, p[1] = p[0] + t.width, p[2] = p[1] + t.width, f = p[2] + t.width;
              for (let w = 0; w < t.width; ++w) {
                const Y = a[p[0]++] << 24 | a[p[1]++] << 16 | a[p[2]++] << 8;
                S += Y, h[d] = S, d++;
              }
              break;
          }
        }
      return new DataView(h.buffer);
    }
    function Br(t) {
      var n = t.viewer, a = { value: t.offset.value }, u = new Uint8Array(t.width * t.lines * (t.channels * t.type * 2)), h = {
        version: ue(n, a),
        unknownUncompressedSize: ue(n, a),
        unknownCompressedSize: ue(n, a),
        acCompressedSize: ue(n, a),
        dcCompressedSize: ue(n, a),
        rleCompressedSize: ue(n, a),
        rleUncompressedSize: ue(n, a),
        rleRawSize: ue(n, a),
        totalAcUncompressedCount: ue(n, a),
        totalDcUncompressedCount: ue(n, a),
        acCompression: ue(n, a)
      };
      if (h.version < 2)
        throw "EXRLoader.parse: " + nt.compression + " version " + h.version + " is unsupported";
      for (var f = new Array(), d = tt(n, a) - 2; d > 0; ) {
        var p = Rt(n.buffer, a), g = We(n, a), A = g >> 2 & 3, S = (g >> 4) - 1, w = new Int8Array([S])[0], Y = We(n, a);
        f.push({
          name: p,
          index: w,
          type: Y,
          compression: A
        }), d -= p.length + 3;
      }
      for (var I = nt.channels, _ = new Array(t.channels), N = 0; N < t.channels; ++N) {
        var U = _[N] = {}, D = I[N];
        U.name = D.name, U.compression = 0, U.decoded = !1, U.type = D.pixelType, U.pLinear = D.pLinear, U.width = t.width, U.height = t.lines;
      }
      for (var z = {
        idx: new Array(3)
      }, V = 0; V < t.channels; ++V)
        for (var U = _[V], N = 0; N < f.length; ++N) {
          var te = f[N];
          U.name == te.name && (U.compression = te.compression, te.index >= 0 && (z.idx[te.index] = V), U.offset = V);
        }
      if (h.acCompressedSize > 0)
        switch (h.acCompression) {
          case 0:
            var H = new Uint16Array(h.totalAcUncompressedCount);
            Fr(
              t.array,
              n,
              a,
              h.acCompressedSize,
              H,
              h.totalAcUncompressedCount
            );
            break;
          case 1:
            var k = t.array.slice(a.value, a.value + h.totalAcUncompressedCount), Te = Dt(k), H = new Uint16Array(Te.buffer);
            a.value += h.totalAcUncompressedCount;
            break;
        }
      if (h.dcCompressedSize > 0) {
        var J = {
          array: t.array,
          offset: a,
          size: h.dcCompressedSize
        }, Oe = new Uint16Array(sr(J).buffer);
        a.value += h.dcCompressedSize;
      }
      if (h.rleRawSize > 0) {
        var k = t.array.slice(a.value, a.value + h.rleCompressedSize), Te = Dt(k), it = Mr(Te.buffer);
        a.value += h.rleCompressedSize;
      }
      for (var he = 0, B = new Array(_.length), N = 0; N < B.length; ++N)
        B[N] = new Array();
      for (var K = 0; K < t.lines; ++K)
        for (var W = 0; W < _.length; ++W)
          B[W].push(he), he += _[W].width * t.type * 2;
      Qn(z, B, _, H, Oe, u);
      for (var N = 0; N < _.length; ++N) {
        var U = _[N];
        if (!U.decoded)
          switch (U.compression) {
            case 2:
              for (var F = 0, fe = 0, K = 0; K < t.lines; ++K) {
                for (var De = B[N][F], ae = 0; ae < U.width; ++ae) {
                  for (var xe = 0; xe < 2 * U.type; ++xe)
                    u[De++] = it[fe + xe * U.width * U.height];
                  fe++;
                }
                F++;
              }
              break;
            case 1:
            default:
              throw "EXRLoader.parse: unsupported channel compression";
          }
      }
      return new DataView(u.buffer);
    }
    function Rt(t, n) {
      for (var a = new Uint8Array(t), u = 0; a[n.value + u] != 0; )
        u += 1;
      var h = new TextDecoder().decode(a.slice(n.value, n.value + u));
      return n.value = n.value + u + 1, h;
    }
    function ai(t, n, a) {
      var u = new TextDecoder().decode(new Uint8Array(t).slice(n.value, n.value + a));
      return n.value = n.value + a, u;
    }
    function ci(t, n) {
      var a = et(t, n), u = ne(t, n);
      return [a, u];
    }
    function li(t, n) {
      var a = ne(t, n), u = ne(t, n);
      return [a, u];
    }
    function et(t, n) {
      var a = t.getInt32(n.value, !0);
      return n.value = n.value + 4, a;
    }
    function ne(t, n) {
      var a = t.getUint32(n.value, !0);
      return n.value = n.value + 4, a;
    }
    function zr(t, n) {
      var a = t[n.value];
      return n.value = n.value + 1, a;
    }
    function We(t, n) {
      var a = t.getUint8(n.value);
      return n.value = n.value + 1, a;
    }
    const ue = function(t, n) {
      let a;
      return "getBigInt64" in DataView.prototype ? a = Number(t.getBigInt64(n.value, !0)) : a = t.getUint32(n.value + 4, !0) + Number(t.getUint32(n.value, !0) << 32), n.value += 8, a;
    };
    function j(t, n) {
      var a = t.getFloat32(n.value, !0);
      return n.value += 4, a;
    }
    function ui(t, n) {
      return Gr.toHalfFloat(j(t, n));
    }
    function T(t) {
      var n = (t & 31744) >> 10, a = t & 1023;
      return (t >> 15 ? -1 : 1) * (n ? n === 31 ? a ? NaN : 1 / 0 : Math.pow(2, n - 15) * (1 + a / 1024) : 6103515625e-14 * (a / 1024));
    }
    function tt(t, n) {
      var a = t.getUint16(n.value, !0);
      return n.value += 2, a;
    }
    function hi(t, n) {
      return T(tt(t, n));
    }
    function fi(t, n, a, u) {
      for (var h = a.value, f = []; a.value < h + u - 1; ) {
        var d = Rt(n, a), p = et(t, a), g = We(t, a);
        a.value += 3;
        var A = et(t, a), S = et(t, a);
        f.push({
          name: d,
          pixelType: p,
          pLinear: g,
          xSampling: A,
          ySampling: S
        });
      }
      return a.value += 1, f;
    }
    function vi(t, n) {
      var a = j(t, n), u = j(t, n), h = j(t, n), f = j(t, n), d = j(t, n), p = j(t, n), g = j(t, n), A = j(t, n);
      return {
        redX: a,
        redY: u,
        greenX: h,
        greenY: f,
        blueX: d,
        blueY: p,
        whiteX: g,
        whiteY: A
      };
    }
    function yi(t, n) {
      var a = [
        "NO_COMPRESSION",
        "RLE_COMPRESSION",
        "ZIPS_COMPRESSION",
        "ZIP_COMPRESSION",
        "PIZ_COMPRESSION",
        "PXR24_COMPRESSION",
        "B44_COMPRESSION",
        "B44A_COMPRESSION",
        "DWAA_COMPRESSION",
        "DWAB_COMPRESSION"
      ], u = We(t, n);
      return a[u];
    }
    function pi(t, n) {
      var a = ne(t, n), u = ne(t, n), h = ne(t, n), f = ne(t, n);
      return { xMin: a, yMin: u, xMax: h, yMax: f };
    }
    function di(t, n) {
      var a = ["INCREASING_Y"], u = We(t, n);
      return a[u];
    }
    function wi(t, n) {
      var a = j(t, n), u = j(t, n);
      return [a, u];
    }
    function Ai(t, n) {
      var a = j(t, n), u = j(t, n), h = j(t, n);
      return [a, u, h];
    }
    function gi(t, n, a, u, h) {
      if (u === "string" || u === "stringvector" || u === "iccProfile")
        return ai(n, a, h);
      if (u === "chlist")
        return fi(t, n, a, h);
      if (u === "chromaticities")
        return vi(t, a);
      if (u === "compression")
        return yi(t, a);
      if (u === "box2i")
        return pi(t, a);
      if (u === "lineOrder")
        return di(t, a);
      if (u === "float")
        return j(t, a);
      if (u === "v2f")
        return wi(t, a);
      if (u === "v3f")
        return Ai(t, a);
      if (u === "int")
        return et(t, a);
      if (u === "rational")
        return ci(t, a);
      if (u === "timecode")
        return li(t, a);
      if (u === "preview")
        return a.value += h, "skipped";
      a.value += h;
    }
    function Si(t, n, a) {
      const u = {};
      if (t.getUint32(0, !0) != 20000630)
        throw "THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";
      u.version = t.getUint8(4);
      const h = t.getUint8(5);
      u.spec = {
        singleTile: !!(h & 2),
        longName: !!(h & 4),
        deepFormat: !!(h & 8),
        multiPart: !!(h & 16)
      }, a.value = 8;
      for (var f = !0; f; ) {
        var d = Rt(n, a);
        if (d == 0)
          f = !1;
        else {
          var p = Rt(n, a), g = ne(t, a), A = gi(t, n, a, p, g);
          A === void 0 ? console.warn(`EXRLoader.parse: skipped unknown header attribute type '${p}'.`) : u[d] = A;
        }
      }
      if (h & -5)
        throw console.error("EXRHeader:", u), "THREE.EXRLoader: provided file is currently unsupported.";
      return u;
    }
    function Ti(t, n, a, u, h) {
      const f = {
        size: 0,
        viewer: n,
        array: a,
        offset: u,
        width: t.dataWindow.xMax - t.dataWindow.xMin + 1,
        height: t.dataWindow.yMax - t.dataWindow.yMin + 1,
        channels: t.channels.length,
        bytesPerLine: null,
        lines: null,
        inputSize: null,
        type: t.channels[0].pixelType,
        uncompress: null,
        getter: null,
        format: null,
        [at ? "colorSpace" : "encoding"]: null
      };
      switch (t.compression) {
        case "NO_COMPRESSION":
          f.lines = 1, f.uncompress = Dr;
          break;
        case "RLE_COMPRESSION":
          f.lines = 1, f.uncompress = ii;
          break;
        case "ZIPS_COMPRESSION":
          f.lines = 1, f.uncompress = sr;
          break;
        case "ZIP_COMPRESSION":
          f.lines = 16, f.uncompress = sr;
          break;
        case "PIZ_COMPRESSION":
          f.lines = 32, f.uncompress = si;
          break;
        case "PXR24_COMPRESSION":
          f.lines = 16, f.uncompress = oi;
          break;
        case "DWAA_COMPRESSION":
          f.lines = 32, f.uncompress = Br;
          break;
        case "DWAB_COMPRESSION":
          f.lines = 256, f.uncompress = Br;
          break;
        default:
          throw "EXRLoader.parse: " + t.compression + " is unsupported";
      }
      if (f.scanlineBlockSize = f.lines, f.type == 1)
        switch (h) {
          case ft:
            f.getter = hi, f.inputSize = 2;
            break;
          case lt:
            f.getter = tt, f.inputSize = 2;
            break;
        }
      else if (f.type == 2)
        switch (h) {
          case ft:
            f.getter = j, f.inputSize = 4;
            break;
          case lt:
            f.getter = ui, f.inputSize = 4;
        }
      else
        throw "EXRLoader.parse: unsupported pixelType " + f.type + " for " + t.compression + ".";
      f.blockCount = (t.dataWindow.yMax + 1) / f.scanlineBlockSize;
      for (var d = 0; d < f.blockCount; d++)
        ue(n, u);
      f.outputChannels = f.channels == 3 ? 4 : f.channels;
      const p = f.width * f.height * f.outputChannels;
      switch (h) {
        case ft:
          f.byteArray = new Float32Array(p), f.channels < f.outputChannels && f.byteArray.fill(1, 0, p);
          break;
        case lt:
          f.byteArray = new Uint16Array(p), f.channels < f.outputChannels && f.byteArray.fill(15360, 0, p);
          break;
        default:
          console.error("THREE.EXRLoader: unsupported type: ", h);
          break;
      }
      return f.bytesPerLine = f.width * f.inputSize * f.channels, f.outputChannels == 4 ? f.format = hn : f.format = vn, at ? f.colorSpace = "srgb-linear" : f.encoding = 3e3, f;
    }
    const xt = new DataView(e), Ei = new Uint8Array(e), rt = { value: 0 }, nt = Si(xt, e, rt), C = Ti(nt, xt, Ei, rt, this.type), kr = { value: 0 }, Ii = { R: 0, G: 1, B: 2, A: 3, Y: 0 };
    for (let t = 0; t < C.height / C.scanlineBlockSize; t++) {
      const n = ne(xt, rt);
      C.size = ne(xt, rt), C.lines = n + C.scanlineBlockSize > C.height ? C.height - n : C.scanlineBlockSize;
      const u = C.size < C.lines * C.bytesPerLine ? C.uncompress(C) : Dr(C);
      rt.value += C.size;
      for (let h = 0; h < C.scanlineBlockSize; h++) {
        const f = h + t * C.scanlineBlockSize;
        if (f >= C.height)
          break;
        for (let d = 0; d < C.channels; d++) {
          const p = Ii[nt.channels[d].name];
          for (let g = 0; g < C.width; g++) {
            kr.value = (h * (C.channels * C.width) + d * C.width + g) * C.inputSize;
            const A = (C.height - 1 - f) * (C.width * C.outputChannels) + g * C.outputChannels + p;
            C.byteArray[A] = C.getter(u, kr);
          }
        }
      }
    }
    return {
      header: nt,
      width: C.width,
      height: C.height,
      data: C.byteArray,
      format: C.format,
      [at ? "colorSpace" : "encoding"]: C[at ? "colorSpace" : "encoding"],
      type: this.type
    };
  }
  setDataType(e) {
    return this.type = e, this;
  }
  load(e, i, s, o) {
    function c(l, v) {
      at ? l.colorSpace = v.colorSpace : l.encoding = v.encoding, l.minFilter = kt, l.magFilter = kt, l.generateMipmaps = !1, l.flipY = !1, i && i(l, v);
    }
    return super.load(e, c, s, o);
  }
}
class ia extends Vt {
  setDepth(e) {
    return this.depth = e, this;
  }
  load(e, i, s, o) {
    const c = new lo(this.manager);
    c.setRequestHeader(this.requestHeader), c.setPath(this.path), c.setWithCredentials(this.withCredentials), c.load(
      e,
      (l) => {
        const { data: v, width: y, height: E } = l.image, b = this.depth ?? Math.sqrt(E), m = new fn(v, y, E / b, b);
        m.type = l.type, m.format = l.format, m.colorSpace = l.colorSpace, m.needsUpdate = !0;
        try {
          i(m);
        } catch (q) {
          o != null ? o(q) : console.error(q), this.manager.itemError(e);
        }
      },
      s,
      o
    );
  }
}
const vr = 1e-6, Bt = /* @__PURE__ */ new Re(), zt = /* @__PURE__ */ new Re(), Ue = /* @__PURE__ */ new Re(), ct = /* @__PURE__ */ new Re(), yr = /* @__PURE__ */ new Re(), uo = /* @__PURE__ */ new Re(), ho = /* @__PURE__ */ new Di(), fo = /* @__PURE__ */ new Mi(), vo = /* @__PURE__ */ new Bi();
class Xn {
  constructor(e = 0, i = 0, s = 0, o = 0) {
    this.distance = e, this.heading = i, this.pitch = s, this.roll = o;
  }
  get distance() {
    return this._distance;
  }
  set distance(e) {
    this._distance = Math.max(e, vr);
  }
  get pitch() {
    return this._pitch;
  }
  set pitch(e) {
    this._pitch = Je(e, -Math.PI / 2 + vr, Math.PI / 2 - vr);
  }
  set(e, i, s, o) {
    return this.distance = e, this.heading = i, this.pitch = s, o != null && (this.roll = o), this;
  }
  clone() {
    return new Xn(this.distance, this.heading, this.pitch, this.roll);
  }
  copy(e) {
    return this.distance = e.distance, this.heading = e.heading, this.pitch = e.pitch, this.roll = e.roll, this;
  }
  equals(e) {
    return e.distance === this.distance && e.heading === this.heading && e.pitch === this.pitch && e.roll === this.roll;
  }
  decompose(e, i, s, o, c = Xr.WGS84) {
    c.getEastNorthUpVectors(
      e,
      Bt,
      zt,
      Ue
    ), o == null || o.copy(Ue);
    const l = ct.copy(Bt).multiplyScalar(Math.cos(this.heading)).add(
      yr.copy(zt).multiplyScalar(Math.sin(this.heading))
    ).multiplyScalar(Math.cos(this.pitch)).add(yr.copy(Ue).multiplyScalar(Math.sin(this.pitch))).normalize().multiplyScalar(this.distance);
    if (i.copy(e).sub(l), this.roll !== 0) {
      const v = ct.copy(e).sub(i).normalize();
      Ue.applyQuaternion(
        fo.setFromAxisAngle(v, this.roll)
      );
    }
    s.setFromRotationMatrix(
      ho.lookAt(i, e, Ue)
    );
  }
  setFromCamera(e, i = Xr.WGS84) {
    const s = ct.setFromMatrixPosition(e.matrixWorld), o = yr.set(0, 0, 0.5).unproject(e).sub(s).normalize(), c = i.getIntersection(vo.set(s, o));
    if (c == null)
      return;
    this.distance = s.distanceTo(c), i.getEastNorthUpVectors(
      c,
      Bt,
      zt,
      Ue
    ), this.heading = Math.atan2(
      zt.dot(o),
      Bt.dot(o)
    ), this.pitch = Math.asin(Ue.dot(o));
    const l = ct.copy(e.up).applyQuaternion(e.quaternion), v = uo.copy(o).multiplyScalar(-l.dot(o)).add(l).normalize(), y = ct.copy(o).multiplyScalar(-Ue.dot(o)).add(Ue).normalize(), E = y.dot(v), b = o.dot(y.cross(v));
    return this.roll = Math.atan2(b, E), this;
  }
}
const dt = class dt {
  constructor(e = 0, i = 0, s = 0, o = 0) {
    this.west = e, this.south = i, this.east = s, this.north = o;
  }
  get width() {
    let e = this.east;
    return e < this.west && (e += Math.PI * 2), e - this.west;
  }
  get height() {
    return this.north - this.south;
  }
  set(e, i, s, o) {
    return this.west = e, this.south = i, this.east = s, this.north = o, this;
  }
  clone() {
    return new dt(this.west, this.south, this.east, this.north);
  }
  copy(e) {
    return this.west = e.west, this.south = e.south, this.east = e.east, this.north = e.north, this;
  }
  equals(e) {
    return e.west === this.west && e.south === this.south && e.east === this.east && e.north === this.north;
  }
  at(e, i, s = new st()) {
    return s.set(
      this.west + (this.east - this.west) * e,
      this.north + (this.south - this.north) * i
    );
  }
  fromArray(e, i = 0) {
    return this.west = e[i], this.south = e[i + 1], this.east = e[i + 2], this.north = e[i + 3], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.west, e[i + 1] = this.south, e[i + 2] = this.east, e[i + 3] = this.north, e;
  }
  *[Symbol.iterator]() {
    yield this.west, yield this.south, yield this.east, yield this.north;
  }
};
dt.MAX = /* @__PURE__ */ new dt(
  st.MIN_LONGITUDE,
  st.MIN_LATITUDE,
  st.MAX_LONGITUDE,
  st.MAX_LATITUDE
);
let qt = dt;
const yo = /^[ \t]*#include +"([\w\d./]+)"/gm;
function po(r, e) {
  return r.replace(yo, (i, s) => {
    const c = s.split("/").reduce(
      (l, v) => typeof l != "string" && l != null ? l[v] : void 0,
      e
    );
    if (typeof c != "string")
      throw new Error(`Could not find include for ${s}.`);
    return po(c, e);
  });
}
const sa = Bn(ks, {
  format: vn,
  minFilter: Wr,
  magFilter: Wr,
  wrapS: or,
  wrapT: or,
  wrapR: or,
  width: Zi,
  height: Hi,
  depth: Gi
});
function* Yn(r, e, i, s, o) {
  if (i >= s)
    return;
  const c = 2 ** i, l = i + 1, v = 2 ** l, y = Math.floor(r / c * v), E = Math.floor(e / c * v), b = [
    [y, E, l],
    [y + 1, E, l],
    [y, E + 1, l],
    [y + 1, E + 1, l]
  ];
  if (l < s)
    for (const m of b)
      for (const q of Yn(...m, s, o))
        yield q;
  else
    for (const m of b)
      yield (o ?? new wt()).set(...m);
}
class wt {
  constructor(e = 0, i = 0, s = 0) {
    this.x = e, this.y = i, this.z = s;
  }
  set(e, i, s) {
    return this.x = e, this.y = i, s != null && (this.z = s), this;
  }
  clone() {
    return new wt(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  getParent(e = new wt()) {
    const i = 2 ** this.z, s = this.x / i, o = this.y / i, c = this.z - 1, l = 2 ** c;
    return e.set(Math.floor(s * l), Math.floor(o * l), c);
  }
  *traverseChildren(e, i) {
    const { x: s, y: o, z: c } = this;
    for (const l of Yn(s, o, c, c + e, i))
      yield l;
  }
  fromArray(e, i = 0) {
    return this.x = e[i], this.y = e[i + 1], this.z = e[i + 2], this;
  }
  toArray(e = [], i = 0) {
    return e[i] = this.x, e[i + 1] = this.y, e[i + 2] = this.z, e;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const un = /* @__PURE__ */ new yn();
class qn {
  constructor(e = 2, i = 1, s = qt.MAX) {
    this.width = e, this.height = i, this.rectangle = s;
  }
  clone() {
    return new qn(this.width, this.height, this.rectangle.clone());
  }
  copy(e) {
    return this.width = e.width, this.height = e.height, this.rectangle.copy(e.rectangle), this;
  }
  getSize(e, i = new yn()) {
    return i.set(this.width << e, this.height << e);
  }
  // Reference: https://github.com/CesiumGS/cesium/blob/1.122/packages/engine/Source/Core/GeographicTilingScheme.js#L210
  getTile(e, i, s = new wt()) {
    const o = this.getSize(i, un), { rectangle: c } = this, l = c.width / o.x, v = c.height / o.y, { west: y, south: E, east: b } = c;
    let m = e.longitude;
    b < y && (m += Math.PI * 2);
    let q = Math.floor((m - y) / l);
    q >= o.x && (q = o.x - 1);
    let se = Math.floor((e.latitude - E) / v);
    return se >= o.y && (se = o.y - 1), s.x = q, s.y = se, s.z = i, s;
  }
  // Reference: https://github.com/CesiumGS/cesium/blob/1.122/packages/engine/Source/Core/GeographicTilingScheme.js#L169
  getRectangle(e, i = new qt()) {
    const s = this.getSize(e.z, un), { rectangle: o } = this, c = o.width / s.x, l = o.height / s.y, { west: v, north: y } = o;
    return i.west = e.x * c + v, i.east = (e.x + 1) * c + v, i.north = y - (s.y - e.y - 1) * l, i.south = y - (s.y - e.y) * l, i;
  }
}
const wo = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*(?:i\s*\+\+|\+\+\s*i)\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Ao(r, e, i, s) {
  let o = "";
  for (let c = parseInt(e); c < parseInt(i); ++c)
    o += s.replace(/\[\s*i\s*\]/g, "[" + c + "]").replace(/UNROLLED_LOOP_INDEX/g, `${c}`);
  return o;
}
function oa(r) {
  return r.replace(wo, Ao);
}
export {
  ki as ArrayBufferLoader,
  _o as DEFAULT_STBN_URL,
  qs as DataLoader,
  ia as EXR3DLoader,
  Xr as Ellipsoid,
  la as EllipsoidGeometry,
  P as Float16Array,
  Po as Float32ArrayLoader,
  st as Geodetic,
  Fo as Int16ArrayLoader,
  Xn as PointOfView,
  qt as Rectangle,
  sa as STBNLoader,
  Gi as STBN_TEXTURE_DEPTH,
  Hi as STBN_TEXTURE_HEIGHT,
  Zi as STBN_TEXTURE_WIDTH,
  wt as TileCoordinate,
  qn as TilingScheme,
  Ws as TypedArrayLoader,
  Lo as Uint16ArrayLoader,
  To as assertType,
  Wo as ceilPowerOfTwo,
  Je as clamp,
  Qo as closeTo,
  Mo as createData3DTextureLoader,
  Bn as createData3DTextureLoaderClass,
  Do as createDataTextureLoader,
  Vs as createDataTextureLoaderClass,
  xo as createTypedArrayLoader,
  St as createTypedArrayLoaderClass,
  jo as define,
  ta as defineExpression,
  ea as defineFloat,
  Ko as defineInt,
  ra as definePropertyShorthand,
  na as defineUniformShorthand,
  Ho as degrees,
  Bo as euclideanModulo,
  Xo as floorPowerOfTwo,
  Io as fromBufferGeometryLike,
  bo as getTypedArrayElementType,
  zo as inverseLerp,
  Go as isPowerOfTwo,
  No as isTypedArray,
  ko as lerp,
  Yo as normalize,
  Co as parseFloat16Array,
  Gs as parseFloat32Array,
  Ro as parseFloat64Array,
  Hs as parseInt16Array,
  Uo as parseInt32Array,
  Oo as parseInt8Array,
  Zs as parseUint16Array,
  mo as parseUint32Array,
  ks as parseUint8Array,
  Zo as radians,
  qo as remap,
  Vo as remapClamped,
  po as resolveIncludes,
  $o as saturate,
  Jo as smoothstep,
  Eo as toBufferGeometryLike,
  oa as unrollLoops
};
//# sourceMappingURL=index.js.map
