import { jsx as y, jsxs as k, Fragment as N } from "react/jsx-runtime";
import { useThree as A, useFrame as w, extend as j, useLoader as B } from "@react-three/fiber";
import { EffectComposerContext as z } from "@react-three/postprocessing";
import { RenderPass as G } from "postprocessing";
import { createContext as W, forwardRef as E, useRef as M, useState as _, useEffect as v, useMemo as P, useImperativeHandle as K, useContext as S } from "react";
import { Vector3 as L, Matrix4 as Q, Texture as V, Object3D as Y } from "three";
import { P as O, g as q, e as F, f as J, a as U, A as X, v as Z, w as $, r as I, u as H, y as ee, x as te, z as re, C as ne } from "./shared.js";
import { Ellipsoid as oe, ArrayBufferLoader as se } from "@takram/three-geospatial";
import { ScreenQuad as ie } from "@react-three/drei";
const C = W({}), ge = /* @__PURE__ */ E(function({
  textures: e,
  useHalfFloat: t,
  ellipsoid: a = oe.WGS84,
  correctAltitude: r = !0,
  photometric: o = !0,
  date: c,
  children: s
}, u) {
  const n = M({
    sunDirection: new L(),
    moonDirection: new L(),
    rotationMatrix: new Q()
  }), p = A(({ gl: d }) => d);
  t == null && (t = p.getContext().getExtension("OES_texture_float_linear") == null);
  const [l, m] = _(
    typeof e != "string" ? e : void 0
  );
  v(() => {
    if (typeof e == "string") {
      const d = new O();
      d.useHalfFloat = t, (async () => {
        m(await d.loadAsync(e));
      })().catch((T) => {
        console.error(T);
      });
    } else e != null ? m(e) : m(void 0);
  }, [e, t]);
  const i = P(
    () => ({
      textures: l,
      useHalfFloat: t,
      ellipsoid: a,
      correctAltitude: r,
      photometric: o,
      transientProps: n.current
    }),
    [l, t, a, r, o]
  ), x = P(() => {
    const { sunDirection: d, moonDirection: T, rotationMatrix: g } = n.current;
    return (h) => {
      q(h, g), F(h, d).applyMatrix4(g), J(h, T).applyMatrix4(g);
    };
  }, []), D = c != null && !isNaN(+c) ? +c : void 0;
  return v(() => {
    D != null && x(D);
  }, [D, x]), K(
    u,
    () => ({
      ...n.current,
      textures: l,
      updateByDate: x
    }),
    [l, x]
  ), /* @__PURE__ */ y(C.Provider, { value: i, children: s });
});
function R(f) {
  const {
    irradianceTexture: e,
    scatteringTexture: t,
    transmittanceTexture: a,
    useHalfFloat: r,
    ellipsoid: o,
    correctAltitude: c,
    photometric: s,
    sunDirection: u,
    sunAngularRadius: n,
    renderTargetCount: p,
    ...l
  } = f;
  return [
    {
      irradianceTexture: e,
      scatteringTexture: t,
      transmittanceTexture: a,
      useHalfFloat: r,
      ellipsoid: o,
      correctAltitude: c,
      photometric: s,
      sunDirection: u,
      sunAngularRadius: n,
      renderTargetCount: p
    },
    l
  ];
}
const ye = /* @__PURE__ */ E(function(e, t) {
  const { textures: a, transientProps: r, ...o } = S(C), [c, { blendFunction: s, ...u }] = R({
    ...U,
    ...o,
    ...a,
    ...e
  }), n = S(z), { normalPass: p, camera: l } = n, m = "geometryPass" in n && n.geometryPass instanceof G && "geometryTexture" in n.geometryPass && n.geometryPass.geometryTexture instanceof V ? n.geometryPass.geometryTexture : void 0, i = P(
    () => new X(void 0, { blendFunction: s }),
    [s]
  );
  return v(() => () => {
    i.dispose();
  }, [i]), w(() => {
    r != null && (i.sunDirection.copy(r.sunDirection), i.moonDirection.copy(r.moonDirection));
  }), /* @__PURE__ */ y(
    "primitive",
    {
      ref: t,
      object: i,
      mainCamera: l,
      normalBuffer: m ?? (p == null ? void 0 : p.texture) ?? null,
      ...c,
      ...u,
      octEncodedNormal: m != null
    }
  );
}), De = /* @__PURE__ */ E(
  function(e, t) {
    const { textures: a, transientProps: r, ...o } = S(C), [
      c,
      {
        sun: s,
        moon: u,
        moonDirection: n,
        moonAngularRadius: p,
        lunarRadianceScale: l,
        ...m
      }
    ] = R({
      ...Z,
      ...o,
      ...a,
      ...e
    }), i = P(() => new $(), []);
    return v(() => () => {
      i.dispose();
    }, [i]), w(() => {
      r != null && (i.sunDirection.copy(r.sunDirection), i.moonDirection.copy(r.moonDirection));
    }), /* @__PURE__ */ y(ie, { renderOrder: I, ...m, ref: t, children: /* @__PURE__ */ y(
      "primitive",
      {
        object: i,
        ...c,
        sun: s,
        moon: u,
        moonDirection: n,
        moonAngularRadius: p,
        lunarRadianceScale: l
      }
    ) });
  }
);
function b(f) {
  return (e) => {
    f.forEach((t) => {
      typeof t == "function" ? t(e) : t != null && (t.current = e);
    });
  };
}
const he = /* @__PURE__ */ E(
  function(e, t) {
    const { textures: a, transientProps: r, ...o } = S(C), c = M(null);
    return w(() => {
      const s = c.current;
      s != null && r != null && (s.sunDirection.copy(r.sunDirection), s.update());
    }), j({ SkyLightProbe: H }), /* @__PURE__ */ y(
      "skyLightProbe",
      {
        ref: b([c, t]),
        ...o,
        ...a,
        ...e
      }
    );
  }
), ve = /* @__PURE__ */ E(
  function({ data: e, ...t }, a) {
    const { textures: r, transientProps: o, ...c } = S(C), [
      s,
      { pointSize: u, radianceScale: n, background: p, ...l }
    ] = R({
      ...ee,
      ...c,
      ...r,
      ...t
    }), [m, i] = _(
      typeof e != "string" ? e : void 0
    );
    v(() => {
      if (typeof e == "string") {
        const g = new se();
        (async () => {
          i(await g.loadAsync(e));
        })().catch((h) => {
          console.error(h);
        });
      } else e != null ? i(e) : i(void 0);
    }, [e]);
    const x = P(
      () => m != null ? new te(m) : void 0,
      [m]
    );
    v(() => () => {
      x == null || x.dispose();
    }, [x]);
    const D = P(() => new re(), []);
    v(() => () => {
      D.dispose();
    }, [D]);
    const d = M(null);
    w(({ camera: g }) => {
      var h;
      o != null && g.isPerspectiveCamera === !0 && (D.sunDirection.copy(o.sunDirection), (h = d.current) == null || h.setRotationFromMatrix(o.rotationMatrix));
    });
    const T = A(({ camera: g }) => g);
    return x == null || T.isPerspectiveCamera !== !0 ? null : /* @__PURE__ */ k(
      "points",
      {
        ref: b([d, a]),
        frustumCulled: !1,
        renderOrder: I + 1,
        ...l,
        children: [
          /* @__PURE__ */ y("primitive", { object: x }),
          /* @__PURE__ */ y(
            "primitive",
            {
              object: D,
              ...s,
              pointSize: u,
              radianceScale: n,
              background: p,
              depthTest: !0,
              depthWrite: !1
            }
          )
        ]
      }
    );
  }
), Pe = /* @__PURE__ */ E(function({ position: e, ...t }, a) {
  const { textures: r, transientProps: o, ...c } = S(C), s = M(null);
  w(() => {
    const n = s.current;
    n != null && o != null && (n.sunDirection.copy(o.sunDirection), n.update());
  });
  const u = P(() => new Y(), []);
  return j({ SunDirectionalLight: ne }), /* @__PURE__ */ k(N, { children: [
    /* @__PURE__ */ y(
      "sunDirectionalLight",
      {
        ref: b([s, a]),
        ...c,
        ...r,
        ...t,
        target: u
      }
    ),
    /* @__PURE__ */ y("primitive", { object: u, position: e })
  ] });
});
function Se(f, e) {
  const t = A(({ gl: r }) => r);
  return e == null && (e = t.getContext().getExtension("OES_texture_float_linear") == null), {
    textures: B(O, f, (r) => {
      r.useHalfFloat = e;
    }),
    useHalfFloat: e
  };
}
export {
  ye as AerialPerspective,
  ge as Atmosphere,
  C as AtmosphereContext,
  De as Sky,
  he as SkyLight,
  ve as Stars,
  Pe as SunLight,
  Se as useAtmosphereTextureProps
};
//# sourceMappingURL=r3f.js.map
