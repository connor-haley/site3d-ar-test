"use strict";const a=require("postprocessing"),r=require("three"),f=require("@takram/three-geospatial"),l=require("@takram/three-geospatial/shaders"),b=`#include "core/depth"
#include "core/turbo"

uniform float near;
uniform float far;

void mainImage(const vec4 inputColor, const vec2 uv, out vec4 outputColor) {
  float depth = readDepth(uv);
  depth = reverseLogDepth(depth, cameraNear, cameraFar);
  depth = linearizeDepth(depth, near, far) / far;

  #ifdef USE_TURBO
  vec3 color = turbo(1.0 - depth);
  #else // USE_TURBO
  vec3 color = vec3(depth);
  #endif // USE_TURBO

  outputColor = vec4(color, inputColor.a);
}
`;var T=Object.defineProperty,B=(i,e,t,s)=>{for(var n=void 0,o=i.length-1,u;o>=0;o--)(u=i[o])&&(n=u(e,t,n)||n);return n&&T(e,t,n),n};const d={blendFunction:a.BlendFunction.SRC,useTurbo:!1,near:1,far:1e3};class p extends a.Effect{constructor(e){const{blendFunction:t,useTurbo:s,near:n,far:o}={...d,...e};super("DepthEffect",f.resolveIncludes(b,{core:{depth:l.depth,turbo:l.turbo}}),{blendFunction:t,attributes:a.EffectAttribute.DEPTH,uniforms:new Map(Object.entries({near:new r.Uniform(n),far:new r.Uniform(o)}))}),this.useTurbo=s}get near(){return this.uniforms.get("near").value}set near(e){this.uniforms.get("near").value=e}get far(){return this.uniforms.get("far").value}set far(e){this.uniforms.get("far").value=e}}B([f.define("USE_TURBO")],p.prototype,"useTurbo");const E=`#define DITHERING

#include <dithering_pars_fragment>

void mainImage(const vec4 inputColor, const vec2 uv, out vec4 outputColor) {
  outputColor = vec4(saturate(dithering(inputColor.rgb)), inputColor.a);
}
`,g={blendFunction:a.BlendFunction.NORMAL};class C extends a.Effect{constructor(e){const{blendFunction:t}={...g,...e};super("DitheringEffect",E,{blendFunction:t})}}const m=Symbol("SETUP");function _(i){const e=i.vertexShader.replace("#include <fog_pars_vertex>",`
        #include <fog_pars_vertex>
        #include <normal_pars_vertex>
      `).replace("#include <defaultnormal_vertex>",`
        #include <defaultnormal_vertex>
        #include <normal_vertex>
      `).replace("#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )","#if 1").replace("#include <clipping_planes_vertex>",`
        #include <clipping_planes_vertex>
        vViewPosition = - mvPosition.xyz;
      `);i.vertexShader=`
    #undef FLAT_SHADED
    varying vec3 vViewPosition;
    ${e}
  `;const t=i.fragmentShader.replace(/#ifndef FLAT_SHADED\s+varying vec3 vNormal;\s+#endif/m,"#include <normal_pars_fragment>").replace("#include <common>",`
        #include <common>
        #include <packing>
      `).replace("#include <specularmap_fragment>",`
        #include <specularmap_fragment>
        #include <normal_fragment_begin>
        #include <normal_fragment_maps>
      `);return i.fragmentShader=`
    #undef FLAT_SHADED
    varying vec3 vViewPosition;
    ${t}
  `,i}function v(i,{type:e}={}){if(i[m]===!0)return i;e==="basic"&&_(i);const t=e==="physical"?`
          vec4(
            packNormalToVec2(normal),
            metalnessFactor,
            roughnessFactor
          )
        `:`
          vec4(
            packNormalToVec2(normal),
            reflectivity,
            0.0
          );
        `;return i.fragmentShader=`
    layout(location = 1) out vec4 outputBuffer1;

    #if !defined(USE_ENVMAP)
      uniform float reflectivity;
    #endif // !defined(USE_ENVMAP)

    ${l.packing}
    ${i.fragmentShader.replace(/}\s*$/m,`
          outputBuffer1 = ${t};
        }
      `)}
  `,i[m]=!0,i}function w(){v(r.ShaderLib.lambert),v(r.ShaderLib.phong),v(r.ShaderLib.basic,{type:"basic"}),v(r.ShaderLib.standard,{type:"physical"}),v(r.ShaderLib.physical,{type:"physical"})}class y extends a.RenderPass{constructor(e,t,s,n){super(t,s,n),this.geometryTexture=e.texture.clone(),this.geometryTexture.isRenderTargetTexture=!0,this.geometryTexture.type=r.HalfFloatType,w()}render(e,t,s,n,o){t!=null&&(t.textures[1]=this.geometryTexture),super.render(e,t,null),t!=null&&(t.textures.length=1)}setSize(e,t){this.geometryTexture.image.width=e,this.geometryTexture.image.height=t}}const D=`#include <common>

uniform sampler2D inputBuffer;

uniform float thresholdLevel;
uniform float thresholdRange;

in vec2 vCenterUv1;
in vec2 vCenterUv2;
in vec2 vCenterUv3;
in vec2 vCenterUv4;
in vec2 vRowUv1;
in vec2 vRowUv2;
in vec2 vRowUv3;
in vec2 vRowUv4;
in vec2 vRowUv5;
in vec2 vRowUv6;
in vec2 vRowUv7;
in vec2 vRowUv8;
in vec2 vRowUv9;

float clampToBorder(const vec2 uv) {
  return float(uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0);
}

// Reference: https://learnopengl.com/Guest-Articles/2022/Phys.-Based-Bloom
void main() {
  vec3 color = 0.125 * texture(inputBuffer, vec2(vRowUv5)).rgb;
  vec4 weight =
    0.03125 *
    vec4(
      clampToBorder(vRowUv1),
      clampToBorder(vRowUv3),
      clampToBorder(vRowUv7),
      clampToBorder(vRowUv9)
    );
  color += weight.x * texture(inputBuffer, vec2(vRowUv1)).rgb;
  color += weight.y * texture(inputBuffer, vec2(vRowUv3)).rgb;
  color += weight.z * texture(inputBuffer, vec2(vRowUv7)).rgb;
  color += weight.w * texture(inputBuffer, vec2(vRowUv9)).rgb;

  weight =
    0.0625 *
    vec4(
      clampToBorder(vRowUv2),
      clampToBorder(vRowUv4),
      clampToBorder(vRowUv6),
      clampToBorder(vRowUv8)
    );
  color += weight.x * texture(inputBuffer, vec2(vRowUv2)).rgb;
  color += weight.y * texture(inputBuffer, vec2(vRowUv4)).rgb;
  color += weight.z * texture(inputBuffer, vec2(vRowUv6)).rgb;
  color += weight.w * texture(inputBuffer, vec2(vRowUv8)).rgb;

  weight =
    0.125 *
    vec4(
      clampToBorder(vRowUv2),
      clampToBorder(vRowUv4),
      clampToBorder(vRowUv6),
      clampToBorder(vRowUv8)
    );
  color += weight.x * texture(inputBuffer, vec2(vCenterUv1)).rgb;
  color += weight.y * texture(inputBuffer, vec2(vCenterUv2)).rgb;
  color += weight.z * texture(inputBuffer, vec2(vCenterUv3)).rgb;
  color += weight.w * texture(inputBuffer, vec2(vCenterUv4)).rgb;

  // WORKAROUND: Avoid screen flashes if the input buffer contains NaN texels.
  // See: https://github.com/takram-design-engineering/three-geospatial/issues/7
  if (any(isnan(color))) {
    gl_FragColor = vec4(vec3(0.0), 1.0);
    return;
  }

  float l = luminance(color);
  float scale = saturate(smoothstep(thresholdLevel, thresholdLevel + thresholdRange, l));
  gl_FragColor = vec4(color * scale, 1.0);
}
`,P=`uniform vec2 texelSize;

out vec2 vCenterUv1;
out vec2 vCenterUv2;
out vec2 vCenterUv3;
out vec2 vCenterUv4;
out vec2 vRowUv1;
out vec2 vRowUv2;
out vec2 vRowUv3;
out vec2 vRowUv4;
out vec2 vRowUv5;
out vec2 vRowUv6;
out vec2 vRowUv7;
out vec2 vRowUv8;
out vec2 vRowUv9;

void main() {
  vec2 uv = position.xy * 0.5 + 0.5;
  vCenterUv1 = uv + texelSize * vec2(-1.0, 1.0);
  vCenterUv2 = uv + texelSize * vec2(1.0, 1.0);
  vCenterUv3 = uv + texelSize * vec2(-1.0, -1.0);
  vCenterUv4 = uv + texelSize * vec2(1.0, -1.0);
  vRowUv1 = uv + texelSize * vec2(-2.0, 2.0);
  vRowUv2 = uv + texelSize * vec2(0.0, 2.0);
  vRowUv3 = uv + texelSize * vec2(2.0, 2.0);
  vRowUv4 = uv + texelSize * vec2(-2.0, 0.0);
  vRowUv5 = uv + texelSize;
  vRowUv6 = uv + texelSize * vec2(2.0, 0.0);
  vRowUv7 = uv + texelSize * vec2(-2.0, -2.0);
  vRowUv8 = uv + texelSize * vec2(0.0, -2.0);
  vRowUv9 = uv + texelSize * vec2(2.0, -2.0);

  gl_Position = vec4(position.xy, 1.0, 1.0);
}
`,A={thresholdLevel:10,thresholdRange:1};class F extends r.ShaderMaterial{constructor(e){const{inputBuffer:t=null,thresholdLevel:s,thresholdRange:n,...o}={...A,...e};super({name:"DownsampleThresholdMaterial",fragmentShader:D,vertexShader:P,blending:r.NoBlending,toneMapped:!1,depthWrite:!1,depthTest:!1,...o,uniforms:{inputBuffer:new r.Uniform(t),texelSize:new r.Uniform(new r.Vector2),thresholdLevel:new r.Uniform(s),thresholdRange:new r.Uniform(n),...o.uniforms}})}setSize(e,t){this.uniforms.texelSize.value.set(1/e,1/t)}get inputBuffer(){return this.uniforms.inputBuffer.value}set inputBuffer(e){this.uniforms.inputBuffer.value=e}get thresholdLevel(){return this.uniforms.thresholdLevel.value}set thresholdLevel(e){this.uniforms.thresholdLevel.value=e}get thresholdRange(){return this.uniforms.thresholdRange.value}set thresholdRange(e){this.uniforms.thresholdRange.value=e}}const M=`#include <common>

#define SQRT_2 (0.7071067811865476)

uniform sampler2D inputBuffer;

uniform vec2 texelSize;
uniform float ghostAmount;
uniform float haloAmount;
uniform float chromaticAberration;

in vec2 vUv;
in vec2 vAspectRatio;

vec3 sampleGhost(const vec2 direction, const vec3 color, const float offset) {
  vec2 suv = clamp(1.0 - vUv + direction * offset, 0.0, 1.0);
  vec3 result = texture(inputBuffer, suv).rgb * color;

  // Falloff at the perimeter.
  float d = clamp(length(0.5 - suv) / (0.5 * SQRT_2), 0.0, 1.0);
  result *= pow(1.0 - d, 3.0);
  return result;
}

vec4 sampleGhosts(float amount) {
  vec3 color = vec3(0.0);
  vec2 direction = vUv - 0.5;
  color += sampleGhost(direction, vec3(0.8, 0.8, 1.0), -5.0);
  color += sampleGhost(direction, vec3(1.0, 0.8, 0.4), -1.5);
  color += sampleGhost(direction, vec3(0.9, 1.0, 0.8), -0.4);
  color += sampleGhost(direction, vec3(1.0, 0.8, 0.4), -0.2);
  color += sampleGhost(direction, vec3(0.9, 0.7, 0.7), -0.1);
  color += sampleGhost(direction, vec3(0.5, 1.0, 0.4), 0.7);
  color += sampleGhost(direction, vec3(0.5, 0.5, 0.5), 1.0);
  color += sampleGhost(direction, vec3(1.0, 1.0, 0.6), 2.5);
  color += sampleGhost(direction, vec3(0.5, 0.8, 1.0), 10.0);
  return vec4(color * amount, 1.0);
}

// Reference: https://john-chapman.github.io/2017/11/05/pseudo-lens-flare.html
float cubicRingMask(const float x, const float radius, const float thickness) {
  float v = min(abs(x - radius) / thickness, 1.0);
  return 1.0 - v * v * (3.0 - 2.0 * v);
}

vec3 sampleHalo(const float radius) {
  vec2 direction = normalize((vUv - 0.5) / vAspectRatio) * vAspectRatio;
  vec3 offset = vec3(texelSize.x * chromaticAberration) * vec3(-1.0, 0.0, 1.0);
  vec2 suv = fract(1.0 - vUv + direction * radius);
  vec3 result = vec3(
    texture(inputBuffer, suv + direction * offset.r).r,
    texture(inputBuffer, suv + direction * offset.g).g,
    texture(inputBuffer, suv + direction * offset.b).b
  );

  // Falloff at the center and perimeter.
  vec2 wuv = (vUv - vec2(0.5, 0.0)) / vAspectRatio + vec2(0.5, 0.0);
  float d = saturate(distance(wuv, vec2(0.5)));
  result *= cubicRingMask(d, 0.45, 0.25);
  return result;
}

vec4 sampleHalos(const float amount) {
  vec3 color = vec3(0.0);
  color += sampleHalo(0.3);
  return vec4(color, 1.0) * amount;
}

void main() {
  gl_FragColor += sampleGhosts(ghostAmount);
  gl_FragColor += sampleHalos(haloAmount);
}

`,z=`uniform vec2 texelSize;

out vec2 vUv;
out vec2 vAspectRatio;

void main() {
  vUv = position.xy * 0.5 + 0.5;
  vAspectRatio = vec2(texelSize.x / texelSize.y, 1.0);
  gl_Position = vec4(position.xy, 1.0, 1.0);
}
`,O={ghostAmount:.001,haloAmount:.001,chromaticAberration:10};class L extends r.ShaderMaterial{constructor(e){const{inputBuffer:t=null,ghostAmount:s,haloAmount:n,chromaticAberration:o,...u}={...O,...e};super({name:"LensFlareFeaturesMaterial",fragmentShader:M,vertexShader:z,blending:r.NoBlending,toneMapped:!1,depthWrite:!1,depthTest:!1,uniforms:{inputBuffer:new r.Uniform(t),texelSize:new r.Uniform(new r.Vector2),ghostAmount:new r.Uniform(s),haloAmount:new r.Uniform(n),chromaticAberration:new r.Uniform(o),...u.uniforms}})}setSize(e,t){this.uniforms.texelSize.value.set(1/e,1/t)}get inputBuffer(){return this.uniforms.inputBuffer.value}set inputBuffer(e){this.uniforms.inputBuffer.value=e}get ghostAmount(){return this.uniforms.ghostAmount.value}set ghostAmount(e){this.uniforms.ghostAmount.value=e}get haloAmount(){return this.uniforms.haloAmount.value}set haloAmount(e){this.uniforms.haloAmount.value=e}get chromaticAberration(){return this.uniforms.chromaticAberration.value}set chromaticAberration(e){this.uniforms.chromaticAberration.value=e}}const N=`uniform sampler2D bloomBuffer;
uniform sampler2D featuresBuffer;
uniform float intensity;

void mainImage(const vec4 inputColor, const vec2 uv, out vec4 outputColor) {
  vec3 bloom = texture(bloomBuffer, uv).rgb;
  vec3 features = texture(featuresBuffer, uv).rgb;
  outputColor = vec4(inputColor.rgb + (bloom + features) * intensity, inputColor.a);
}
`,x={blendFunction:a.BlendFunction.NORMAL,resolutionScale:.5,width:a.Resolution.AUTO_SIZE,height:a.Resolution.AUTO_SIZE,intensity:.005};class G extends a.Effect{constructor(e){const{blendFunction:t,resolutionScale:s,width:n,height:o,resolutionX:u=n,resolutionY:c=o,intensity:S}={...x,...e};super("LensFlareEffect",N,{blendFunction:t,attributes:a.EffectAttribute.CONVOLUTION,uniforms:new Map(Object.entries({bloomBuffer:new r.Uniform(null),featuresBuffer:new r.Uniform(null),intensity:new r.Uniform(1)}))}),this.onResolutionChange=()=>{this.setSize(this.resolution.baseWidth,this.resolution.baseHeight)},this.renderTarget1=new r.WebGLRenderTarget(1,1,{depthBuffer:!1,stencilBuffer:!1,type:r.HalfFloatType}),this.renderTarget1.texture.name="LensFlare.Target1",this.renderTarget2=new r.WebGLRenderTarget(1,1,{depthBuffer:!1,stencilBuffer:!1,type:r.HalfFloatType}),this.renderTarget2.texture.name="LensFlare.Target2",this.thresholdMaterial=new F,this.thresholdPass=new a.ShaderPass(this.thresholdMaterial),this.blurPass=new a.MipmapBlurPass,this.blurPass.levels=8,this.preBlurPass=new a.KawaseBlurPass({kernelSize:a.KernelSize.SMALL}),this.featuresMaterial=new L,this.featuresPass=new a.ShaderPass(this.featuresMaterial),this.uniforms.get("bloomBuffer").value=this.blurPass.texture,this.uniforms.get("featuresBuffer").value=this.renderTarget1.texture,this.resolution=new a.Resolution(this,u,c,s),this.resolution.addEventListener("change",this.onResolutionChange),this.intensity=S}initialize(e,t,s){this.thresholdPass.initialize(e,t,s),this.blurPass.initialize(e,t,s),this.preBlurPass.initialize(e,t,s),this.featuresPass.initialize(e,t,s)}update(e,t,s){this.thresholdPass.render(e,t,this.renderTarget1),this.blurPass.render(e,this.renderTarget1,null),this.preBlurPass.render(e,this.renderTarget1,this.renderTarget2),this.featuresPass.render(e,this.renderTarget2,this.renderTarget1)}setSize(e,t){const s=this.resolution;s.setBaseSize(e,t);const{width:n,height:o}=s;this.renderTarget1.setSize(n,o),this.renderTarget2.setSize(n,o),this.thresholdMaterial.setSize(n,o),this.blurPass.setSize(n,o),this.preBlurPass.setSize(n,o),this.featuresMaterial.setSize(n,o)}get intensity(){return this.uniforms.get("intensity").value}set intensity(e){this.uniforms.get("intensity").value=e}get thresholdLevel(){return this.thresholdMaterial.thresholdLevel}set thresholdLevel(e){this.thresholdMaterial.thresholdLevel=e}get thresholdRange(){return this.thresholdMaterial.thresholdRange}set thresholdRange(e){this.thresholdMaterial.thresholdRange=e}}const j=`#include "core/depth"
#include "core/packing"
#include "core/transform"

uniform highp sampler2D normalBuffer;

uniform mat4 projectionMatrix;
uniform mat4 inverseProjectionMatrix;

vec3 reconstructNormal(const vec2 uv) {
  float depth = readDepth(uv);
  depth = reverseLogDepth(depth, cameraNear, cameraFar);
  vec3 position = screenToView(
    uv,
    depth,
    getViewZ(depth),
    projectionMatrix,
    inverseProjectionMatrix
  );
  vec3 dx = dFdx(position);
  vec3 dy = dFdy(position);
  return normalize(cross(dx, dy));
}

vec3 readNormal(const vec2 uv) {
  #ifdef OCT_ENCODED
  return unpackVec2ToNormal(texture(normalBuffer, uv).xy);
  #else // OCT_ENCODED
  return 2.0 * texture(normalBuffer, uv).xyz - 1.0;
  #endif // OCT_ENCODED
}

void mainImage(const vec4 inputColor, const vec2 uv, out vec4 outputColor) {
  #ifdef RECONSTRUCT_FROM_DEPTH
  vec3 normal = reconstructNormal(uv);
  #else // RECONSTRUCT_FROM_DEPTH
  vec3 normal = readNormal(uv);
  #endif // RECONSTRUCT_FROM_DEPTH

  outputColor = vec4(normal * 0.5 + 0.5, inputColor.a);
}
`;var H=Object.defineProperty,U=(i,e,t,s)=>{for(var n=void 0,o=i.length-1,u;o>=0;o--)(u=i[o])&&(n=u(e,t,n)||n);return n&&H(e,t,n),n};const R={blendFunction:a.BlendFunction.SRC,octEncoded:!1,reconstructFromDepth:!1};class h extends a.Effect{constructor(e,t){const{blendFunction:s,normalBuffer:n=null,octEncoded:o,reconstructFromDepth:u}={...R,...t};super("NormalEffect",f.resolveIncludes(j,{core:{depth:l.depth,packing:l.packing,transform:l.transform}}),{blendFunction:s,attributes:a.EffectAttribute.DEPTH,uniforms:new Map(Object.entries({normalBuffer:new r.Uniform(n),projectionMatrix:new r.Uniform(new r.Matrix4),inverseProjectionMatrix:new r.Uniform(new r.Matrix4)}))}),this.camera=e,e!=null&&(this.mainCamera=e),this.octEncoded=o,this.reconstructFromDepth=u}get mainCamera(){return this.camera}set mainCamera(e){this.camera=e}update(e,t,s){const n=this.uniforms,o=n.get("projectionMatrix"),u=n.get("inverseProjectionMatrix"),c=this.camera;c!=null&&(o.value.copy(c.projectionMatrix),u.value.copy(c.projectionMatrixInverse))}get normalBuffer(){return this.uniforms.get("normalBuffer").value}set normalBuffer(e){this.uniforms.get("normalBuffer").value=e}}U([f.define("OCT_ENCODED")],h.prototype,"octEncoded");U([f.define("RECONSTRUCT_FROM_DEPTH")],h.prototype,"reconstructFromDepth");exports.DepthEffect=p;exports.DitheringEffect=C;exports.GeometryPass=y;exports.LensFlareEffect=G;exports.NormalEffect=h;exports.depthEffectOptionsDefaults=d;exports.ditheringOptionsDefaults=g;exports.lensFlareEffectOptionsDefaults=x;exports.normalEffectOptionsDefaults=R;exports.setupMaterialsForGeometryPass=w;
//# sourceMappingURL=shared.cjs.map
