var B = Object.defineProperty;
var W = (p, t, i) => t in p ? B(p, t, { enumerable: !0, configurable: !0, writable: !0, value: i }) : p[t] = i;
var z = (p, t, i) => W(p, typeof t != "symbol" ? t + "" : t, i);
import { Vector3 as c, Matrix4 as $, BufferGeometry as Q, BufferAttribute as F } from "three";
const X = /* @__PURE__ */ new c();
function D(p, t, i = new c(), r) {
  const { x: s, y: n, z: e } = p, a = t.x, o = t.y, y = t.z, d = s * s * a, u = n * n * o, m = e * e * y, l = d + u + m, h = Math.sqrt(1 / l);
  if (!Number.isFinite(h))
    return;
  const f = X.copy(p).multiplyScalar(h);
  if (l < ((r == null ? void 0 : r.centerTolerance) ?? 0.1))
    return i.copy(f);
  const E = f.multiply(t).multiplyScalar(2);
  let M = (1 - h) * p.length() / (E.length() / 2), I = 0, w, x, g, A;
  do {
    M -= I, w = 1 / (1 + M * a), x = 1 / (1 + M * o), g = 1 / (1 + M * y);
    const q = w * w, L = x * x, T = g * g, G = q * w, P = L * x, j = T * g;
    A = d * q + u * L + m * T - 1, I = A / ((d * G * a + u * P * o + m * j * y) * -2);
  } while (Math.abs(A) > 1e-12);
  return i.set(s * w, n * x, e * g);
}
const N = /* @__PURE__ */ new c(), U = /* @__PURE__ */ new c(), O = /* @__PURE__ */ new c(), V = class V {
  constructor(t, i, r) {
    z(this, "radii");
    this.radii = new c(t, i, r);
  }
  get minimumRadius() {
    return Math.min(this.radii.x, this.radii.y, this.radii.z);
  }
  get maximumRadius() {
    return Math.max(this.radii.x, this.radii.y, this.radii.z);
  }
  reciprocalRadii(t = new c()) {
    const { x: i, y: r, z: s } = this.radii;
    return t.set(1 / i, 1 / r, 1 / s);
  }
  reciprocalRadiiSquared(t = new c()) {
    const { x: i, y: r, z: s } = this.radii;
    return t.set(1 / i ** 2, 1 / r ** 2, 1 / s ** 2);
  }
  projectOnSurface(t, i = new c(), r) {
    return D(
      t,
      this.reciprocalRadiiSquared(),
      i,
      r
    );
  }
  getSurfaceNormal(t, i = new c()) {
    return i.multiplyVectors(this.reciprocalRadiiSquared(N), t).normalize();
  }
  getEastNorthUpVectors(t, i = new c(), r = new c(), s = new c()) {
    this.getSurfaceNormal(t, s), i.set(-t.y, t.x, 0).normalize(), r.crossVectors(s, i).normalize();
  }
  getEastNorthUpFrame(t, i = new $()) {
    const r = N, s = U, n = O;
    return this.getEastNorthUpVectors(t, r, s, n), i.makeBasis(r, s, n).setPosition(t);
  }
  getIntersection(t, i = new c()) {
    const r = this.reciprocalRadii(N), s = U.copy(r).multiply(t.origin), n = O.copy(r).multiply(t.direction), e = s.lengthSq(), a = n.lengthSq(), o = s.dot(n), y = o ** 2 - a * (e - 1);
    if (e === 1)
      return i.copy(t.origin);
    if (e > 1) {
      if (o >= 0 || y < 0)
        return;
      const d = Math.sqrt(y), u = (-o - d) / a, m = (-o + d) / a;
      return t.at(Math.min(u, m), i);
    }
    if (e < 1) {
      const d = o ** 2 - a * (e - 1), u = Math.sqrt(d), m = (-o + u) / a;
      return t.at(m, i);
    }
    if (o < 0)
      return t.at(-o / a, i);
  }
  getOsculatingSphereCenter(t, i, r = new c()) {
    const s = this.radii.x ** 2, n = N.set(
      t.x / s,
      t.y / s,
      t.z / this.radii.z ** 2
    ).normalize();
    return r.copy(n.multiplyScalar(-i).add(t));
  }
};
z(V, "WGS84", /* @__PURE__ */ new V(
  6378137,
  6378137,
  6356752314245179e-9
));
let b = V;
class J extends Q {
  constructor(i = new c(1, 1, 1), r = 32, s = 16) {
    super();
    z(this, "type", "EllipsoidGeometry");
    z(this, "parameters");
    this.parameters = {
      radii: i,
      longitudeSegments: r,
      latitudeSegments: s
    }, r = Math.max(3, Math.floor(r)), s = Math.max(2, Math.floor(s));
    const n = (r + 1) * (s + 1), e = new c(), a = new c(), o = new Float32Array(n * 3), y = new Float32Array(n * 3), d = new Float32Array(n * 2), u = [], m = [];
    for (let l = 0, h = 0, f = 0, E = 0; l <= s; ++l) {
      const M = [], I = l / s, w = I * Math.PI;
      let x = 0;
      l === 0 ? x = 0.5 / r : l === s && (x = -0.5 / r);
      for (let g = 0; g <= r; ++g, h += 3, f += 2, ++E) {
        const A = g / r, q = A * Math.PI * 2;
        e.x = i.x * Math.cos(q) * Math.sin(w), e.y = i.y * Math.sin(q) * Math.sin(w), e.z = i.z * Math.cos(w), o[h] = e.x, o[h + 1] = e.y, o[h + 2] = e.z, a.copy(e).normalize(), y[h] = a.x, y[h + 1] = a.y, y[h + 2] = a.z, d[f] = A + x, d[f + 1] = 1 - I, M.push(E);
      }
      u.push(M);
    }
    for (let l = 0; l < s; ++l)
      for (let h = 0; h < r; ++h) {
        const f = u[l][h + 1], E = u[l][h], M = u[l + 1][h], I = u[l + 1][h + 1];
        l !== 0 && m.push(f, E, I), l !== s - 1 && m.push(E, M, I);
      }
    this.setIndex(m), this.setAttribute("position", new F(o, 3)), this.setAttribute("normal", new F(y, 3)), this.setAttribute("uv", new F(d, 2));
  }
  copy(i) {
    return super.copy(i), this.parameters = { ...i.parameters }, this;
  }
}
const S = /* @__PURE__ */ new c(), R = /* @__PURE__ */ new c(), v = class v {
  constructor(t = 0, i = 0, r = 0) {
    this.longitude = t, this.latitude = i, this.height = r;
  }
  set(t, i, r) {
    return this.longitude = t, this.latitude = i, r != null && (this.height = r), this;
  }
  clone() {
    return new v(this.longitude, this.latitude, this.height);
  }
  copy(t) {
    return this.longitude = t.longitude, this.latitude = t.latitude, this.height = t.height, this;
  }
  equals(t) {
    return t.longitude === this.longitude && t.latitude === this.latitude && t.height === this.height;
  }
  setLongitude(t) {
    return this.longitude = t, this;
  }
  setLatitude(t) {
    return this.latitude = t, this;
  }
  setHeight(t) {
    return this.height = t, this;
  }
  normalize() {
    return this.longitude < v.MIN_LONGITUDE && (this.longitude += Math.PI * 2), this;
  }
  // See: https://en.wikipedia.org/wiki/Geographic_coordinate_conversion
  // Reference: https://github.com/CesiumGS/cesium/blob/1.122/packages/engine/Source/Core/Geodetic.js#L119
  setFromECEF(t, i) {
    const s = ((i == null ? void 0 : i.ellipsoid) ?? b.WGS84).reciprocalRadiiSquared(S), n = D(
      t,
      s,
      R,
      i
    );
    if (n == null)
      throw new Error(
        `Could not project position to ellipsoid surface: ${t.toArray()}`
      );
    const e = S.multiplyVectors(n, s).normalize();
    this.longitude = Math.atan2(e.y, e.x), this.latitude = Math.asin(e.z);
    const a = S.subVectors(t, n);
    return this.height = Math.sign(a.dot(t)) * a.length(), this;
  }
  // See: https://en.wikipedia.org/wiki/Geographic_coordinate_conversion
  // Reference: https://github.com/CesiumGS/cesium/blob/1.122/packages/engine/Source/Core/Cartesian3.js#L916
  toECEF(t = new c(), i) {
    const r = (i == null ? void 0 : i.ellipsoid) ?? b.WGS84, s = S.multiplyVectors(
      r.radii,
      r.radii
    ), n = Math.cos(this.latitude), e = R.set(
      n * Math.cos(this.longitude),
      n * Math.sin(this.longitude),
      Math.sin(this.latitude)
    ).normalize();
    return t.multiplyVectors(s, e), t.divideScalar(Math.sqrt(e.dot(t))).add(e.multiplyScalar(this.height));
  }
  fromArray(t, i = 0) {
    return this.longitude = t[i], this.latitude = t[i + 1], this.height = t[i + 2], this;
  }
  toArray(t = [], i = 0) {
    return t[i] = this.longitude, t[i + 1] = this.latitude, t[i + 2] = this.height, t;
  }
  *[Symbol.iterator]() {
    yield this.longitude, yield this.latitude, yield this.height;
  }
};
z(v, "MIN_LONGITUDE", -Math.PI), z(v, "MAX_LONGITUDE", Math.PI), z(v, "MIN_LATITUDE", -Math.PI / 2), z(v, "MAX_LATITUDE", Math.PI / 2);
let C = v;
export {
  b as E,
  C as G,
  J as a
};
//# sourceMappingURL=shared.js.map
