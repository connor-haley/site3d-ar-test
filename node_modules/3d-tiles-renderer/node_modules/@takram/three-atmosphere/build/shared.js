var Kn = Object.defineProperty;
var Jn = (e, n, t) => n in e ? Kn(e, n, { enumerable: !0, configurable: !0, writable: !0, value: t }) : e[n] = t;
var g = (e, n, t) => Jn(e, typeof n != "symbol" ? n + "" : n, t);
import { BlendFunction as Qn, Effect as nt, EffectAttribute as tt } from "postprocessing";
import { Vector3 as p, Uniform as m, Matrix4 as U, Camera as et, MathUtils as En, RawShaderMaterial as rt, Color as it, Vector2 as sn, Loader as ot, Data3DTexture as at, LightProbe as st, GLSL3 as On, BufferGeometry as ct, InterleavedBuffer as Sn, InterleavedBufferAttribute as k0, Sphere as ut, DirectionalLight as lt } from "three";
import { radians as xn, assertType as dt, Ellipsoid as _0, depthShader as _t, packingShader as mt, transformShader as ft, Geodetic as ht, clamp as wn, Float32Data3DLoader as vt, Float32Data2DLoader as An } from "@takram/three-geospatial";
const gt = [
  "solarIrradiance",
  "sunAngularRadius",
  "bottomRadius",
  "topRadius",
  "rayleighScattering",
  "mieScattering",
  "miePhaseFunctionG",
  "muSMinFloat",
  "muSMinHalfFloat",
  "skyRadianceToLuminance",
  "sunRadianceToLuminance",
  "luminousEfficiency"
];
function pt(e, n) {
  if (n != null)
    for (const t of gt) {
      const r = n[t];
      r != null && (e[t] instanceof p ? e[t].copy(r) : (dt(t), e[t] = r));
    }
}
const N0 = class N0 {
  constructor(n) {
    g(this, "solarIrradiance", new p(1.474, 1.8504, 1.91198));
    g(this, "sunAngularRadius", 4675e-6);
    g(this, "bottomRadius", 636e4);
    g(this, "topRadius", 642e4);
    g(this, "rayleighScattering", new p(5802e-6, 0.013558, 0.0331));
    g(this, "mieScattering", new p(3996e-6, 3996e-6, 3996e-6));
    g(this, "miePhaseFunctionG", 0.8);
    g(this, "muSMinFloat", Math.cos(xn(120)));
    g(this, "muSMinHalfFloat", Math.cos(xn(102)));
    // Radiance to luminance conversion
    // prettier-ignore
    g(this, "skyRadianceToLuminance", new p(114974.916437, 71305.954816, 65310.548555));
    g(this, "sunRadianceToLuminance", new p(98242.786222, 69954.398112, 66475.012354));
    g(this, "luminousEfficiency", new p(0.2126, 0.7152, 0.0722));
    g(this, "skyRadianceToRelativeLuminance", new p());
    g(this, "sunRadianceToRelativeLuminance", new p());
    pt(this, n);
    const t = this.luminousEfficiency.dot(this.skyRadianceToLuminance);
    this.skyRadianceToRelativeLuminance.copy(this.skyRadianceToLuminance).divideScalar(t), this.sunRadianceToRelativeLuminance.copy(this.sunRadianceToLuminance).divideScalar(t);
  }
};
g(N0, "DEFAULT", /* @__PURE__ */ new N0());
let X = N0;
const D0 = 64, P0 = 16, cn = 32, un = 128, ln = 32, dn = 8, Tt = dn * ln, Rt = un, Et = cn, U0 = 256, G0 = 64, e0 = 1 / 1e3, je = 100;
var St = `uniform sampler2D normalBuffer;

uniform mat4 projectionMatrix;
uniform mat4 inverseProjectionMatrix;
uniform mat4 inverseViewMatrix;
uniform float cameraHeight;
uniform vec3 sunDirection;
uniform vec3 moonDirection;
uniform float moonAngularRadius;
uniform float lunarRadianceScale;
uniform float irradianceScale;
uniform float idealSphereAlpha;

varying vec3 vWorldPosition;
varying vec3 vWorldDirection;
varying vec3 vEllipsoidCenter;
varying vec3 vSkyEllipsoidCenter;
varying vec3 vEllipsoidRadiiSquared;

vec3 readNormal(const vec2 uv) {
  #ifdef OCT_ENCODED_NORMAL
  return unpackVec2ToNormal(texture2D(normalBuffer, uv).xy);
  #else
  return 2.0 * texture2D(normalBuffer, uv).xyz - 1.0;
  #endif 
}

void correctGeometricError(inout vec3 worldPosition, inout vec3 worldNormal) {
  
  vec3 normal = normalize(1.0 / vEllipsoidRadiiSquared * worldPosition);
  vec3 position = u_bottom_radius * normal;
  worldNormal = mix(worldNormal, normal, idealSphereAlpha);
  worldPosition = mix(worldPosition, position, idealSphereAlpha);
}

#if defined(SUN_IRRADIANCE) || defined(SKY_IRRADIANCE)
vec3 getSunSkyIrradiance(
  const vec3 worldPosition,
  const vec3 worldNormal,
  const vec3 inputColor
) {
  
  
  vec3 albedo = inputColor * irradianceScale * RECIPROCAL_PI;
  vec3 skyIrradiance;
  vec3 sunIrradiance = GetSunAndSkyIrradiance(
    worldPosition - vEllipsoidCenter,
    worldNormal,
    sunDirection,
    skyIrradiance
  );
  #if defined(SUN_IRRADIANCE) && defined(SKY_IRRADIANCE)
  return albedo * (sunIrradiance + skyIrradiance);
  #elif defined(SUN_IRRADIANCE)
  return albedo * sunIrradiance;
  #elif defined(SKY_IRRADIANCE)
  return albedo * skyIrradiance;
  #endif
}
#endif 

#if defined(TRANSMITTANCE) || defined(INSCATTER)
void getTransmittanceInscatter(
  const vec3 worldPosition,
  const vec3 worldNormal,
  inout vec3 radiance
) {
  vec3 transmittance;
  vec3 inscatter = GetSkyRadianceToPoint(
    vWorldPosition - vEllipsoidCenter,
    worldPosition - vEllipsoidCenter,
    0.0, 
    sunDirection,
    transmittance
  );
  #if defined(TRANSMITTANCE)
  radiance = radiance * transmittance;
  #endif
  #if defined(INSCATTER)
  radiance = radiance + inscatter;
  #endif
}
#endif 

void mainImage(const vec4 inputColor, const vec2 uv, out vec4 outputColor) {
  float depth = readDepth(uv);
  if (depth >= 1.0 - 1e-7) {
    #ifdef SKY
    vec3 viewPosition = vWorldPosition - vSkyEllipsoidCenter;
    vec3 rayDirection = normalize(vWorldDirection);
    outputColor.rgb = getSkyRadiance(
      viewPosition,
      rayDirection,
      sunDirection,
      moonDirection,
      moonAngularRadius,
      lunarRadianceScale
    );
    outputColor.a = 1.0;
    #else
    outputColor = inputColor;
    #endif 
    return;
  }
  depth = reverseLogDepth(depth, cameraNear, cameraFar);

  
  vec3 viewPosition = screenToView(
    uv,
    depth,
    getViewZ(depth),
    projectionMatrix,
    inverseProjectionMatrix
  );
  vec3 viewNormal;
  #ifdef RECONSTRUCT_NORMAL
  vec3 dx = dFdx(viewPosition);
  vec3 dy = dFdy(viewPosition);
  viewNormal = normalize(cross(dx, dy));
  #else
  viewNormal = readNormal(uv);
  #endif 

  vec3 worldPosition =
    (inverseViewMatrix * vec4(viewPosition, 1.0)).xyz * METER_TO_UNIT_LENGTH;
  vec3 worldNormal = normalize(mat3(inverseViewMatrix) * viewNormal);

  #ifdef CORRECT_GEOMETRIC_ERROR
  correctGeometricError(worldPosition, worldNormal);
  #endif 

  vec3 radiance;
  #if defined(SUN_IRRADIANCE) || defined(SKY_IRRADIANCE)
  radiance = getSunSkyIrradiance(worldPosition, worldNormal, inputColor.rgb);
  #else
  radiance = inputColor.rgb;
  #endif 

  #if defined(TRANSMITTANCE) || defined(INSCATTER)
  getTransmittanceInscatter(worldPosition, worldNormal, radiance);
  #endif 

  outputColor = vec4(radiance, inputColor.a);
}`, xt = `uniform mat4 inverseViewMatrix;
uniform mat4 inverseProjectionMatrix;
uniform vec3 cameraPosition;
uniform float cameraHeight;
uniform vec3 ellipsoidCenter;
uniform vec3 ellipsoidRadii;
uniform float idealSphereAlpha;

varying vec3 vWorldPosition;
varying vec3 vWorldDirection;
varying vec3 vEllipsoidCenter;
varying vec3 vSkyEllipsoidCenter;
varying vec3 vEllipsoidRadiiSquared;

void getCameraRay(out vec3 origin, out vec3 direction) {
  bool isPerspective = inverseProjectionMatrix[2][3] != 0.0; 

  if (isPerspective) {
    
    vec4 viewPosition = inverseProjectionMatrix * vec4(position, 1.0);
    vec4 worldDirection = inverseViewMatrix * vec4(viewPosition.xyz, 0.0);
    origin = cameraPosition;
    direction = worldDirection.xyz;
  } else {
    
    vec4 nearPoint = inverseProjectionMatrix * vec4(position.xy, -1.0, 1.0);
    vec4 farPoint = inverseProjectionMatrix * vec4(position.xy, -0.9, 1.0);
    nearPoint /= nearPoint.w;
    farPoint /= farPoint.w;

    
    vec4 worldDirection =
      inverseViewMatrix * vec4(farPoint.xyz - nearPoint.xyz, 0.0);
    vec4 worldOrigin = inverseViewMatrix * nearPoint;

    
    direction = worldDirection.xyz;
    origin = worldOrigin.xyz;
  }
}

void mainSupport() {
  vec3 direction, origin;
  getCameraRay(origin, direction);
  vWorldPosition = origin * METER_TO_UNIT_LENGTH;
  vWorldDirection = direction;

  vSkyEllipsoidCenter = ellipsoidCenter * METER_TO_UNIT_LENGTH;
  #ifdef CORRECT_GEOMETRIC_ERROR
  
  
  
  vEllipsoidCenter =
    mix(ellipsoidCenter, vec3(0.0), idealSphereAlpha) * METER_TO_UNIT_LENGTH;
  #else
  vEllipsoidCenter = vSkyEllipsoidCenter;
  #endif 

  vec3 radii = ellipsoidRadii * METER_TO_UNIT_LENGTH;
  vEllipsoidRadiiSquared = radii * radii;
}`, _n = `float ClampCosine(float mu) {
  return clamp(mu, float(-1.0), float(1.0));
}

float ClampDistance(float d) {
  return max(d, 0.0);
}

float ClampRadius(float r) {
  return clamp(r, u_bottom_radius, u_top_radius);
}

float SafeSqrt(float a) {
  return sqrt(max(a, 0.0));
}

float DistanceToTopAtmosphereBoundary(float r, float mu) {
  float discriminant = r * r * (mu * mu - 1.0) + u_top_radius * u_top_radius;
  return ClampDistance(-r * mu + SafeSqrt(discriminant));
}

float DistanceToBottomAtmosphereBoundary(float r, float mu) {
  float discriminant =
    r * r * (mu * mu - 1.0) + u_bottom_radius * u_bottom_radius;
  return ClampDistance(-r * mu - SafeSqrt(discriminant));
}

bool RayIntersectsGround(float r, float mu) {
  return mu < 0.0 &&
  r * r * (mu * mu - 1.0) + u_bottom_radius * u_bottom_radius >= 0.0;
}

float GetTextureCoordFromUnitRange(float x, int texture_size) {
  return 0.5 / float(texture_size) + x * (1.0 - 1.0 / float(texture_size));
}

float GetUnitRangeFromTextureCoord(float u, int texture_size) {
  return (u - 0.5 / float(texture_size)) / (1.0 - 1.0 / float(texture_size));
}

vec2 GetTransmittanceTextureUvFromRMu(float r, float mu) {
  float H = sqrt(
    u_top_radius * u_top_radius - u_bottom_radius * u_bottom_radius
  );
  float rho = SafeSqrt(r * r - u_bottom_radius * u_bottom_radius);
  float d = DistanceToTopAtmosphereBoundary(r, mu);
  float d_min = u_top_radius - r;
  float d_max = rho + H;
  float x_mu = (d - d_min) / (d_max - d_min);
  float x_r = rho / H;
  return vec2(
    GetTextureCoordFromUnitRange(x_mu, TRANSMITTANCE_TEXTURE_WIDTH),
    GetTextureCoordFromUnitRange(x_r, TRANSMITTANCE_TEXTURE_HEIGHT)
  );
}

vec3 GetTransmittanceToTopAtmosphereBoundary(
  const sampler2D u_transmittance_texture,
  float r,
  float mu
) {
  vec2 uv = GetTransmittanceTextureUvFromRMu(r, mu);
  return vec3(texture(u_transmittance_texture, uv));
}

vec3 GetTransmittance(
  const sampler2D u_transmittance_texture,
  float r,
  float mu,
  float d,
  bool ray_r_mu_intersects_ground
) {
  float r_d = ClampRadius(sqrt(d * d + 2.0 * r * mu * d + r * r));
  float mu_d = ClampCosine((r * mu + d) / r_d);
  if (ray_r_mu_intersects_ground) {
    return min(
      GetTransmittanceToTopAtmosphereBoundary(
        u_transmittance_texture,
        r_d,
        -mu_d
      ) /
        GetTransmittanceToTopAtmosphereBoundary(
          u_transmittance_texture,
          r,
          -mu
        ),
      vec3(1.0)
    );
  } else {
    return min(
      GetTransmittanceToTopAtmosphereBoundary(u_transmittance_texture, r, mu) /
        GetTransmittanceToTopAtmosphereBoundary(
          u_transmittance_texture,
          r_d,
          mu_d
        ),
      vec3(1.0)
    );
  }
}

vec3 GetTransmittanceToSun(
  const sampler2D u_transmittance_texture,
  float r,
  float mu_s
) {
  float sin_theta_h = u_bottom_radius / r;
  float cos_theta_h = -sqrt(max(1.0 - sin_theta_h * sin_theta_h, 0.0));
  return GetTransmittanceToTopAtmosphereBoundary(
    u_transmittance_texture,
    r,
    mu_s
  ) *
  smoothstep(
    -sin_theta_h * u_sun_angular_radius,
    sin_theta_h * u_sun_angular_radius,
    mu_s - cos_theta_h
  );
}

float DistanceToNearestAtmosphereBoundary(
  float r,
  float mu,
  bool ray_r_mu_intersects_ground
) {
  if (ray_r_mu_intersects_ground) {
    return DistanceToBottomAtmosphereBoundary(r, mu);
  } else {
    return DistanceToTopAtmosphereBoundary(r, mu);
  }
}

float RayleighPhaseFunction(float nu) {
  float k = 3.0 / (16.0 * PI);
  return k * (1.0 + nu * nu);
}

float MiePhaseFunction(float g, float nu) {
  float k = 3.0 / (8.0 * PI) * (1.0 - g * g) / (2.0 + g * g);
  return k * (1.0 + nu * nu) / pow(1.0 + g * g - 2.0 * g * nu, 1.5);
}

vec4 GetScatteringTextureUvwzFromRMuMuSNu(
  float r,
  float mu,
  float mu_s,
  float nu,
  bool ray_r_mu_intersects_ground
) {
  float H = sqrt(
    u_top_radius * u_top_radius - u_bottom_radius * u_bottom_radius
  );
  float rho = SafeSqrt(r * r - u_bottom_radius * u_bottom_radius);
  float u_r = GetTextureCoordFromUnitRange(rho / H, SCATTERING_TEXTURE_R_SIZE);
  float r_mu = r * mu;
  float discriminant = r_mu * r_mu - r * r + u_bottom_radius * u_bottom_radius;
  float u_mu;
  if (ray_r_mu_intersects_ground) {
    float d = -r_mu - SafeSqrt(discriminant);
    float d_min = r - u_bottom_radius;
    float d_max = rho;
    u_mu =
      0.5 -
      0.5 *
        GetTextureCoordFromUnitRange(
          d_max == d_min
            ? 0.0
            : (d - d_min) / (d_max - d_min),
          SCATTERING_TEXTURE_MU_SIZE / 2
        );
  } else {
    float d = -r_mu + SafeSqrt(discriminant + H * H);
    float d_min = u_top_radius - r;
    float d_max = rho + H;
    u_mu =
      0.5 +
      0.5 *
        GetTextureCoordFromUnitRange(
          (d - d_min) / (d_max - d_min),
          SCATTERING_TEXTURE_MU_SIZE / 2
        );
  }
  float d = DistanceToTopAtmosphereBoundary(u_bottom_radius, mu_s);
  float d_min = u_top_radius - u_bottom_radius;
  float d_max = H;
  float a = (d - d_min) / (d_max - d_min);
  float D = DistanceToTopAtmosphereBoundary(u_bottom_radius, u_mu_s_min);
  float A = (D - d_min) / (d_max - d_min);
  float u_mu_s = GetTextureCoordFromUnitRange(
    max(1.0 - a / A, 0.0) / (1.0 + a),
    SCATTERING_TEXTURE_MU_S_SIZE
  );
  float u_nu = (nu + 1.0) / 2.0;
  return vec4(u_nu, u_mu_s, u_mu, u_r);
}

vec2 GetIrradianceTextureUvFromRMuS(float r, float mu_s) {
  float x_r = (r - u_bottom_radius) / (u_top_radius - u_bottom_radius);
  float x_mu_s = mu_s * 0.5 + 0.5;
  return vec2(
    GetTextureCoordFromUnitRange(x_mu_s, IRRADIANCE_TEXTURE_WIDTH),
    GetTextureCoordFromUnitRange(x_r, IRRADIANCE_TEXTURE_HEIGHT)
  );
}

const vec2 IRRADIANCE_TEXTURE_SIZE = vec2(
  IRRADIANCE_TEXTURE_WIDTH,
  IRRADIANCE_TEXTURE_HEIGHT
);

vec3 GetIrradiance(const sampler2D u_irradiance_texture, float r, float mu_s) {
  vec2 uv = GetIrradianceTextureUvFromRMuS(r, mu_s);
  return vec3(texture(u_irradiance_texture, uv));
}

vec3 GetExtrapolatedSingleMieScattering(const vec4 scattering) {
  if (scattering.r <= 0.0) {
    return vec3(0.0);
  }
  return scattering.rgb *
  scattering.a /
  scattering.r *
  (u_rayleigh_scattering.r / u_mie_scattering.r) *
  (u_mie_scattering / u_rayleigh_scattering);
}

vec3 GetCombinedScattering(
  const sampler3D u_scattering_texture,
  const sampler3D u_single_mie_scattering_texture,
  float r,
  float mu,
  float mu_s,
  float nu,
  bool ray_r_mu_intersects_ground,
  out vec3 single_mie_scattering
) {
  vec4 uvwz = GetScatteringTextureUvwzFromRMuMuSNu(
    r,
    mu,
    mu_s,
    nu,
    ray_r_mu_intersects_ground
  );
  float tex_coord_x = uvwz.x * float(SCATTERING_TEXTURE_NU_SIZE - 1);
  float tex_x = floor(tex_coord_x);
  float lerp = tex_coord_x - tex_x;
  vec3 uvw0 = vec3(
    (tex_x + uvwz.y) / float(SCATTERING_TEXTURE_NU_SIZE),
    uvwz.z,
    uvwz.w
  );
  vec3 uvw1 = vec3(
    (tex_x + 1.0 + uvwz.y) / float(SCATTERING_TEXTURE_NU_SIZE),
    uvwz.z,
    uvwz.w
  );
  vec4 combined_scattering =
    texture(u_scattering_texture, uvw0) * (1.0 - lerp) +
    texture(u_scattering_texture, uvw1) * lerp;
  vec3 scattering = vec3(combined_scattering);
  single_mie_scattering = GetExtrapolatedSingleMieScattering(
    combined_scattering
  );
  return scattering;
}

vec3 GetSkyRadiance(
  const sampler2D u_transmittance_texture,
  const sampler3D u_scattering_texture,
  const sampler3D u_single_mie_scattering_texture,
  vec3 camera,
  const vec3 view_ray,
  float shadow_length,
  const vec3 sun_direction,
  out vec3 transmittance
) {
  float r = length(camera);
  float rmu = dot(camera, view_ray);
  float distance_to_top_atmosphere_boundary =
    -rmu - SafeSqrt(rmu * rmu - r * r + u_top_radius * u_top_radius);
  if (distance_to_top_atmosphere_boundary > 0.0) {
    camera = camera + view_ray * distance_to_top_atmosphere_boundary;
    r = u_top_radius;
    rmu += distance_to_top_atmosphere_boundary;
  } else if (r > u_top_radius) {
    transmittance = vec3(1.0);
    return vec3(0.0);
  }
  float mu = rmu / r;
  float mu_s = dot(camera, sun_direction) / r;
  float nu = dot(view_ray, sun_direction);
  bool ray_r_mu_intersects_ground = RayIntersectsGround(r, mu);
  transmittance = ray_r_mu_intersects_ground
    ? vec3(0.0)
    : GetTransmittanceToTopAtmosphereBoundary(u_transmittance_texture, r, mu);
  vec3 single_mie_scattering;
  vec3 scattering;
  if (shadow_length == 0.0) {
    scattering = GetCombinedScattering(
      u_scattering_texture,
      u_single_mie_scattering_texture,
      r,
      mu,
      mu_s,
      nu,
      ray_r_mu_intersects_ground,
      single_mie_scattering
    );
  } else {
    float d = shadow_length;
    float r_p = ClampRadius(sqrt(d * d + 2.0 * r * mu * d + r * r));
    float mu_p = (r * mu + d) / r_p;
    float mu_s_p = (r * mu_s + d * nu) / r_p;
    scattering = GetCombinedScattering(
      u_scattering_texture,
      u_single_mie_scattering_texture,
      r_p,
      mu_p,
      mu_s_p,
      nu,
      ray_r_mu_intersects_ground,
      single_mie_scattering
    );
    vec3 shadow_transmittance = GetTransmittance(
      u_transmittance_texture,
      r,
      mu,
      shadow_length,
      ray_r_mu_intersects_ground
    );
    scattering = scattering * shadow_transmittance;
    single_mie_scattering = single_mie_scattering * shadow_transmittance;
  }
  return scattering * RayleighPhaseFunction(nu) +
  single_mie_scattering * MiePhaseFunction(u_mie_phase_function_g, nu);
}

vec3 GetSkyRadianceToPoint(
  const sampler2D u_transmittance_texture,
  const sampler3D u_scattering_texture,
  const sampler3D u_single_mie_scattering_texture,
  vec3 camera,
  const vec3 point,
  float shadow_length,
  const vec3 sun_direction,
  out vec3 transmittance
) {
  vec3 view_ray = normalize(point - camera);
  float r = length(camera);
  float rmu = dot(camera, view_ray);
  float distance_to_top_atmosphere_boundary =
    -rmu - sqrt(rmu * rmu - r * r + u_top_radius * u_top_radius);
  if (distance_to_top_atmosphere_boundary > 0.0) {
    camera = camera + view_ray * distance_to_top_atmosphere_boundary;
    r = u_top_radius;
    rmu += distance_to_top_atmosphere_boundary;
  }
  float mu = rmu / r;
  float mu_s = dot(camera, sun_direction) / r;
  float nu = dot(view_ray, sun_direction);
  float d = length(point - camera);
  bool ray_r_mu_intersects_ground = RayIntersectsGround(r, mu);

  
  
  
  if (!ray_r_mu_intersects_ground) {
    float mu_horiz = -SafeSqrt(
      1.0 - u_bottom_radius / r * (u_bottom_radius / r)
    );
    mu = max(mu, mu_horiz + 0.004);
  }

  transmittance = GetTransmittance(
    u_transmittance_texture,
    r,
    mu,
    d,
    ray_r_mu_intersects_ground
  );
  vec3 single_mie_scattering;
  vec3 scattering = GetCombinedScattering(
    u_scattering_texture,
    u_single_mie_scattering_texture,
    r,
    mu,
    mu_s,
    nu,
    ray_r_mu_intersects_ground,
    single_mie_scattering
  );
  d = max(d - shadow_length, 0.0);
  float r_p = ClampRadius(sqrt(d * d + 2.0 * r * mu * d + r * r));
  float mu_p = (r * mu + d) / r_p;
  float mu_s_p = (r * mu_s + d * nu) / r_p;
  vec3 single_mie_scattering_p;
  vec3 scattering_p = GetCombinedScattering(
    u_scattering_texture,
    u_single_mie_scattering_texture,
    r_p,
    mu_p,
    mu_s_p,
    nu,
    ray_r_mu_intersects_ground,
    single_mie_scattering_p
  );
  vec3 shadow_transmittance = transmittance;
  if (shadow_length > 0.0) {
    shadow_transmittance = GetTransmittance(
      u_transmittance_texture,
      r,
      mu,
      d,
      ray_r_mu_intersects_ground
    );
  }
  scattering = scattering - shadow_transmittance * scattering_p;
  single_mie_scattering =
    single_mie_scattering - shadow_transmittance * single_mie_scattering_p;
  single_mie_scattering = GetExtrapolatedSingleMieScattering(
    vec4(scattering, single_mie_scattering.r)
  );
  single_mie_scattering =
    single_mie_scattering * smoothstep(float(0.0), float(0.01), mu_s);
  return scattering * RayleighPhaseFunction(nu) +
  single_mie_scattering * MiePhaseFunction(u_mie_phase_function_g, nu);
}

vec3 GetSunAndSkyIrradiance(
  const sampler2D u_transmittance_texture,
  const sampler2D u_irradiance_texture,
  const vec3 point,
  const vec3 normal,
  const vec3 sun_direction,
  out vec3 sky_irradiance
) {
  float r = length(point);
  float mu_s = dot(point, sun_direction) / r;
  sky_irradiance =
    GetIrradiance(u_irradiance_texture, r, mu_s) *
    (1.0 + dot(normal, point) / r) *
    0.5;
  return u_solar_irradiance *
  GetTransmittanceToSun(u_transmittance_texture, r, mu_s) *
  max(dot(normal, sun_direction), 0.0);
}

vec3 GetSolarRadiance() {
  vec3 radiance =
    u_solar_irradiance / (PI * u_sun_angular_radius * u_sun_angular_radius);
  #ifdef PHOTOMETRIC
  radiance *= SUN_SPECTRAL_RADIANCE_TO_LUMINANCE;
  #endif 
  return radiance;
}

vec3 GetSkyRadiance(
  vec3 camera,
  vec3 view_ray,
  float shadow_length,
  vec3 sun_direction,
  out vec3 transmittance
) {
  vec3 radiance = GetSkyRadiance(
    u_transmittance_texture,
    u_scattering_texture,
    u_single_mie_scattering_texture,
    camera,
    view_ray,
    shadow_length,
    sun_direction,
    transmittance
  );
  #ifdef PHOTOMETRIC
  radiance *= SKY_SPECTRAL_RADIANCE_TO_LUMINANCE;
  #endif 
  return radiance;
}

vec3 GetSkyRadianceToPoint(
  vec3 camera,
  vec3 point,
  float shadow_length,
  vec3 sun_direction,
  out vec3 transmittance
) {
  vec3 inscatter = GetSkyRadianceToPoint(
    u_transmittance_texture,
    u_scattering_texture,
    u_single_mie_scattering_texture,
    camera,
    point,
    shadow_length,
    sun_direction,
    transmittance
  );
  #ifdef PHOTOMETRIC
  inscatter *= SKY_SPECTRAL_RADIANCE_TO_LUMINANCE;
  #endif 
  return inscatter;
}

vec3 GetSunAndSkyIrradiance(
  vec3 p,
  vec3 normal,
  vec3 sun_direction,
  out vec3 sky_irradiance
) {
  vec3 sun_irradiance = GetSunAndSkyIrradiance(
    u_transmittance_texture,
    u_irradiance_texture,
    p,
    normal,
    sun_direction,
    sky_irradiance
  );
  #ifdef PHOTOMETRIC
  sun_irradiance *= SUN_SPECTRAL_RADIANCE_TO_LUMINANCE;
  sky_irradiance *= SKY_SPECTRAL_RADIANCE_TO_LUMINANCE;
  #endif 
  return sun_irradiance;
}`, i0 = `uniform vec3 u_solar_irradiance;
uniform float u_sun_angular_radius;
uniform float u_bottom_radius;
uniform float u_top_radius;
uniform vec3 u_rayleigh_scattering;
uniform vec3 u_mie_scattering;
uniform float u_mie_phase_function_g;
uniform float u_mu_s_min;

uniform sampler2D u_transmittance_texture;
uniform sampler3D u_scattering_texture;
uniform sampler3D u_single_mie_scattering_texture;
uniform sampler2D u_irradiance_texture;`, bn = `vec3 getLunarRadiance(const float moonAngularRadius) {
  
  vec3 radiance =
    u_solar_irradiance *
    0.000002 /
    (PI * moonAngularRadius * moonAngularRadius);
  #ifdef PHOTOMETRIC
  radiance *= SUN_SPECTRAL_RADIANCE_TO_LUMINANCE;
  #endif 
  return radiance;
}

float intersectSphere(const vec3 ray, const vec3 point, const float radius) {
  vec3 P = -point;
  float PoR = dot(P, ray);
  float D = dot(P, P) - radius * radius;
  return -PoR - sqrt(PoR * PoR - D);
}

float orenNayarDiffuse(const vec3 L, const vec3 V, const vec3 N) {
  float NoL = dot(N, L);
  float NoV = dot(N, V);
  float s = dot(L, V) - NoL * NoV;
  float t = mix(1.0, max(NoL, NoV), step(0.0, s));
  return max(0.0, NoL) * (0.62406015 + 0.41284404 * s / t);
}

vec3 getSkyRadiance(
  const vec3 viewPosition,
  const vec3 rayDirection,
  const vec3 sunDirection,
  const vec3 moonDirection,
  const float moonAngularRadius,
  const float lunarRadianceScale
) {
  vec3 transmittance;
  vec3 radiance = GetSkyRadiance(
    viewPosition,
    rayDirection,
    0.0, 
    sunDirection,
    transmittance
  );

  
  #ifdef PERSPECTIVE_CAMERA

  #if defined(SUN) || defined(MOON)
  vec3 ddx = dFdx(rayDirection);
  vec3 ddy = dFdy(rayDirection);
  float fragmentAngle = length(ddx + ddy) / length(rayDirection);
  #endif 

  #ifdef SUN
  float viewDotSun = dot(rayDirection, sunDirection);
  if (viewDotSun > cos(u_sun_angular_radius)) {
    float angle = acos(clamp(viewDotSun, -1.0, 1.0));
    float antialias = smoothstep(
      u_sun_angular_radius,
      u_sun_angular_radius - fragmentAngle,
      angle
    );
    radiance += transmittance * GetSolarRadiance() * antialias;
  }
  #endif 

  #ifdef MOON
  float intersection = intersectSphere(
    rayDirection,
    moonDirection,
    moonAngularRadius
  );
  if (intersection > 0.0) {
    vec3 normal = normalize(moonDirection - rayDirection * intersection);
    float diffuse = orenNayarDiffuse(-sunDirection, rayDirection, normal);
    float viewDotMoon = dot(rayDirection, moonDirection);
    float angle = acos(clamp(viewDotMoon, -1.0, 1.0));
    float antialias = smoothstep(
      moonAngularRadius,
      moonAngularRadius - fragmentAngle,
      angle
    );
    radiance +=
      transmittance *
      getLunarRadiance(moonAngularRadius) *
      lunarRadianceScale *
      diffuse *
      antialias;
  }
  #endif 

  #endif 

  return radiance;
}`;
const $0 = /* @__PURE__ */ new p(), wt = /* @__PURE__ */ new ht(), At = {
  blendFunction: Qn.NORMAL,
  octEncodedNormal: !1,
  reconstructNormal: !1,
  ellipsoid: _0.WGS84,
  correctAltitude: !0,
  correctGeometricError: !0,
  photometric: !0,
  sunIrradiance: !1,
  skyIrradiance: !1,
  transmittance: !0,
  inscatter: !0,
  irradianceScale: 1,
  sky: !1,
  sun: !0,
  moon: !0,
  moonAngularRadius: 45e-4,
  // â‰ˆ 15.5 arcminutes
  lunarRadianceScale: 1
};
class qe extends nt {
  constructor(t = new et(), r, i = X.DEFAULT) {
    const {
      blendFunction: o,
      normalBuffer: s = null,
      octEncodedNormal: c,
      reconstructNormal: a,
      irradianceTexture: l = null,
      scatteringTexture: d = null,
      transmittanceTexture: _ = null,
      useHalfFloat: f,
      ellipsoid: T,
      correctAltitude: h,
      correctGeometricError: v,
      photometric: x,
      sunDirection: y,
      sunIrradiance: N,
      skyIrradiance: D,
      transmittance: P,
      inscatter: O,
      irradianceScale: L,
      sky: b,
      sun: f0,
      moon: s0,
      moonDirection: Y,
      moonAngularRadius: h0,
      lunarRadianceScale: c0
    } = { ...At, ...r };
    super(
      "AerialPerspectiveEffect",
      /* glsl */
      `
        ${i0}
        ${_n}
        ${_t}
        ${mt}
        ${ft}
        ${bn}
        ${St}
      `,
      {
        blendFunction: o,
        vertexShader: (
          /* glsl */
          `
          ${i0}
          ${xt}
        `
        ),
        attributes: tt.DEPTH,
        // prettier-ignore
        uniforms: /* @__PURE__ */ new Map([
          ["u_solar_irradiance", new m(i.solarIrradiance)],
          ["u_sun_angular_radius", new m(i.sunAngularRadius)],
          ["u_bottom_radius", new m(i.bottomRadius * e0)],
          ["u_top_radius", new m(i.topRadius * e0)],
          ["u_rayleigh_scattering", new m(i.rayleighScattering)],
          ["u_mie_scattering", new m(i.mieScattering)],
          ["u_mie_phase_function_g", new m(i.miePhaseFunctionG)],
          ["u_mu_s_min", new m(0)],
          ["u_irradiance_texture", new m(l)],
          ["u_scattering_texture", new m(d)],
          ["u_single_mie_scattering_texture", new m(d)],
          ["u_transmittance_texture", new m(_)],
          ["normalBuffer", new m(s)],
          ["projectionMatrix", new m(new U())],
          ["inverseProjectionMatrix", new m(new U())],
          ["inverseViewMatrix", new m(new U())],
          ["cameraPosition", new m(new p())],
          ["cameraHeight", new m(0)],
          ["ellipsoidCenter", new m(new p())],
          ["ellipsoidRadii", new m(new p())],
          ["sunDirection", new m((y == null ? void 0 : y.clone()) ?? new p())],
          ["irradianceScale", new m(L)],
          ["idealSphereAlpha", new m(0)],
          ["moonDirection", new m((Y == null ? void 0 : Y.clone()) ?? new p())],
          ["moonAngularRadius", new m(h0)],
          ["lunarRadianceScale", new m(c0)]
        ]),
        // prettier-ignore
        defines: /* @__PURE__ */ new Map([
          ["TRANSMITTANCE_TEXTURE_WIDTH", `${U0}`],
          ["TRANSMITTANCE_TEXTURE_HEIGHT", `${G0}`],
          ["SCATTERING_TEXTURE_R_SIZE", `${cn}`],
          ["SCATTERING_TEXTURE_MU_SIZE", `${un}`],
          ["SCATTERING_TEXTURE_MU_S_SIZE", `${ln}`],
          ["SCATTERING_TEXTURE_NU_SIZE", `${dn}`],
          ["IRRADIANCE_TEXTURE_WIDTH", `${D0}`],
          ["IRRADIANCE_TEXTURE_HEIGHT", `${P0}`],
          ["METER_TO_UNIT_LENGTH", `float(${e0})`],
          ["SUN_SPECTRAL_RADIANCE_TO_LUMINANCE", `vec3(${i.sunRadianceToRelativeLuminance.toArray().join(",")})`],
          ["SKY_SPECTRAL_RADIANCE_TO_LUMINANCE", `vec3(${i.skyRadianceToRelativeLuminance.toArray().join(",")})`]
        ])
      }
    );
    g(this, "atmosphere");
    g(this, "_ellipsoid");
    g(this, "correctAltitude");
    this.camera = t, this.camera = t, this.atmosphere = i, this.octEncodedNormal = c, this.reconstructNormal = a, this.useHalfFloat = f === !0, this.ellipsoid = T, this.correctAltitude = h, this.correctGeometricError = v, this.photometric = x, this.sunIrradiance = N, this.skyIrradiance = D, this.transmittance = P, this.inscatter = O, this.sky = b, this.sun = f0, this.moon = s0;
  }
  get mainCamera() {
    return this.camera;
  }
  set mainCamera(t) {
    this.camera = t;
  }
  update(t, r, i) {
    const o = this.uniforms, s = o.get("projectionMatrix"), c = o.get("inverseProjectionMatrix"), a = o.get("inverseViewMatrix"), l = this.camera;
    s.value.copy(l.projectionMatrix), c.value.copy(l.projectionMatrixInverse), a.value.copy(l.matrixWorld);
    const d = o.get("cameraPosition"), _ = o.get("cameraHeight"), f = l.getWorldPosition(d.value);
    _.value = wt.setFromECEF(f).height;
    const T = o.get("idealSphereAlpha");
    $0.set(0, this.ellipsoid.maximumRadius, -_.value).applyMatrix4(l.projectionMatrix);
    let h = En.mapLinear($0.y, 41.5, 13.8, 0, 1);
    h = En.clamp(h, 0, 1), T.value = h;
    const v = o.get("ellipsoidCenter");
    if (this.correctAltitude) {
      const x = this.ellipsoid.projectOnSurface(
        f,
        $0
      );
      x != null && this.ellipsoid.getOsculatingSphereCenter(
        // Move the center of the atmosphere's inner sphere down to intersect
        // the viewpoint when it's located underground.
        x.lengthSq() < f.lengthSq() ? x : f,
        this.atmosphere.bottomRadius,
        v.value
      );
    } else
      v.value.set(0, 0, 0);
  }
  get normalBuffer() {
    return this.uniforms.get("normalBuffer").value;
  }
  set normalBuffer(t) {
    this.uniforms.get("normalBuffer").value = t;
  }
  get octEncodedNormal() {
    return this.defines.has("OCT_ENCODED_NORMAL");
  }
  set octEncodedNormal(t) {
    t !== this.octEncodedNormal && (t ? this.defines.set("OCT_ENCODED_NORMAL", "1") : this.defines.delete("OCT_ENCODED_NORMAL"), this.setChanged());
  }
  get reconstructNormal() {
    return this.defines.has("RECONSTRUCT_NORMAL");
  }
  set reconstructNormal(t) {
    t !== this.reconstructNormal && (t ? this.defines.set("RECONSTRUCT_NORMAL", "1") : this.defines.delete("RECONSTRUCT_NORMAL"), this.setChanged());
  }
  get irradianceTexture() {
    return this.uniforms.get("u_irradiance_texture").value;
  }
  set irradianceTexture(t) {
    this.uniforms.get("u_irradiance_texture").value = t;
  }
  get scatteringTexture() {
    return this.uniforms.get("u_scattering_texture").value;
  }
  set scatteringTexture(t) {
    this.uniforms.get("u_scattering_texture").value = t, this.uniforms.get("u_single_mie_scattering_texture").value = t;
  }
  get transmittanceTexture() {
    return this.uniforms.get("u_transmittance_texture").value;
  }
  set transmittanceTexture(t) {
    this.uniforms.get("u_transmittance_texture").value = t;
  }
  get useHalfFloat() {
    return this.uniforms.get("u_mu_s_min").value === this.atmosphere.muSMinHalfFloat;
  }
  set useHalfFloat(t) {
    this.uniforms.get("u_mu_s_min").value = t ? this.atmosphere.muSMinHalfFloat : this.atmosphere.muSMinFloat;
  }
  get ellipsoid() {
    return this._ellipsoid;
  }
  set ellipsoid(t) {
    this._ellipsoid = t, this.uniforms.get("ellipsoidRadii").value.copy(t.radii);
  }
  get correctGeometricError() {
    return this.defines.has("CORRECT_GEOMETRIC_ERROR");
  }
  set correctGeometricError(t) {
    t !== this.correctGeometricError && (t ? this.defines.set("CORRECT_GEOMETRIC_ERROR", "1") : this.defines.delete("CORRECT_GEOMETRIC_ERROR"), this.setChanged());
  }
  get photometric() {
    return this.defines.has("PHOTOMETRIC");
  }
  set photometric(t) {
    t !== this.photometric && (t ? this.defines.set("PHOTOMETRIC", "1") : this.defines.delete("PHOTOMETRIC"), this.setChanged());
  }
  get sunDirection() {
    return this.uniforms.get("sunDirection").value;
  }
  get sunIrradiance() {
    return this.defines.has("SUN_IRRADIANCE");
  }
  set sunIrradiance(t) {
    t !== this.sunIrradiance && (t ? this.defines.set("SUN_IRRADIANCE", "1") : this.defines.delete("SUN_IRRADIANCE"), this.setChanged());
  }
  get skyIrradiance() {
    return this.defines.has("SKY_IRRADIANCE");
  }
  set skyIrradiance(t) {
    t !== this.skyIrradiance && (t ? this.defines.set("SKY_IRRADIANCE", "1") : this.defines.delete("SKY_IRRADIANCE"), this.setChanged());
  }
  get transmittance() {
    return this.defines.has("TRANSMITTANCE");
  }
  set transmittance(t) {
    t !== this.transmittance && (t ? this.defines.set("TRANSMITTANCE", "1") : this.defines.delete("TRANSMITTANCE"), this.setChanged());
  }
  get inscatter() {
    return this.defines.has("INSCATTER");
  }
  set inscatter(t) {
    t !== this.inscatter && (t ? this.defines.set("INSCATTER", "1") : this.defines.delete("INSCATTER"), this.setChanged());
  }
  get irradianceScale() {
    return this.uniforms.get("irradianceScale").value;
  }
  set irradianceScale(t) {
    this.uniforms.get("irradianceScale").value = t;
  }
  get sky() {
    return this.defines.has("SKY");
  }
  set sky(t) {
    t !== this.sky && (t ? this.defines.set("SKY", "1") : this.defines.delete("SKY"), this.setChanged());
  }
  get sun() {
    return this.defines.has("SUN");
  }
  set sun(t) {
    t !== this.sun && (t ? this.defines.set("SUN", "1") : this.defines.delete("SUN"), this.setChanged());
  }
  get moon() {
    return this.defines.has("MOON");
  }
  set moon(t) {
    t !== this.moon && (t ? this.defines.set("MOON", "1") : this.defines.delete("MOON"), this.setChanged());
  }
  get moonDirection() {
    return this.uniforms.get("moonDirection").value;
  }
  get moonAngularRadius() {
    return this.uniforms.get("moonAngularRadius").value;
  }
  set moonAngularRadius(t) {
    this.uniforms.get("moonAngularRadius").value = t;
  }
  get lunarRadianceScale() {
    return this.uniforms.get("lunarRadianceScale").value;
  }
  set lunarRadianceScale(t) {
    this.uniforms.get("lunarRadianceScale").value = t;
  }
}
const yt = /* @__PURE__ */ new p();
function Ct(e, n) {
  let t = "", r = "";
  for (let i = 1; i < n; ++i)
    t += `layout(location = ${i}) out float renderTarget${i};
`, r += `renderTarget${i} = 0.0;
`;
  return e.replace("#include <mrt_layout>", t).replace("#include <mrt_output>", r);
}
const mn = {
  useHalfFloat: !1,
  ellipsoid: _0.WGS84,
  correctAltitude: !0,
  photometric: !0,
  renderTargetCount: 1
};
class zn extends rt {
  constructor(t, r = X.DEFAULT) {
    const {
      irradianceTexture: i = null,
      scatteringTexture: o = null,
      transmittanceTexture: s = null,
      useHalfFloat: c,
      ellipsoid: a,
      correctAltitude: l,
      photometric: d,
      sunDirection: _,
      sunAngularRadius: f,
      renderTargetCount: T,
      ...h
    } = { ...mn, ...t };
    super({
      toneMapped: !1,
      depthWrite: !1,
      depthTest: !1,
      ...h,
      // prettier-ignore
      uniforms: {
        u_solar_irradiance: new m(r.solarIrradiance),
        u_sun_angular_radius: new m(f ?? r.sunAngularRadius),
        u_bottom_radius: new m(r.bottomRadius * e0),
        u_top_radius: new m(r.topRadius * e0),
        u_rayleigh_scattering: new m(r.rayleighScattering),
        u_mie_scattering: new m(r.mieScattering),
        u_mie_phase_function_g: new m(r.miePhaseFunctionG),
        u_mu_s_min: new m(0),
        u_irradiance_texture: new m(i),
        u_scattering_texture: new m(o),
        u_single_mie_scattering_texture: new m(o),
        u_transmittance_texture: new m(s),
        cameraPosition: new m(new p()),
        ellipsoidCenter: new m(new p()),
        sunDirection: new m((_ == null ? void 0 : _.clone()) ?? new p()),
        ...h.uniforms
      },
      // prettier-ignore
      defines: {
        PI: `${Math.PI}`,
        TRANSMITTANCE_TEXTURE_WIDTH: `${U0}`,
        TRANSMITTANCE_TEXTURE_HEIGHT: `${G0}`,
        SCATTERING_TEXTURE_R_SIZE: `${cn}`,
        SCATTERING_TEXTURE_MU_SIZE: `${un}`,
        SCATTERING_TEXTURE_MU_S_SIZE: `${ln}`,
        SCATTERING_TEXTURE_NU_SIZE: `${dn}`,
        IRRADIANCE_TEXTURE_WIDTH: `${D0}`,
        IRRADIANCE_TEXTURE_HEIGHT: `${P0}`,
        METER_TO_UNIT_LENGTH: `float(${e0})`,
        SUN_SPECTRAL_RADIANCE_TO_LUMINANCE: `vec3(${r.sunRadianceToRelativeLuminance.toArray().join(",")})`,
        SKY_SPECTRAL_RADIANCE_TO_LUMINANCE: `vec3(${r.skyRadianceToRelativeLuminance.toArray().join(",")})`,
        ...h.defines
      }
    });
    g(this, "atmosphere");
    g(this, "ellipsoid");
    g(this, "correctAltitude");
    g(this, "_renderTargetCount");
    this.atmosphere = r, this.useHalfFloat = c, this.ellipsoid = a, this.correctAltitude = l, this.photometric = d, this.renderTargetCount = T;
  }
  onBeforeCompile(t, r) {
    t.fragmentShader = Ct(
      t.fragmentShader,
      this.renderTargetCount
    );
  }
  onBeforeRender(t, r, i, o, s, c) {
    const a = this.uniforms, l = i.getWorldPosition(a.cameraPosition.value);
    if (this.correctAltitude) {
      const d = this.ellipsoid.projectOnSurface(
        l,
        yt
      );
      d != null && this.ellipsoid.getOsculatingSphereCenter(
        // Move the center of the atmosphere's inner sphere down to intersect
        // the viewpoint when it's located underground.
        d.lengthSq() < l.lengthSq() ? d : l,
        this.atmosphere.bottomRadius,
        a.ellipsoidCenter.value
      );
    } else
      a.ellipsoidCenter.value.set(0, 0, 0);
  }
  get irradianceTexture() {
    return this.uniforms.u_irradiance_texture.value;
  }
  set irradianceTexture(t) {
    this.uniforms.u_irradiance_texture.value = t;
  }
  get scatteringTexture() {
    return this.uniforms.u_scattering_texture.value;
  }
  set scatteringTexture(t) {
    this.uniforms.u_scattering_texture.value = t, this.uniforms.u_single_mie_scattering_texture.value = t;
  }
  get transmittanceTexture() {
    return this.uniforms.u_transmittance_texture.value;
  }
  set transmittanceTexture(t) {
    this.uniforms.u_transmittance_texture.value = t;
  }
  get useHalfFloat() {
    return this.uniforms.u_mu_s_min.value === this.atmosphere.muSMinHalfFloat;
  }
  set useHalfFloat(t) {
    this.uniforms.u_mu_s_min.value = t ? this.atmosphere.muSMinHalfFloat : this.atmosphere.muSMinFloat;
  }
  get photometric() {
    return this.defines.PHOTOMETRIC != null;
  }
  set photometric(t) {
    t !== this.photometric && (t ? this.defines.PHOTOMETRIC = "1" : delete this.defines.PHOTOMETRIC, this.needsUpdate = !0);
  }
  get sunDirection() {
    return this.uniforms.sunDirection.value;
  }
  get sunAngularRadius() {
    return this.uniforms.u_sun_angular_radius.value;
  }
  set sunAngularRadius(t) {
    this.uniforms.u_sun_angular_radius.value = t;
  }
  get renderTargetCount() {
    return this._renderTargetCount;
  }
  set renderTargetCount(t) {
    t !== this.renderTargetCount && (this._renderTargetCount = t, this.needsUpdate = !0);
  }
}
/**
    @preserve

    Astronomy library for JavaScript (browser and Node.js).
    https://github.com/cosinekitty/astronomy

    MIT License

    Copyright (c) 2019-2023 Don Cross <cosinekitty@gmail.com>

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/
/**
 * @fileoverview Astronomy calculation library for browser scripting and Node.js.
 * @author Don Cross <cosinekitty@gmail.com>
 * @license MIT
 */
const Mt = 173.1446326846693, It = 14959787069098932e-8, o0 = 0.017453292519943295, Nt = 365.24217, yn = /* @__PURE__ */ new Date("2000-01-01T12:00:00Z"), H = 2 * Math.PI, W = 3600 * (180 / Math.PI), Q = 484813681109536e-20, Dt = 180 * 60 * 60, Pt = 2 * Dt, Ut = 6378.1366, Gt = Ut / It, Ot = 81.30056, fn = 2959122082855911e-19, B0 = 2825345909524226e-22, Z0 = 8459715185680659e-23, Y0 = 1292024916781969e-23, K0 = 1524358900784276e-23;
function V0(e) {
  if (!Number.isFinite(e))
    throw console.trace(), `Value is not a finite number: ${e}`;
  return e;
}
function J(e) {
  return e - Math.floor(e);
}
var E;
(function(e) {
  e.Sun = "Sun", e.Moon = "Moon", e.Mercury = "Mercury", e.Venus = "Venus", e.Earth = "Earth", e.Mars = "Mars", e.Jupiter = "Jupiter", e.Saturn = "Saturn", e.Uranus = "Uranus", e.Neptune = "Neptune", e.Pluto = "Pluto", e.SSB = "SSB", e.EMB = "EMB", e.Star1 = "Star1", e.Star2 = "Star2", e.Star3 = "Star3", e.Star4 = "Star4", e.Star5 = "Star5", e.Star6 = "Star6", e.Star7 = "Star7", e.Star8 = "Star8";
})(E || (E = {}));
const bt = [
  E.Star1,
  E.Star2,
  E.Star3,
  E.Star4,
  E.Star5,
  E.Star6,
  E.Star7,
  E.Star8
], zt = [
  { ra: 0, dec: 0, dist: 0 },
  { ra: 0, dec: 0, dist: 0 },
  { ra: 0, dec: 0, dist: 0 },
  { ra: 0, dec: 0, dist: 0 },
  { ra: 0, dec: 0, dist: 0 },
  { ra: 0, dec: 0, dist: 0 },
  { ra: 0, dec: 0, dist: 0 },
  { ra: 0, dec: 0, dist: 0 }
];
function Lt(e) {
  const n = bt.indexOf(e);
  return n >= 0 ? zt[n] : null;
}
function Ln(e) {
  const n = Lt(e);
  return n && n.dist > 0 ? n : null;
}
var $;
(function(e) {
  e[e.From2000 = 0] = "From2000", e[e.Into2000 = 1] = "Into2000";
})($ || ($ = {}));
const n0 = {
  Mercury: [
    [
      [
        [4.40250710144, 0, 0],
        [0.40989414977, 1.48302034195, 26087.9031415742],
        [0.050462942, 4.47785489551, 52175.8062831484],
        [0.00855346844, 1.16520322459, 78263.70942472259],
        [0.00165590362, 4.11969163423, 104351.61256629678],
        [34561897e-11, 0.77930768443, 130439.51570787099],
        [7583476e-11, 3.71348404924, 156527.41884944518]
      ],
      [
        [26087.90313685529, 0, 0],
        [0.01131199811, 6.21874197797, 26087.9031415742],
        [0.00292242298, 3.04449355541, 52175.8062831484],
        [75775081e-11, 6.08568821653, 78263.70942472259],
        [19676525e-11, 2.80965111777, 104351.61256629678]
      ]
    ],
    [
      [
        [0.11737528961, 1.98357498767, 26087.9031415742],
        [0.02388076996, 5.03738959686, 52175.8062831484],
        [0.01222839532, 3.14159265359, 0],
        [0.0054325181, 1.79644363964, 78263.70942472259],
        [0.0012977877, 4.83232503958, 104351.61256629678],
        [31866927e-11, 1.58088495658, 130439.51570787099],
        [7963301e-11, 4.60972126127, 156527.41884944518]
      ],
      [
        [0.00274646065, 3.95008450011, 26087.9031415742],
        [99737713e-11, 3.14159265359, 0]
      ]
    ],
    [
      [
        [0.39528271651, 0, 0],
        [0.07834131818, 6.19233722598, 26087.9031415742],
        [0.00795525558, 2.95989690104, 52175.8062831484],
        [0.00121281764, 6.01064153797, 78263.70942472259],
        [21921969e-11, 2.77820093972, 104351.61256629678],
        [4354065e-11, 5.82894543774, 130439.51570787099]
      ],
      [
        [0.0021734774, 4.65617158665, 26087.9031415742],
        [44141826e-11, 1.42385544001, 52175.8062831484]
      ]
    ]
  ],
  Venus: [
    [
      [
        [3.17614666774, 0, 0],
        [0.01353968419, 5.59313319619, 10213.285546211],
        [89891645e-11, 5.30650047764, 20426.571092422],
        [5477194e-11, 4.41630661466, 7860.4193924392],
        [3455741e-11, 2.6996444782, 11790.6290886588],
        [2372061e-11, 2.99377542079, 3930.2096962196],
        [1317168e-11, 5.18668228402, 26.2983197998],
        [1664146e-11, 4.25018630147, 1577.3435424478],
        [1438387e-11, 4.15745084182, 9683.5945811164],
        [1200521e-11, 6.15357116043, 30639.856638633]
      ],
      [
        [10213.28554621638, 0, 0],
        [95617813e-11, 2.4640651111, 10213.285546211],
        [7787201e-11, 0.6247848222, 20426.571092422]
      ]
    ],
    [
      [
        [0.05923638472, 0.26702775812, 10213.285546211],
        [40107978e-11, 1.14737178112, 20426.571092422],
        [32814918e-11, 3.14159265359, 0]
      ],
      [
        [0.00287821243, 1.88964962838, 10213.285546211]
      ]
    ],
    [
      [
        [0.72334820891, 0, 0],
        [0.00489824182, 4.02151831717, 10213.285546211],
        [1658058e-11, 4.90206728031, 20426.571092422],
        [1378043e-11, 1.12846591367, 11790.6290886588],
        [1632096e-11, 2.84548795207, 7860.4193924392],
        [498395e-11, 2.58682193892, 9683.5945811164],
        [221985e-11, 2.01346696541, 19367.1891622328],
        [237454e-11, 2.55136053886, 15720.8387848784]
      ],
      [
        [34551041e-11, 0.89198706276, 10213.285546211]
      ]
    ]
  ],
  Earth: [
    [
      [
        [1.75347045673, 0, 0],
        [0.03341656453, 4.66925680415, 6283.0758499914],
        [34894275e-11, 4.62610242189, 12566.1516999828],
        [3417572e-11, 2.82886579754, 3.523118349],
        [3497056e-11, 2.74411783405, 5753.3848848968],
        [3135899e-11, 3.62767041756, 77713.7714681205],
        [2676218e-11, 4.41808345438, 7860.4193924392],
        [2342691e-11, 6.13516214446, 3930.2096962196],
        [1273165e-11, 2.03709657878, 529.6909650946],
        [1324294e-11, 0.74246341673, 11506.7697697936],
        [901854e-11, 2.04505446477, 26.2983197998],
        [1199167e-11, 1.10962946234, 1577.3435424478],
        [857223e-11, 3.50849152283, 398.1490034082],
        [779786e-11, 1.17882681962, 5223.6939198022],
        [99025e-10, 5.23268072088, 5884.9268465832],
        [753141e-11, 2.53339052847, 5507.5532386674],
        [505267e-11, 4.58292599973, 18849.2275499742],
        [492392e-11, 4.20505711826, 775.522611324],
        [356672e-11, 2.91954114478, 0.0673103028],
        [284125e-11, 1.89869240932, 796.2980068164],
        [242879e-11, 0.34481445893, 5486.777843175],
        [317087e-11, 5.84901948512, 11790.6290886588],
        [271112e-11, 0.31486255375, 10977.078804699],
        [206217e-11, 4.80646631478, 2544.3144198834],
        [205478e-11, 1.86953770281, 5573.1428014331],
        [202318e-11, 2.45767790232, 6069.7767545534],
        [126225e-11, 1.08295459501, 20.7753954924],
        [155516e-11, 0.83306084617, 213.299095438]
      ],
      [
        [6283.0758499914, 0, 0],
        [0.00206058863, 2.67823455808, 6283.0758499914],
        [4303419e-11, 2.63512233481, 12566.1516999828]
      ],
      [
        [8721859e-11, 1.07253635559, 6283.0758499914]
      ]
    ],
    [
      [],
      [
        [0.00227777722, 3.4137662053, 6283.0758499914],
        [3805678e-11, 3.37063423795, 12566.1516999828]
      ]
    ],
    [
      [
        [1.00013988784, 0, 0],
        [0.01670699632, 3.09846350258, 6283.0758499914],
        [13956024e-11, 3.05524609456, 12566.1516999828],
        [308372e-10, 5.19846674381, 77713.7714681205],
        [1628463e-11, 1.17387558054, 5753.3848848968],
        [1575572e-11, 2.84685214877, 7860.4193924392],
        [924799e-11, 5.45292236722, 11506.7697697936],
        [542439e-11, 4.56409151453, 3930.2096962196],
        [47211e-10, 3.66100022149, 5884.9268465832],
        [85831e-11, 1.27079125277, 161000.6857376741],
        [57056e-11, 2.01374292245, 83996.84731811189],
        [55736e-11, 5.2415979917, 71430.69561812909],
        [174844e-11, 3.01193636733, 18849.2275499742],
        [243181e-11, 4.2734953079, 11790.6290886588]
      ],
      [
        [0.00103018607, 1.10748968172, 6283.0758499914],
        [1721238e-11, 1.06442300386, 12566.1516999828]
      ],
      [
        [4359385e-11, 5.78455133808, 6283.0758499914]
      ]
    ]
  ],
  Mars: [
    [
      [
        [6.20347711581, 0, 0],
        [0.18656368093, 5.0503710027, 3340.6124266998],
        [0.01108216816, 5.40099836344, 6681.2248533996],
        [91798406e-11, 5.75478744667, 10021.8372800994],
        [27744987e-11, 5.97049513147, 3.523118349],
        [10610235e-11, 2.93958560338, 2281.2304965106],
        [12315897e-11, 0.84956094002, 2810.9214616052],
        [8926784e-11, 4.15697846427, 0.0172536522],
        [8715691e-11, 6.11005153139, 13362.4497067992],
        [6797556e-11, 0.36462229657, 398.1490034082],
        [7774872e-11, 3.33968761376, 5621.8429232104],
        [3575078e-11, 1.6618650571, 2544.3144198834],
        [4161108e-11, 0.22814971327, 2942.4634232916],
        [3075252e-11, 0.85696614132, 191.4482661116],
        [2628117e-11, 0.64806124465, 3337.0893083508],
        [2937546e-11, 6.07893711402, 0.0673103028],
        [2389414e-11, 5.03896442664, 796.2980068164],
        [2579844e-11, 0.02996736156, 3344.1355450488],
        [1528141e-11, 1.14979301996, 6151.533888305],
        [1798806e-11, 0.65634057445, 529.6909650946],
        [1264357e-11, 3.62275122593, 5092.1519581158],
        [1286228e-11, 3.06796065034, 2146.1654164752],
        [1546404e-11, 2.91579701718, 1751.539531416],
        [1024902e-11, 3.69334099279, 8962.4553499102],
        [891566e-11, 0.18293837498, 16703.062133499],
        [858759e-11, 2.4009381194, 2914.0142358238],
        [832715e-11, 2.46418619474, 3340.5951730476],
        [83272e-10, 4.49495782139, 3340.629680352],
        [712902e-11, 3.66335473479, 1059.3819301892],
        [748723e-11, 3.82248614017, 155.4203994342],
        [723861e-11, 0.67497311481, 3738.761430108],
        [635548e-11, 2.92182225127, 8432.7643848156],
        [655162e-11, 0.48864064125, 3127.3133312618],
        [550474e-11, 3.81001042328, 0.9803210682],
        [55275e-10, 4.47479317037, 1748.016413067],
        [425966e-11, 0.55364317304, 6283.0758499914],
        [415131e-11, 0.49662285038, 213.299095438],
        [472167e-11, 3.62547124025, 1194.4470102246],
        [306551e-11, 0.38052848348, 6684.7479717486],
        [312141e-11, 0.99853944405, 6677.7017350506],
        [293198e-11, 4.22131299634, 20.7753954924],
        [302375e-11, 4.48618007156, 3532.0606928114],
        [274027e-11, 0.54222167059, 3340.545116397],
        [281079e-11, 5.88163521788, 1349.8674096588],
        [231183e-11, 1.28242156993, 3870.3033917944],
        [283602e-11, 5.7688543494, 3149.1641605882],
        [236117e-11, 5.75503217933, 3333.498879699],
        [274033e-11, 0.13372524985, 3340.6797370026],
        [299395e-11, 2.78323740866, 6254.6266625236]
      ],
      [
        [3340.61242700512, 0, 0],
        [0.01457554523, 3.60433733236, 3340.6124266998],
        [0.00168414711, 3.92318567804, 6681.2248533996],
        [20622975e-11, 4.26108844583, 10021.8372800994],
        [3452392e-11, 4.7321039319, 3.523118349],
        [2586332e-11, 4.60670058555, 13362.4497067992],
        [841535e-11, 4.45864030426, 2281.2304965106]
      ],
      [
        [58152577e-11, 2.04961712429, 3340.6124266998],
        [13459579e-11, 2.45738706163, 6681.2248533996]
      ]
    ],
    [
      [
        [0.03197134986, 3.76832042431, 3340.6124266998],
        [0.00298033234, 4.10616996305, 6681.2248533996],
        [0.00289104742, 0, 0],
        [31365539e-11, 4.4465105309, 10021.8372800994],
        [34841e-9, 4.7881254926, 13362.4497067992]
      ],
      [
        [0.00217310991, 6.04472194776, 3340.6124266998],
        [20976948e-11, 3.14159265359, 0],
        [12834709e-11, 1.60810667915, 6681.2248533996]
      ]
    ],
    [
      [
        [1.53033488271, 0, 0],
        [0.1418495316, 3.47971283528, 3340.6124266998],
        [0.00660776362, 3.81783443019, 6681.2248533996],
        [46179117e-11, 4.15595316782, 10021.8372800994],
        [8109733e-11, 5.55958416318, 2810.9214616052],
        [7485318e-11, 1.77239078402, 5621.8429232104],
        [5523191e-11, 1.3643630377, 2281.2304965106],
        [382516e-10, 4.49407183687, 13362.4497067992],
        [2306537e-11, 0.09081579001, 2544.3144198834],
        [1999396e-11, 5.36059617709, 3337.0893083508],
        [2484394e-11, 4.9254563992, 2942.4634232916],
        [1960195e-11, 4.74249437639, 3344.1355450488],
        [1167119e-11, 2.11260868341, 5092.1519581158],
        [1102816e-11, 5.00908403998, 398.1490034082],
        [899066e-11, 4.40791133207, 529.6909650946],
        [992252e-11, 5.83861961952, 6151.533888305],
        [807354e-11, 2.10217065501, 1059.3819301892],
        [797915e-11, 3.44839203899, 796.2980068164],
        [740975e-11, 1.49906336885, 2146.1654164752]
      ],
      [
        [0.01107433345, 2.03250524857, 3340.6124266998],
        [0.00103175887, 2.37071847807, 6681.2248533996],
        [128772e-9, 0, 0],
        [1081588e-10, 2.70888095665, 10021.8372800994]
      ],
      [
        [44242249e-11, 0.47930604954, 3340.6124266998],
        [8138042e-11, 0.86998389204, 6681.2248533996]
      ]
    ]
  ],
  Jupiter: [
    [
      [
        [0.59954691494, 0, 0],
        [0.09695898719, 5.06191793158, 529.6909650946],
        [0.00573610142, 1.44406205629, 7.1135470008],
        [0.00306389205, 5.41734730184, 1059.3819301892],
        [97178296e-11, 4.14264726552, 632.7837393132],
        [72903078e-11, 3.64042916389, 522.5774180938],
        [64263975e-11, 3.41145165351, 103.0927742186],
        [39806064e-11, 2.29376740788, 419.4846438752],
        [38857767e-11, 1.27231755835, 316.3918696566],
        [27964629e-11, 1.7845459182, 536.8045120954],
        [1358973e-10, 5.7748104079, 1589.0728952838],
        [8246349e-11, 3.5822792584, 206.1855484372],
        [8768704e-11, 3.63000308199, 949.1756089698],
        [7368042e-11, 5.0810119427, 735.8765135318],
        [626315e-10, 0.02497628807, 213.299095438],
        [6114062e-11, 4.51319998626, 1162.4747044078],
        [4905396e-11, 1.32084470588, 110.2063212194],
        [5305285e-11, 1.30671216791, 14.2270940016],
        [5305441e-11, 4.18625634012, 1052.2683831884],
        [4647248e-11, 4.69958103684, 3.9321532631],
        [3045023e-11, 4.31676431084, 426.598190876],
        [2609999e-11, 1.56667394063, 846.0828347512],
        [2028191e-11, 1.06376530715, 3.1813937377],
        [1764763e-11, 2.14148655117, 1066.49547719],
        [1722972e-11, 3.88036268267, 1265.5674786264],
        [1920945e-11, 0.97168196472, 639.897286314],
        [1633223e-11, 3.58201833555, 515.463871093],
        [1431999e-11, 4.29685556046, 625.6701923124],
        [973272e-11, 4.09764549134, 95.9792272178]
      ],
      [
        [529.69096508814, 0, 0],
        [0.00489503243, 4.2208293947, 529.6909650946],
        [0.00228917222, 6.02646855621, 7.1135470008],
        [30099479e-11, 4.54540782858, 1059.3819301892],
        [2072092e-10, 5.45943156902, 522.5774180938],
        [12103653e-11, 0.16994816098, 536.8045120954],
        [6067987e-11, 4.42422292017, 103.0927742186],
        [5433968e-11, 3.98480737746, 419.4846438752],
        [4237744e-11, 5.89008707199, 14.2270940016]
      ],
      [
        [47233601e-11, 4.32148536482, 7.1135470008],
        [30649436e-11, 2.929777887, 529.6909650946],
        [14837605e-11, 3.14159265359, 0]
      ]
    ],
    [
      [
        [0.02268615702, 3.55852606721, 529.6909650946],
        [0.00109971634, 3.90809347197, 1059.3819301892],
        [0.00110090358, 0, 0],
        [8101428e-11, 3.60509572885, 522.5774180938],
        [6043996e-11, 4.25883108339, 1589.0728952838],
        [6437782e-11, 0.30627119215, 536.8045120954]
      ],
      [
        [78203446e-11, 1.52377859742, 529.6909650946]
      ]
    ],
    [
      [
        [5.20887429326, 0, 0],
        [0.25209327119, 3.49108639871, 529.6909650946],
        [0.00610599976, 3.84115365948, 1059.3819301892],
        [0.00282029458, 2.57419881293, 632.7837393132],
        [0.00187647346, 2.07590383214, 522.5774180938],
        [86792905e-11, 0.71001145545, 419.4846438752],
        [72062974e-11, 0.21465724607, 536.8045120954],
        [65517248e-11, 5.9799588479, 316.3918696566],
        [29134542e-11, 1.67759379655, 103.0927742186],
        [30135335e-11, 2.16132003734, 949.1756089698],
        [23453271e-11, 3.54023522184, 735.8765135318],
        [22283743e-11, 4.19362594399, 1589.0728952838],
        [23947298e-11, 0.2745803748, 7.1135470008],
        [13032614e-11, 2.96042965363, 1162.4747044078],
        [970336e-10, 1.90669633585, 206.1855484372],
        [12749023e-11, 2.71550286592, 1052.2683831884],
        [7057931e-11, 2.18184839926, 1265.5674786264],
        [6137703e-11, 6.26418240033, 846.0828347512],
        [2616976e-11, 2.00994012876, 1581.959348283]
      ],
      [
        [0.0127180152, 2.64937512894, 529.6909650946],
        [61661816e-11, 3.00076460387, 1059.3819301892],
        [53443713e-11, 3.89717383175, 522.5774180938],
        [31185171e-11, 4.88276958012, 536.8045120954],
        [41390269e-11, 0, 0]
      ]
    ]
  ],
  Saturn: [
    [
      [
        [0.87401354025, 0, 0],
        [0.11107659762, 3.96205090159, 213.299095438],
        [0.01414150957, 4.58581516874, 7.1135470008],
        [0.00398379389, 0.52112032699, 206.1855484372],
        [0.00350769243, 3.30329907896, 426.598190876],
        [0.00206816305, 0.24658372002, 103.0927742186],
        [792713e-9, 3.84007056878, 220.4126424388],
        [23990355e-11, 4.66976924553, 110.2063212194],
        [16573588e-11, 0.43719228296, 419.4846438752],
        [14906995e-11, 5.76903183869, 316.3918696566],
        [1582029e-10, 0.93809155235, 632.7837393132],
        [14609559e-11, 1.56518472, 3.9321532631],
        [13160301e-11, 4.44891291899, 14.2270940016],
        [15053543e-11, 2.71669915667, 639.897286314],
        [13005299e-11, 5.98119023644, 11.0457002639],
        [10725067e-11, 3.12939523827, 202.2533951741],
        [5863206e-11, 0.23656938524, 529.6909650946],
        [5227757e-11, 4.20783365759, 3.1813937377],
        [6126317e-11, 1.76328667907, 277.0349937414],
        [5019687e-11, 3.17787728405, 433.7117378768],
        [459255e-10, 0.61977744975, 199.0720014364],
        [4005867e-11, 2.24479718502, 63.7358983034],
        [2953796e-11, 0.98280366998, 95.9792272178],
        [387367e-10, 3.22283226966, 138.5174968707],
        [2461186e-11, 2.03163875071, 735.8765135318],
        [3269484e-11, 0.77492638211, 949.1756089698],
        [1758145e-11, 3.2658010994, 522.5774180938],
        [1640172e-11, 5.5050445305, 846.0828347512],
        [1391327e-11, 4.02333150505, 323.5054166574],
        [1580648e-11, 4.37265307169, 309.2783226558],
        [1123498e-11, 2.83726798446, 415.5524906121],
        [1017275e-11, 3.71700135395, 227.5261894396],
        [848642e-11, 3.1915017083, 209.3669421749]
      ],
      [
        [213.2990952169, 0, 0],
        [0.01297370862, 1.82834923978, 213.299095438],
        [0.00564345393, 2.88499717272, 7.1135470008],
        [93734369e-11, 1.06311793502, 426.598190876],
        [0.00107674962, 2.27769131009, 206.1855484372],
        [40244455e-11, 2.04108104671, 220.4126424388],
        [19941774e-11, 1.2795439047, 103.0927742186],
        [10511678e-11, 2.7488034213, 14.2270940016],
        [6416106e-11, 0.38238295041, 639.897286314],
        [4848994e-11, 2.43037610229, 419.4846438752],
        [4056892e-11, 2.92133209468, 110.2063212194],
        [3768635e-11, 3.6496533078, 3.9321532631]
      ],
      [
        [0.0011644133, 1.17988132879, 7.1135470008],
        [91841837e-11, 0.0732519584, 213.299095438],
        [36661728e-11, 0, 0],
        [15274496e-11, 4.06493179167, 206.1855484372]
      ]
    ],
    [
      [
        [0.04330678039, 3.60284428399, 213.299095438],
        [0.00240348302, 2.85238489373, 426.598190876],
        [84745939e-11, 0, 0],
        [30863357e-11, 3.48441504555, 220.4126424388],
        [34116062e-11, 0.57297307557, 206.1855484372],
        [1473407e-10, 2.11846596715, 639.897286314],
        [9916667e-11, 5.79003188904, 419.4846438752],
        [6993564e-11, 4.7360468972, 7.1135470008],
        [4807588e-11, 5.43305312061, 316.3918696566]
      ],
      [
        [0.00198927992, 4.93901017903, 213.299095438],
        [36947916e-11, 3.14159265359, 0],
        [17966989e-11, 0.5197943111, 426.598190876]
      ]
    ],
    [
      [
        [9.55758135486, 0, 0],
        [0.52921382865, 2.39226219573, 213.299095438],
        [0.01873679867, 5.2354960466, 206.1855484372],
        [0.01464663929, 1.64763042902, 426.598190876],
        [0.00821891141, 5.93520042303, 316.3918696566],
        [0.00547506923, 5.0153261898, 103.0927742186],
        [0.0037168465, 2.27114821115, 220.4126424388],
        [0.00361778765, 3.13904301847, 7.1135470008],
        [0.00140617506, 5.70406606781, 632.7837393132],
        [0.00108974848, 3.29313390175, 110.2063212194],
        [69006962e-11, 5.94099540992, 419.4846438752],
        [61053367e-11, 0.94037691801, 639.897286314],
        [48913294e-11, 1.55733638681, 202.2533951741],
        [34143772e-11, 0.19519102597, 277.0349937414],
        [32401773e-11, 5.47084567016, 949.1756089698],
        [20936596e-11, 0.46349251129, 735.8765135318],
        [9796004e-11, 5.20477537945, 1265.5674786264],
        [11993338e-11, 5.98050967385, 846.0828347512],
        [208393e-9, 1.52102476129, 433.7117378768],
        [15298404e-11, 3.0594381494, 529.6909650946],
        [6465823e-11, 0.17732249942, 1052.2683831884],
        [11380257e-11, 1.7310542704, 522.5774180938],
        [3419618e-11, 4.94550542171, 1581.959348283]
      ],
      [
        [0.0618298134, 0.2584351148, 213.299095438],
        [0.00506577242, 0.71114625261, 206.1855484372],
        [0.00341394029, 5.79635741658, 426.598190876],
        [0.00188491195, 0.47215589652, 220.4126424388],
        [0.00186261486, 3.14159265359, 0],
        [0.00143891146, 1.40744822888, 7.1135470008]
      ],
      [
        [0.00436902572, 4.78671677509, 213.299095438]
      ]
    ]
  ],
  Uranus: [
    [
      [
        [5.48129294297, 0, 0],
        [0.09260408234, 0.89106421507, 74.7815985673],
        [0.01504247898, 3.6271926092, 1.4844727083],
        [0.00365981674, 1.89962179044, 73.297125859],
        [0.00272328168, 3.35823706307, 149.5631971346],
        [70328461e-11, 5.39254450063, 63.7358983034],
        [68892678e-11, 6.09292483287, 76.2660712756],
        [61998615e-11, 2.26952066061, 2.9689454166],
        [61950719e-11, 2.85098872691, 11.0457002639],
        [2646877e-10, 3.14152083966, 71.8126531507],
        [25710476e-11, 6.11379840493, 454.9093665273],
        [2107885e-10, 4.36059339067, 148.0787244263],
        [17818647e-11, 1.74436930289, 36.6485629295],
        [14613507e-11, 4.73732166022, 3.9321532631],
        [11162509e-11, 5.8268179635, 224.3447957019],
        [1099791e-10, 0.48865004018, 138.5174968707],
        [9527478e-11, 2.95516862826, 35.1640902212],
        [7545601e-11, 5.236265824, 109.9456887885],
        [4220241e-11, 3.23328220918, 70.8494453042],
        [40519e-9, 2.277550173, 151.0476698429],
        [3354596e-11, 1.0654900738, 4.4534181249],
        [2926718e-11, 4.62903718891, 9.5612275556],
        [349034e-10, 5.48306144511, 146.594251718],
        [3144069e-11, 4.75199570434, 77.7505439839],
        [2922333e-11, 5.35235361027, 85.8272988312],
        [2272788e-11, 4.36600400036, 70.3281804424],
        [2051219e-11, 1.51773566586, 0.1118745846],
        [2148602e-11, 0.60745949945, 38.1330356378],
        [1991643e-11, 4.92437588682, 277.0349937414],
        [1376226e-11, 2.04283539351, 65.2203710117],
        [1666902e-11, 3.62744066769, 380.12776796],
        [1284107e-11, 3.11347961505, 202.2533951741],
        [1150429e-11, 0.93343589092, 3.1813937377],
        [1533221e-11, 2.58594681212, 52.6901980395],
        [1281604e-11, 0.54271272721, 222.8603229936],
        [1372139e-11, 4.19641530878, 111.4301614968],
        [1221029e-11, 0.1990065003, 108.4612160802],
        [946181e-11, 1.19253165736, 127.4717966068],
        [1150989e-11, 4.17898916639, 33.6796175129]
      ],
      [
        [74.7815986091, 0, 0],
        [0.00154332863, 5.24158770553, 74.7815985673],
        [24456474e-11, 1.71260334156, 1.4844727083],
        [9258442e-11, 0.4282973235, 11.0457002639],
        [8265977e-11, 1.50218091379, 63.7358983034],
        [915016e-10, 1.41213765216, 149.5631971346]
      ]
    ],
    [
      [
        [0.01346277648, 2.61877810547, 74.7815985673],
        [623414e-9, 5.08111189648, 149.5631971346],
        [61601196e-11, 3.14159265359, 0],
        [9963722e-11, 1.61603805646, 76.2660712756],
        [992616e-10, 0.57630380333, 73.297125859]
      ],
      [
        [34101978e-11, 0.01321929936, 74.7815985673]
      ]
    ],
    [
      [
        [19.21264847206, 0, 0],
        [0.88784984413, 5.60377527014, 74.7815985673],
        [0.03440836062, 0.32836099706, 73.297125859],
        [0.0205565386, 1.7829515933, 149.5631971346],
        [0.0064932241, 4.52247285911, 76.2660712756],
        [0.00602247865, 3.86003823674, 63.7358983034],
        [0.00496404167, 1.40139935333, 454.9093665273],
        [0.00338525369, 1.58002770318, 138.5174968707],
        [0.00243509114, 1.57086606044, 71.8126531507],
        [0.00190522303, 1.99809394714, 1.4844727083],
        [0.00161858838, 2.79137786799, 148.0787244263],
        [0.00143706183, 1.38368544947, 11.0457002639],
        [93192405e-11, 0.17437220467, 36.6485629295],
        [71424548e-11, 4.24509236074, 224.3447957019],
        [89806014e-11, 3.66105364565, 109.9456887885],
        [39009723e-11, 1.66971401684, 70.8494453042],
        [46677296e-11, 1.39976401694, 35.1640902212],
        [39025624e-11, 3.36234773834, 277.0349937414],
        [36755274e-11, 3.88649278513, 146.594251718],
        [30348723e-11, 0.70100838798, 151.0476698429],
        [29156413e-11, 3.180563367, 77.7505439839],
        [22637073e-11, 0.72518687029, 529.6909650946],
        [11959076e-11, 1.7504339214, 984.6003316219],
        [25620756e-11, 5.25656086672, 380.12776796]
      ],
      [
        [0.01479896629, 3.67205697578, 74.7815985673]
      ]
    ]
  ],
  Neptune: [
    [
      [
        [5.31188633046, 0, 0],
        [0.0179847553, 2.9010127389, 38.1330356378],
        [0.01019727652, 0.48580922867, 1.4844727083],
        [0.00124531845, 4.83008090676, 36.6485629295],
        [42064466e-11, 5.41054993053, 2.9689454166],
        [37714584e-11, 6.09221808686, 35.1640902212],
        [33784738e-11, 1.24488874087, 76.2660712756],
        [16482741e-11, 7727998e-11, 491.5579294568],
        [9198584e-11, 4.93747051954, 39.6175083461],
        [899425e-10, 0.27462171806, 175.1660598002]
      ],
      [
        [38.13303563957, 0, 0],
        [16604172e-11, 4.86323329249, 1.4844727083],
        [15744045e-11, 2.27887427527, 38.1330356378]
      ]
    ],
    [
      [
        [0.03088622933, 1.44104372644, 38.1330356378],
        [27780087e-11, 5.91271884599, 76.2660712756],
        [27623609e-11, 0, 0],
        [15355489e-11, 2.52123799551, 36.6485629295],
        [15448133e-11, 3.50877079215, 39.6175083461]
      ]
    ],
    [
      [
        [30.07013205828, 0, 0],
        [0.27062259632, 1.32999459377, 38.1330356378],
        [0.01691764014, 3.25186135653, 36.6485629295],
        [0.00807830553, 5.18592878704, 1.4844727083],
        [0.0053776051, 4.52113935896, 35.1640902212],
        [0.00495725141, 1.5710564165, 491.5579294568],
        [0.00274571975, 1.84552258866, 175.1660598002],
        [1201232e-10, 1.92059384991, 1021.2488945514],
        [0.00121801746, 5.79754470298, 76.2660712756],
        [0.00100896068, 0.3770272493, 73.297125859],
        [0.00135134092, 3.37220609835, 39.6175083461],
        [7571796e-11, 1.07149207335, 388.4651552382]
      ]
    ]
  ]
};
function Ft(e) {
  var n, t, r, i, o, s, c;
  const a = 2e3 + (e - 14) / Nt;
  return a < -500 ? (n = (a - 1820) / 100, -20 + 32 * n * n) : a < 500 ? (n = a / 100, t = n * n, r = n * t, i = t * t, o = t * r, s = r * r, 10583.6 - 1014.41 * n + 33.78311 * t - 5.952053 * r - 0.1798452 * i + 0.022174192 * o + 0.0090316521 * s) : a < 1600 ? (n = (a - 1e3) / 100, t = n * n, r = n * t, i = t * t, o = t * r, s = r * r, 1574.2 - 556.01 * n + 71.23472 * t + 0.319781 * r - 0.8503463 * i - 5050998e-9 * o + 0.0083572073 * s) : a < 1700 ? (n = a - 1600, t = n * n, r = n * t, 120 - 0.9808 * n - 0.01532 * t + r / 7129) : a < 1800 ? (n = a - 1700, t = n * n, r = n * t, i = t * t, 8.83 + 0.1603 * n - 59285e-7 * t + 13336e-8 * r - i / 1174e3) : a < 1860 ? (n = a - 1800, t = n * n, r = n * t, i = t * t, o = t * r, s = r * r, c = r * i, 13.72 - 0.332447 * n + 68612e-7 * t + 41116e-7 * r - 37436e-8 * i + 121272e-10 * o - 1699e-10 * s + 875e-12 * c) : a < 1900 ? (n = a - 1860, t = n * n, r = n * t, i = t * t, o = t * r, 7.62 + 0.5737 * n - 0.251754 * t + 0.01680668 * r - 4473624e-10 * i + o / 233174) : a < 1920 ? (n = a - 1900, t = n * n, r = n * t, i = t * t, -2.79 + 1.494119 * n - 0.0598939 * t + 61966e-7 * r - 197e-6 * i) : a < 1941 ? (n = a - 1920, t = n * n, r = n * t, 21.2 + 0.84493 * n - 0.0761 * t + 20936e-7 * r) : a < 1961 ? (n = a - 1950, t = n * n, r = n * t, 29.07 + 0.407 * n - t / 233 + r / 2547) : a < 1986 ? (n = a - 1975, t = n * n, r = n * t, 45.45 + 1.067 * n - t / 260 - r / 718) : a < 2005 ? (n = a - 2e3, t = n * n, r = n * t, i = t * t, o = t * r, 63.86 + 0.3345 * n - 0.060374 * t + 17275e-7 * r + 651814e-9 * i + 2373599e-11 * o) : a < 2050 ? (n = a - 2e3, 62.92 + 0.32217 * n + 5589e-6 * n * n) : a < 2150 ? (n = (a - 1820) / 100, -20 + 32 * n * n - 0.5628 * (2150 - a)) : (n = (a - 1820) / 100, -20 + 32 * n * n);
}
let Ht = Ft;
function Cn(e) {
  return e + Ht(e) / 86400;
}
class j {
  /**
   * @param {FlexibleDateTime} date
   *      A JavaScript Date object, a numeric UTC value expressed in J2000 days, or another AstroTime object.
   */
  constructor(n) {
    if (n instanceof j) {
      this.date = n.date, this.ut = n.ut, this.tt = n.tt;
      return;
    }
    const t = 1e3 * 3600 * 24;
    if (n instanceof Date && Number.isFinite(n.getTime())) {
      this.date = n, this.ut = (n.getTime() - yn.getTime()) / t, this.tt = Cn(this.ut);
      return;
    }
    if (Number.isFinite(n)) {
      this.date = new Date(yn.getTime() + n * t), this.ut = n, this.tt = Cn(this.ut);
      return;
    }
    throw "Argument must be a Date object, an AstroTime object, or a numeric UTC Julian date.";
  }
  /**
   * @brief Creates an `AstroTime` value from a Terrestrial Time (TT) day value.
   *
   * This function can be used in rare cases where a time must be based
   * on Terrestrial Time (TT) rather than Universal Time (UT).
   * Most developers will want to invoke `new AstroTime(ut)` with a universal time
   * instead of this function, because usually time is based on civil time adjusted
   * by leap seconds to match the Earth's rotation, rather than the uniformly
   * flowing TT used to calculate solar system dynamics. In rare cases
   * where the caller already knows TT, this function is provided to create
   * an `AstroTime` value that can be passed to Astronomy Engine functions.
   *
   * @param {number} tt
   *      The number of days since the J2000 epoch as expressed in Terrestrial Time.
   *
   * @returns {AstroTime}
   *      An `AstroTime` object for the specified terrestrial time.
   */
  static FromTerrestrialTime(n) {
    let t = new j(n);
    for (; ; ) {
      const r = n - t.tt;
      if (Math.abs(r) < 1e-12)
        return t;
      t = t.AddDays(r);
    }
  }
  /**
   * Formats an `AstroTime` object as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
   * date/time string in UTC, to millisecond resolution.
   * Example: `2018-08-17T17:22:04.050Z`
   * @returns {string}
   */
  toString() {
    return this.date.toISOString();
  }
  /**
   * Returns a new `AstroTime` object adjusted by the floating point number of days.
   * Does NOT modify the original `AstroTime` object.
   *
   * @param {number} days
   *      The floating point number of days by which to adjust the given date and time.
   *      Positive values adjust the date toward the future, and
   *      negative values adjust the date toward the past.
   *
   * @returns {AstroTime}
   */
  AddDays(n) {
    return new j(this.ut + n);
  }
}
function Z(e) {
  return e instanceof j ? e : new j(e);
}
function kt(e) {
  function n(f) {
    return f % Pt * Q;
  }
  const t = e.tt / 36525, r = n(128710479305e-5 + t * 1295965810481e-4), i = n(335779.526232 + t * 17395272628478e-4), o = n(107226070369e-5 + t * 1602961601209e-3), s = n(450160.398036 - t * 69628905431e-4);
  let c = Math.sin(s), a = Math.cos(s), l = (-172064161 - 174666 * t) * c + 33386 * a, d = (92052331 + 9086 * t) * a + 15377 * c, _ = 2 * (i - o + s);
  return c = Math.sin(_), a = Math.cos(_), l += (-13170906 - 1675 * t) * c - 13696 * a, d += (5730336 - 3015 * t) * a - 4587 * c, _ = 2 * (i + s), c = Math.sin(_), a = Math.cos(_), l += (-2276413 - 234 * t) * c + 2796 * a, d += (978459 - 485 * t) * a + 1374 * c, _ = 2 * s, c = Math.sin(_), a = Math.cos(_), l += (2074554 + 207 * t) * c - 698 * a, d += (-897492 + 470 * t) * a - 291 * c, c = Math.sin(r), a = Math.cos(r), l += (1475877 - 3633 * t) * c + 11817 * a, d += (73871 - 184 * t) * a - 1924 * c, {
    dpsi: -135e-6 + l * 1e-7,
    deps: 388e-6 + d * 1e-7
  };
}
function Fn(e) {
  var n = e.tt / 36525, t = ((((-434e-10 * n - 576e-9) * n + 20034e-7) * n - 1831e-7) * n - 46.836769) * n + 84381.406;
  return t / 3600;
}
var S0;
function Hn(e) {
  if (!S0 || Math.abs(S0.tt - e.tt) > 1e-6) {
    const n = kt(e), t = Fn(e), r = t + n.deps / 3600;
    S0 = {
      tt: e.tt,
      dpsi: n.dpsi,
      deps: n.deps,
      ee: n.dpsi * Math.cos(t * o0) / 15,
      mobl: t,
      tobl: r
    };
  }
  return S0;
}
function $t(e, n) {
  const t = e * o0, r = Math.cos(t), i = Math.sin(t);
  return [
    n[0],
    n[1] * r - n[2] * i,
    n[1] * i + n[2] * r
  ];
}
function Vt(e, n) {
  return $t(Fn(e), n);
}
function Wt(e) {
  const n = e.tt / 36525;
  function t(R, S) {
    const A = [];
    let C;
    for (C = 0; C <= S - R; ++C)
      A.push(0);
    return { min: R, array: A };
  }
  function r(R, S, A, C) {
    const M = [];
    for (let V = 0; V <= S - R; ++V)
      M.push(t(A, C));
    return { min: R, array: M };
  }
  function i(R, S, A) {
    const C = R.array[S - R.min];
    return C.array[A - C.min];
  }
  function o(R, S, A, C) {
    const M = R.array[S - R.min];
    M.array[A - M.min] = C;
  }
  let s, c, a, l, d, _, f, T, h, v, x, y, N, D, P, O, L, b, f0, s0, Y, h0, c0, gn = r(-6, 6, 1, 4), pn = r(-6, 6, 1, 4);
  function v0(R, S) {
    return i(gn, R, S);
  }
  function g0(R, S) {
    return i(pn, R, S);
  }
  function p0(R, S, A) {
    return o(gn, R, S, A);
  }
  function T0(R, S, A) {
    return o(pn, R, S, A);
  }
  function Tn(R, S, A, C, M) {
    M(R * A - S * C, S * A + R * C);
  }
  function w(R) {
    return Math.sin(H * R);
  }
  f = n * n, h = 0, c0 = 0, x = 0, y = 3422.7;
  var R0 = w(0.19833 + 0.05611 * n), b0 = w(0.27869 + 0.04508 * n), z0 = w(0.16827 - 0.36903 * n), L0 = w(0.34734 - 5.37261 * n), F0 = w(0.10498 - 5.37899 * n), E0 = w(0.42681 - 0.41855 * n), Zn = w(0.14943 - 5.37511 * n);
  for (b = 0.84 * R0 + 0.31 * b0 + 14.27 * z0 + 7.26 * L0 + 0.28 * F0 + 0.24 * E0, f0 = 2.94 * R0 + 0.31 * b0 + 14.27 * z0 + 9.34 * L0 + 1.12 * F0 + 0.83 * E0, s0 = -6.4 * R0 - 1.89 * E0, Y = 0.21 * R0 + 0.31 * b0 + 14.27 * z0 - 88.7 * L0 - 15.3 * F0 + 0.24 * E0 - 1.86 * Zn, h0 = b - s0, T = -3332e-9 * w(0.59734 - 5.37261 * n) - 539e-9 * w(0.35498 - 5.37899 * n) - 64e-9 * w(0.39943 - 5.37511 * n), N = H * J(0.60643382 + 1336.85522467 * n - 313e-8 * f) + b / W, D = H * J(0.37489701 + 1325.55240982 * n + 2565e-8 * f) + f0 / W, P = H * J(0.99312619 + 99.99735956 * n - 44e-8 * f) + s0 / W, O = H * J(0.25909118 + 1342.2278298 * n - 892e-8 * f) + Y / W, L = H * J(0.82736186 + 1236.85308708 * n - 397e-8 * f) + h0 / W, d = 1; d <= 4; ++d) {
    switch (d) {
      case 1:
        a = D, c = 4, l = 1.000002208;
        break;
      case 2:
        a = P, c = 3, l = 0.997504612 - 2495388e-9 * n;
        break;
      case 3:
        a = O, c = 4, l = 1.000002708 + 139.978 * T;
        break;
      case 4:
        a = L, c = 6, l = 1;
        break;
      default:
        throw `Internal error: I = ${d}`;
    }
    for (p0(0, d, 1), p0(1, d, Math.cos(a) * l), T0(0, d, 0), T0(1, d, Math.sin(a) * l), _ = 2; _ <= c; ++_)
      Tn(v0(_ - 1, d), g0(_ - 1, d), v0(1, d), g0(1, d), (R, S) => (p0(_, d, R), T0(_, d, S)));
    for (_ = 1; _ <= c; ++_)
      p0(-_, d, v0(_, d)), T0(-_, d, -g0(_, d));
  }
  function Rn(R, S, A, C) {
    for (var M = { x: 1, y: 0 }, V = [0, R, S, A, C], F = 1; F <= 4; ++F)
      V[F] !== 0 && Tn(M.x, M.y, v0(V[F], F), g0(V[F], F), (H0, K) => (M.x = H0, M.y = K));
    return M;
  }
  function u(R, S, A, C, M, V, F, H0) {
    var K = Rn(M, V, F, H0);
    h += R * K.y, c0 += S * K.y, x += A * K.x, y += C * K.x;
  }
  u(13.902, 14.06, -1e-3, 0.2607, 0, 0, 0, 4), u(0.403, -4.01, 0.394, 23e-4, 0, 0, 0, 3), u(2369.912, 2373.36, 0.601, 28.2333, 0, 0, 0, 2), u(-125.154, -112.79, -0.725, -0.9781, 0, 0, 0, 1), u(1.979, 6.98, -0.445, 0.0433, 1, 0, 0, 4), u(191.953, 192.72, 0.029, 3.0861, 1, 0, 0, 2), u(-8.466, -13.51, 0.455, -0.1093, 1, 0, 0, 1), u(22639.5, 22609.07, 0.079, 186.5398, 1, 0, 0, 0), u(18.609, 3.59, -0.094, 0.0118, 1, 0, 0, -1), u(-4586.465, -4578.13, -0.077, 34.3117, 1, 0, 0, -2), u(3.215, 5.44, 0.192, -0.0386, 1, 0, 0, -3), u(-38.428, -38.64, 1e-3, 0.6008, 1, 0, 0, -4), u(-0.393, -1.43, -0.092, 86e-4, 1, 0, 0, -6), u(-0.289, -1.59, 0.123, -53e-4, 0, 1, 0, 4), u(-24.42, -25.1, 0.04, -0.3, 0, 1, 0, 2), u(18.023, 17.93, 7e-3, 0.1494, 0, 1, 0, 1), u(-668.146, -126.98, -1.302, -0.3997, 0, 1, 0, 0), u(0.56, 0.32, -1e-3, -37e-4, 0, 1, 0, -1), u(-165.145, -165.06, 0.054, 1.9178, 0, 1, 0, -2), u(-1.877, -6.46, -0.416, 0.0339, 0, 1, 0, -4), u(0.213, 1.02, -0.074, 54e-4, 2, 0, 0, 4), u(14.387, 14.78, -0.017, 0.2833, 2, 0, 0, 2), u(-0.586, -1.2, 0.054, -0.01, 2, 0, 0, 1), u(769.016, 767.96, 0.107, 10.1657, 2, 0, 0, 0), u(1.75, 2.01, -0.018, 0.0155, 2, 0, 0, -1), u(-211.656, -152.53, 5.679, -0.3039, 2, 0, 0, -2), u(1.225, 0.91, -0.03, -88e-4, 2, 0, 0, -3), u(-30.773, -34.07, -0.308, 0.3722, 2, 0, 0, -4), u(-0.57, -1.4, -0.074, 0.0109, 2, 0, 0, -6), u(-2.921, -11.75, 0.787, -0.0484, 1, 1, 0, 2), u(1.267, 1.52, -0.022, 0.0164, 1, 1, 0, 1), u(-109.673, -115.18, 0.461, -0.949, 1, 1, 0, 0), u(-205.962, -182.36, 2.056, 1.4437, 1, 1, 0, -2), u(0.233, 0.36, 0.012, -25e-4, 1, 1, 0, -3), u(-4.391, -9.66, -0.471, 0.0673, 1, 1, 0, -4), u(0.283, 1.53, -0.111, 6e-3, 1, -1, 0, 4), u(14.577, 31.7, -1.54, 0.2302, 1, -1, 0, 2), u(147.687, 138.76, 0.679, 1.1528, 1, -1, 0, 0), u(-1.089, 0.55, 0.021, 0, 1, -1, 0, -1), u(28.475, 23.59, -0.443, -0.2257, 1, -1, 0, -2), u(-0.276, -0.38, -6e-3, -36e-4, 1, -1, 0, -3), u(0.636, 2.27, 0.146, -0.0102, 1, -1, 0, -4), u(-0.189, -1.68, 0.131, -28e-4, 0, 2, 0, 2), u(-7.486, -0.66, -0.037, -86e-4, 0, 2, 0, 0), u(-8.096, -16.35, -0.74, 0.0918, 0, 2, 0, -2), u(-5.741, -0.04, 0, -9e-4, 0, 0, 2, 2), u(0.255, 0, 0, 0, 0, 0, 2, 1), u(-411.608, -0.2, 0, -0.0124, 0, 0, 2, 0), u(0.584, 0.84, 0, 71e-4, 0, 0, 2, -1), u(-55.173, -52.14, 0, -0.1052, 0, 0, 2, -2), u(0.254, 0.25, 0, -17e-4, 0, 0, 2, -3), u(0.025, -1.67, 0, 31e-4, 0, 0, 2, -4), u(1.06, 2.96, -0.166, 0.0243, 3, 0, 0, 2), u(36.124, 50.64, -1.3, 0.6215, 3, 0, 0, 0), u(-13.193, -16.4, 0.258, -0.1187, 3, 0, 0, -2), u(-1.187, -0.74, 0.042, 74e-4, 3, 0, 0, -4), u(-0.293, -0.31, -2e-3, 46e-4, 3, 0, 0, -6), u(-0.29, -1.45, 0.116, -51e-4, 2, 1, 0, 2), u(-7.649, -10.56, 0.259, -0.1038, 2, 1, 0, 0), u(-8.627, -7.59, 0.078, -0.0192, 2, 1, 0, -2), u(-2.74, -2.54, 0.022, 0.0324, 2, 1, 0, -4), u(1.181, 3.32, -0.212, 0.0213, 2, -1, 0, 2), u(9.703, 11.67, -0.151, 0.1268, 2, -1, 0, 0), u(-0.352, -0.37, 1e-3, -28e-4, 2, -1, 0, -1), u(-2.494, -1.17, -3e-3, -17e-4, 2, -1, 0, -2), u(0.36, 0.2, -0.012, -43e-4, 2, -1, 0, -4), u(-1.167, -1.25, 8e-3, -0.0106, 1, 2, 0, 0), u(-7.412, -6.12, 0.117, 0.0484, 1, 2, 0, -2), u(-0.311, -0.65, -0.032, 44e-4, 1, 2, 0, -4), u(0.757, 1.82, -0.105, 0.0112, 1, -2, 0, 2), u(2.58, 2.32, 0.027, 0.0196, 1, -2, 0, 0), u(2.533, 2.4, -0.014, -0.0212, 1, -2, 0, -2), u(-0.344, -0.57, -0.025, 36e-4, 0, 3, 0, -2), u(-0.992, -0.02, 0, 0, 1, 0, 2, 2), u(-45.099, -0.02, 0, -1e-3, 1, 0, 2, 0), u(-0.179, -9.52, 0, -0.0833, 1, 0, 2, -2), u(-0.301, -0.33, 0, 14e-4, 1, 0, 2, -4), u(-6.382, -3.37, 0, -0.0481, 1, 0, -2, 2), u(39.528, 85.13, 0, -0.7136, 1, 0, -2, 0), u(9.366, 0.71, 0, -0.0112, 1, 0, -2, -2), u(0.202, 0.02, 0, 0, 1, 0, -2, -4), u(0.415, 0.1, 0, 13e-4, 0, 1, 2, 0), u(-2.152, -2.26, 0, -66e-4, 0, 1, 2, -2), u(-1.44, -1.3, 0, 14e-4, 0, 1, -2, 2), u(0.384, -0.04, 0, 0, 0, 1, -2, -2), u(1.938, 3.6, -0.145, 0.0401, 4, 0, 0, 0), u(-0.952, -1.58, 0.052, -0.013, 4, 0, 0, -2), u(-0.551, -0.94, 0.032, -97e-4, 3, 1, 0, 0), u(-0.482, -0.57, 5e-3, -45e-4, 3, 1, 0, -2), u(0.681, 0.96, -0.026, 0.0115, 3, -1, 0, 0), u(-0.297, -0.27, 2e-3, -9e-4, 2, 2, 0, -2), u(0.254, 0.21, -3e-3, 0, 2, -2, 0, -2), u(-0.25, -0.22, 4e-3, 14e-4, 1, 3, 0, -2), u(-3.996, 0, 0, 4e-4, 2, 0, 2, 0), u(0.557, -0.75, 0, -9e-3, 2, 0, 2, -2), u(-0.459, -0.38, 0, -53e-4, 2, 0, -2, 2), u(-1.298, 0.74, 0, 4e-4, 2, 0, -2, 0), u(0.538, 1.14, 0, -0.0141, 2, 0, -2, -2), u(0.263, 0.02, 0, 0, 1, 1, 2, 0), u(0.426, 0.07, 0, -6e-4, 1, 1, -2, -2), u(-0.304, 0.03, 0, 3e-4, 1, -1, 2, 0), u(-0.372, -0.19, 0, -27e-4, 1, -1, -2, 2), u(0.418, 0, 0, 0, 0, 0, 4, 0), u(-0.33, -0.04, 0, 0, 3, 0, 2, 0);
  function z(R, S, A, C, M) {
    return R * Rn(S, A, C, M).y;
  }
  v = 0, v += z(-526.069, 0, 0, 1, -2), v += z(-3.352, 0, 0, 1, -4), v += z(44.297, 1, 0, 1, -2), v += z(-6, 1, 0, 1, -4), v += z(20.599, -1, 0, 1, 0), v += z(-30.598, -1, 0, 1, -2), v += z(-24.649, -2, 0, 1, 0), v += z(-2, -2, 0, 1, -2), v += z(-22.571, 0, 1, 1, -2), v += z(10.985, 0, -1, 1, -2), h += 0.82 * w(0.7736 - 62.5512 * n) + 0.31 * w(0.0466 - 125.1025 * n) + 0.35 * w(0.5785 - 25.1042 * n) + 0.66 * w(0.4591 + 1335.8075 * n) + 0.64 * w(0.313 - 91.568 * n) + 1.14 * w(0.148 + 1331.2898 * n) + 0.21 * w(0.5918 + 1056.5859 * n) + 0.44 * w(0.5784 + 1322.8595 * n) + 0.24 * w(0.2275 - 5.7374 * n) + 0.28 * w(0.2965 + 2.6929 * n) + 0.33 * w(0.3132 + 6.3368 * n), s = O + c0 / W;
  let Yn = (1.000002708 + 139.978 * T) * (18518.511 + 1.189 + x) * Math.sin(s) - 6.24 * Math.sin(3 * s) + v;
  return {
    geo_eclip_lon: H * J((N + h / W) / H),
    geo_eclip_lat: Math.PI / (180 * 3600) * Yn,
    distance_au: W * Gt / (0.999953253 * y)
  };
}
function jt(e, n) {
  return [
    e.rot[0][0] * n[0] + e.rot[1][0] * n[1] + e.rot[2][0] * n[2],
    e.rot[0][1] * n[0] + e.rot[1][1] * n[1] + e.rot[2][1] * n[2],
    e.rot[0][2] * n[0] + e.rot[1][2] * n[1] + e.rot[2][2] * n[2]
  ];
}
function qt(e, n, t) {
  const r = kn(n, t);
  return jt(r, e);
}
function kn(e, n) {
  const t = e.tt / 36525;
  let r = 84381.406, i = ((((-951e-10 * t + 132851e-9) * t - 114045e-8) * t - 1.0790069) * t + 5038.481507) * t, o = ((((3337e-10 * t - 467e-9) * t - 772503e-8) * t + 0.0512623) * t - 0.025754) * t + r, s = ((((-56e-9 * t + 170663e-9) * t - 121197e-8) * t - 2.3814292) * t + 10.556403) * t;
  r *= Q, i *= Q, o *= Q, s *= Q;
  const c = Math.sin(r), a = Math.cos(r), l = Math.sin(-i), d = Math.cos(-i), _ = Math.sin(-o), f = Math.cos(-o), T = Math.sin(s), h = Math.cos(s), v = h * d - l * T * f, x = h * l * a + T * f * d * a - c * T * _, y = h * l * c + T * f * d * c + a * T * _, N = -T * d - l * h * f, D = -T * l * a + h * f * d * a - c * h * _, P = -T * l * c + h * f * d * c + a * h * _, O = l * _, L = -_ * d * a - c * f, b = -_ * d * c + f * a;
  if (n === $.Into2000)
    return new a0([
      [v, x, y],
      [N, D, P],
      [O, L, b]
    ]);
  if (n === $.From2000)
    return new a0([
      [v, N, O],
      [x, D, L],
      [y, P, b]
    ]);
  throw "Invalid precess direction";
}
function Xt(e) {
  const n = 0.779057273264 + 0.00273781191135448 * e.ut, t = e.ut % 1;
  let r = 360 * ((n + t) % 1);
  return r < 0 && (r += 360), r;
}
let x0;
function Bt(e) {
  if (!x0 || x0.tt !== e.tt) {
    const n = e.tt / 36525;
    let t = 15 * Hn(e).ee;
    const r = Xt(e);
    let o = ((t + 0.014506 + ((((-368e-10 * n - 29956e-9) * n - 44e-8) * n + 1.3915817) * n + 4612.156534) * n) / 3600 + r) % 360 / 15;
    o < 0 && (o += 24), x0 = {
      tt: e.tt,
      st: o
    };
  }
  return x0.st;
}
function Zt(e) {
  const n = Z(e);
  return Bt(n);
}
function Yt(e, n) {
  const t = Hn(e), r = t.mobl * o0, i = t.tobl * o0, o = t.dpsi * Q, s = Math.cos(r), c = Math.sin(r), a = Math.cos(i), l = Math.sin(i), d = Math.cos(o), _ = Math.sin(o), f = d, T = -_ * s, h = -_ * c, v = _ * a, x = d * s * a + c * l, y = d * c * a - s * l, N = _ * l, D = d * s * l - c * a, P = d * c * l + s * a;
  if (n === $.From2000)
    return new a0([
      [f, v, N],
      [T, x, D],
      [h, y, P]
    ]);
  if (n === $.Into2000)
    return new a0([
      [f, T, h],
      [v, x, y],
      [N, D, P]
    ]);
  throw "Invalid precess direction";
}
class G {
  constructor(n, t, r, i) {
    this.x = n, this.y = t, this.z = r, this.t = i;
  }
  /**
   * Returns the length of the vector in astronomical units (AU).
   * @returns {number}
   */
  Length() {
    return Math.hypot(this.x, this.y, this.z);
  }
}
class Kt {
  constructor(n, t, r, i, o, s, c) {
    this.x = n, this.y = t, this.z = r, this.vx = i, this.vy = o, this.vz = s, this.t = c;
  }
}
class Jt {
  constructor(n, t, r) {
    this.lat = V0(n), this.lon = V0(t), this.dist = V0(r);
  }
}
class a0 {
  constructor(n) {
    this.rot = n;
  }
}
function J0(e) {
  const n = Z(e), t = Wt(n), r = t.distance_au * Math.cos(t.geo_eclip_lat), i = [
    r * Math.cos(t.geo_eclip_lon),
    r * Math.sin(t.geo_eclip_lon),
    t.distance_au * Math.sin(t.geo_eclip_lat)
  ], o = Vt(n, i), s = qt(o, n, $.Into2000);
  return new G(s[0], s[1], s[2], n);
}
function r0(e, n, t) {
  let r = 1, i = 0;
  for (let o of e) {
    let s = 0;
    for (let [a, l, d] of o)
      s += a * Math.cos(l + n * d);
    let c = r * s;
    t && (c %= H), i += c, r *= n;
  }
  return i;
}
function W0(e, n) {
  let t = 1, r = 0, i = 0, o = 0;
  for (let s of e) {
    let c = 0, a = 0;
    for (let [l, d, _] of s) {
      let f = d + n * _;
      c += l * _ * Math.sin(f), o > 0 && (a += l * Math.cos(f));
    }
    i += o * r * a - t * c, r = t, t *= n, ++o;
  }
  return i;
}
const l0 = 365250, Q0 = 0, nn = 1, tn = 2;
function en(e) {
  return new I(e[0] + 44036e-11 * e[1] - 190919e-12 * e[2], -479966e-12 * e[0] + 0.917482137087 * e[1] - 0.397776982902 * e[2], 0.397776982902 * e[1] + 0.917482137087 * e[2]);
}
function $n(e, n, t) {
  const r = t * Math.cos(n), i = Math.cos(e), o = Math.sin(e);
  return [
    r * i,
    r * o,
    t * Math.sin(n)
  ];
}
function C0(e, n) {
  const t = n.tt / l0, r = r0(e[Q0], t, !0), i = r0(e[nn], t, !1), o = r0(e[tn], t, !1), s = $n(r, i, o);
  return en(s).ToAstroVector(n);
}
function Qt(e, n) {
  const t = n / l0, r = r0(e[Q0], t, !0), i = r0(e[nn], t, !1), o = r0(e[tn], t, !1), s = W0(e[Q0], t), c = W0(e[nn], t), a = W0(e[tn], t), l = Math.cos(r), d = Math.sin(r), _ = Math.cos(i), f = Math.sin(i), T = +(a * _ * l) - o * f * l * c - o * _ * d * s, h = +(a * _ * d) - o * f * d * c + o * _ * l * s, v = +(a * f) + o * _ * c, x = $n(r, i, o), y = [
    T / l0,
    h / l0,
    v / l0
  ], N = en(x), D = en(y);
  return new B(n, N, D);
}
function w0(e, n, t, r) {
  const i = r / (r + fn), o = C0(n0[t], n);
  e.x += i * o.x, e.y += i * o.y, e.z += i * o.z;
}
function ne(e) {
  const n = new G(0, 0, 0, e);
  return w0(n, e, E.Jupiter, B0), w0(n, e, E.Saturn, Z0), w0(n, e, E.Uranus, Y0), w0(n, e, E.Neptune, K0), n;
}
const rn = 51, te = 29200, t0 = 146, k = 201, q = [
  [-73e4, [-26.118207232108, -14.376168177825, 3.384402515299], [0.0016339372163656, -0.0027861699588508, -0.0013585880229445]],
  [-700800, [41.974905202127, -0.448502952929, -12.770351505989], [73458569351457e-17, 0.0022785014891658, 48619778602049e-17]],
  [-671600, [14.706930780744, 44.269110540027, 9.353698474772], [-0.00210001479998, 22295915939915e-17, 70143443551414e-17]],
  [-642400, [-29.441003929957, -6.43016153057, 6.858481011305], [84495803960544e-17, -0.0030783914758711, -0.0012106305981192]],
  [-613200, [39.444396946234, -6.557989760571, -13.913760296463], [0.0011480029005873, 0.0022400006880665, 35168075922288e-17]],
  [-584e3, [20.2303809507, 43.266966657189, 7.382966091923], [-0.0019754081700585, 53457141292226e-17, 75929169129793e-17]],
  [-554800, [-30.65832536462, 2.093818874552, 9.880531138071], [61010603013347e-18, -0.0031326500935382, -99346125151067e-17]],
  [-525600, [35.737703251673, -12.587706024764, -14.677847247563], [0.0015802939375649, 0.0021347678412429, 19074436384343e-17]],
  [-496400, [25.466295188546, 41.367478338417, 5.216476873382], [-0.0018054401046468, 8328308359951e-16, 80260156912107e-17]],
  [-467200, [-29.847174904071, 10.636426313081, 12.297904180106], [-63257063052907e-17, -0.0029969577578221, -74476074151596e-17]],
  [-438e3, [30.774692107687, -18.236637015304, -14.945535879896], [0.0020113162005465, 0.0019353827024189, -20937793168297e-19]],
  [-408800, [30.243153324028, 38.656267888503, 2.938501750218], [-0.0016052508674468, 0.0011183495337525, 83333973416824e-17]],
  [-379600, [-27.288984772533, 18.643162147874, 14.023633623329], [-0.0011856388898191, -0.0027170609282181, -49015526126399e-17]],
  [-350400, [24.519605196774, -23.245756064727, -14.626862367368], [0.0024322321483154, 0.0016062008146048, -23369181613312e-17]],
  [-321200, [34.505274805875, 35.125338586954, 0.557361475637], [-0.0013824391637782, 0.0013833397561817, 84823598806262e-17]],
  [-292e3, [-23.275363915119, 25.818514298769, 15.055381588598], [-0.0016062295460975, -0.0023395961498533, -24377362639479e-17]],
  [-262800, [17.050384798092, -27.180376290126, -13.608963321694], [0.0028175521080578, 0.0011358749093955, -49548725258825e-17]],
  [-233600, [38.093671910285, 30.880588383337, -1.843688067413], [-0.0011317697153459, 0.0016128814698472, 84177586176055e-17]],
  [-204400, [-18.197852930878, 31.932869934309, 15.438294826279], [-0.0019117272501813, -0.0019146495909842, -19657304369835e-18]],
  [-175200, [8.528924039997, -29.618422200048, -11.805400994258], [0.0031034370787005, 5139363329243e-16, -77293066202546e-17]],
  [-146e3, [40.94685725864, 25.904973592021, -4.256336240499], [-83652705194051e-17, 0.0018129497136404, 8156422827306e-16]],
  [-116800, [-12.326958895325, 36.881883446292, 15.217158258711], [-0.0021166103705038, -0.001481442003599, 17401209844705e-17]],
  [-87600, [-0.633258375909, -30.018759794709, -9.17193287495], [0.0032016994581737, -25279858672148e-17, -0.0010411088271861]],
  [-58400, [42.936048423883, 20.344685584452, -6.588027007912], [-50525450073192e-17, 0.0019910074335507, 77440196540269e-17]],
  [-29200, [-5.975910552974, 40.61180995846, 14.470131723673], [-0.0022184202156107, -0.0010562361130164, 33652250216211e-17]],
  [0, [-9.875369580774, -27.978926224737, -5.753711824704], [0.0030287533248818, -0.0011276087003636, -0.0012651326732361]],
  [29200, [43.958831986165, 14.214147973292, -8.808306227163], [-14717608981871e-17, 0.0021404187242141, 71486567806614e-17]],
  [58400, [0.67813676352, 43.094461639362, 13.243238780721], [-0.0022358226110718, -63233636090933e-17, 47664798895648e-17]],
  [87600, [-18.282602096834, -23.30503958666, -1.766620508028], [0.0025567245263557, -0.0019902940754171, -0.0013943491701082]],
  [116800, [43.873338744526, 7.700705617215, -10.814273666425], [23174803055677e-17, 0.0022402163127924, 62988756452032e-17]],
  [146e3, [7.392949027906, 44.382678951534, 11.629500214854], [-0.002193281545383, -21751799585364e-17, 59556516201114e-17]],
  [175200, [-24.981690229261, -16.204012851426, 2.466457544298], [0.001819398914958, -0.0026765419531201, -0.0013848283502247]],
  [204400, [42.530187039511, 0.845935508021, -12.554907527683], [65059779150669e-17, 0.0022725657282262, 51133743202822e-17]],
  [233600, [13.999526486822, 44.462363044894, 9.669418486465], [-0.0021079296569252, 17533423831993e-17, 69128485798076e-17]],
  [262800, [-29.184024803031, -7.371243995762, 6.493275957928], [93581363109681e-17, -0.0030610357109184, -0.0012364201089345]],
  [292e3, [39.831980671753, -6.078405766765, -13.909815358656], [0.0011117769689167, 0.0022362097830152, 36230548231153e-17]],
  [321200, [20.294955108476, 43.417190420251, 7.450091985932], [-0.0019742157451535, 53102050468554e-17, 75938408813008e-17]],
  [350400, [-30.66999230216, 2.318743558955, 9.973480913858], [45605107450676e-18, -0.0031308219926928, -99066533301924e-17]],
  [379600, [35.626122155983, -12.897647509224, -14.777586508444], [0.0016015684949743, 0.0021171931182284, 18002516202204e-17]],
  [408800, [26.133186148561, 41.232139187599, 5.00640132622], [-0.0017857704419579, 86046232702817e-17, 80614690298954e-17]],
  [438e3, [-29.57674022923, 11.863535943587, 12.631323039872], [-72292830060955e-17, -0.0029587820140709, -708242964503e-15]],
  [467200, [29.910805787391, -19.159019294, -15.013363865194], [0.0020871080437997, 0.0018848372554514, -38528655083926e-18]],
  [496400, [31.375957451819, 38.050372720763, 2.433138343754], [-0.0015546055556611, 0.0011699815465629, 83565439266001e-17]],
  [525600, [-26.360071336928, 20.662505904952, 14.414696258958], [-0.0013142373118349, -0.0026236647854842, -42542017598193e-17]],
  [554800, [22.599441488648, -24.508879898306, -14.484045731468], [0.0025454108304806, 0.0014917058755191, -30243665086079e-17]],
  [584e3, [35.877864013014, 33.894226366071, -0.224524636277], [-0.0012941245730845, 0.0014560427668319, 84762160640137e-17]],
  [613200, [-21.538149762417, 28.204068269761, 15.321973799534], [-0.001731211740901, -0.0021939631314577, -1631691327518e-16]],
  [642400, [13.971521374415, -28.339941764789, -13.083792871886], [0.0029334630526035, 91860931752944e-17, -59939422488627e-17]],
  [671600, [39.526942044143, 28.93989736011, -2.872799527539], [-0.0010068481658095, 0.001702113288809, 83578230511981e-17]],
  [700800, [-15.576200701394, 34.399412961275, 15.466033737854], [-0.0020098814612884, -0.0017191109825989, 70414782780416e-18]],
  [73e4, [4.24325283709, -30.118201690825, -10.707441231349], [0.0031725847067411, 1609846120227e-16, -90672150593868e-17]]
];
class I {
  constructor(n, t, r) {
    this.x = n, this.y = t, this.z = r;
  }
  clone() {
    return new I(this.x, this.y, this.z);
  }
  ToAstroVector(n) {
    return new G(this.x, this.y, this.z, n);
  }
  static zero() {
    return new I(0, 0, 0);
  }
  quadrature() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  add(n) {
    return new I(this.x + n.x, this.y + n.y, this.z + n.z);
  }
  sub(n) {
    return new I(this.x - n.x, this.y - n.y, this.z - n.z);
  }
  incr(n) {
    this.x += n.x, this.y += n.y, this.z += n.z;
  }
  decr(n) {
    this.x -= n.x, this.y -= n.y, this.z -= n.z;
  }
  mul(n) {
    return new I(n * this.x, n * this.y, n * this.z);
  }
  div(n) {
    return new I(this.x / n, this.y / n, this.z / n);
  }
  mean(n) {
    return new I((this.x + n.x) / 2, (this.y + n.y) / 2, (this.z + n.z) / 2);
  }
  neg() {
    return new I(-this.x, -this.y, -this.z);
  }
}
class B {
  constructor(n, t, r) {
    this.tt = n, this.r = t, this.v = r;
  }
  clone() {
    return new B(this.tt, this.r, this.v);
  }
  sub(n) {
    return new B(this.tt, this.r.sub(n.r), this.v.sub(n.v));
  }
}
function ee(e) {
  let [n, [t, r, i], [o, s, c]] = e;
  return new B(n, new I(t, r, i), new I(o, s, c));
}
function A0(e, n, t, r) {
  const i = r / (r + fn), o = Qt(n0[t], n);
  return e.r.incr(o.r.mul(i)), e.v.incr(o.v.mul(i)), o;
}
function u0(e, n, t) {
  const r = t.sub(e), i = r.quadrature();
  return r.mul(n / (i * Math.sqrt(i)));
}
class hn {
  constructor(n) {
    let t = new B(n, new I(0, 0, 0), new I(0, 0, 0));
    this.Jupiter = A0(t, n, E.Jupiter, B0), this.Saturn = A0(t, n, E.Saturn, Z0), this.Uranus = A0(t, n, E.Uranus, Y0), this.Neptune = A0(t, n, E.Neptune, K0), this.Jupiter.r.decr(t.r), this.Jupiter.v.decr(t.v), this.Saturn.r.decr(t.r), this.Saturn.v.decr(t.v), this.Uranus.r.decr(t.r), this.Uranus.v.decr(t.v), this.Neptune.r.decr(t.r), this.Neptune.v.decr(t.v), this.Sun = new B(n, t.r.mul(-1), t.v.mul(-1));
  }
  Acceleration(n) {
    let t = u0(n, fn, this.Sun.r);
    return t.incr(u0(n, B0, this.Jupiter.r)), t.incr(u0(n, Z0, this.Saturn.r)), t.incr(u0(n, Y0, this.Uranus.r)), t.incr(u0(n, K0, this.Neptune.r)), t;
  }
}
class O0 {
  constructor(n, t, r, i) {
    this.tt = n, this.r = t, this.v = r, this.a = i;
  }
  clone() {
    return new O0(this.tt, this.r.clone(), this.v.clone(), this.a.clone());
  }
}
class Vn {
  constructor(n, t) {
    this.bary = n, this.grav = t;
  }
}
function M0(e, n, t, r) {
  return new I(n.x + e * (t.x + e * r.x / 2), n.y + e * (t.y + e * r.y / 2), n.z + e * (t.z + e * r.z / 2));
}
function Mn(e, n, t) {
  return new I(n.x + e * t.x, n.y + e * t.y, n.z + e * t.z);
}
function on(e, n) {
  const t = e - n.tt, r = new hn(e), i = M0(t, n.r, n.v, n.a), o = r.Acceleration(i).mean(n.a), s = M0(t, n.r, n.v, o), c = n.v.add(o.mul(t)), a = r.Acceleration(s), l = new O0(e, s, c, a);
  return new Vn(r, l);
}
const re = [];
function Wn(e, n) {
  const t = Math.floor(e);
  return t < 0 ? 0 : t >= n ? n - 1 : t;
}
function an(e) {
  const n = ee(e), t = new hn(n.tt), r = n.r.add(t.Sun.r), i = n.v.add(t.Sun.v), o = t.Acceleration(r), s = new O0(n.tt, r, i, o);
  return new Vn(t, s);
}
function ie(e, n) {
  const t = q[0][0];
  if (n < t || n > q[rn - 1][0])
    return null;
  const r = Wn((n - t) / te, rn - 1);
  if (!e[r]) {
    const o = e[r] = [];
    o[0] = an(q[r]).grav, o[k - 1] = an(q[r + 1]).grav;
    let s, c = o[0].tt;
    for (s = 1; s < k - 1; ++s)
      o[s] = on(c += t0, o[s - 1]).grav;
    c = o[k - 1].tt;
    var i = [];
    for (i[k - 1] = o[k - 1], s = k - 2; s > 0; --s)
      i[s] = on(c -= t0, i[s + 1]).grav;
    for (s = k - 2; s > 0; --s) {
      const a = s / (k - 1);
      o[s].r = o[s].r.mul(1 - a).add(i[s].r.mul(a)), o[s].v = o[s].v.mul(1 - a).add(i[s].v.mul(a)), o[s].a = o[s].a.mul(1 - a).add(i[s].a.mul(a));
    }
  }
  return e[r];
}
function In(e, n, t) {
  let r = an(e);
  const i = Math.ceil((n - r.grav.tt) / t);
  for (let o = 0; o < i; ++o)
    r = on(o + 1 === i ? n : r.grav.tt + t, r.grav);
  return r;
}
function oe(e, n) {
  let t, r, i;
  const o = ie(re, e.tt);
  if (o) {
    const s = Wn((e.tt - o[0].tt) / t0, k - 1), c = o[s], a = o[s + 1], l = c.a.mean(a.a), d = M0(e.tt - c.tt, c.r, c.v, l), _ = Mn(e.tt - c.tt, c.v, l), f = M0(e.tt - a.tt, a.r, a.v, l), T = Mn(e.tt - a.tt, a.v, l), h = (e.tt - c.tt) / t0;
    t = d.mul(1 - h).add(f.mul(h)), r = _.mul(1 - h).add(T.mul(h));
  } else {
    let s;
    e.tt < q[0][0] ? s = In(q[0], e.tt, -t0) : s = In(q[rn - 1], e.tt, +t0), t = s.grav.r, r = s.grav.v, i = s.bary;
  }
  return i || (i = new hn(e.tt)), t = t.sub(i.Sun.r), r = r.sub(i.Sun.v), new Kt(t.x, t.y, t.z, r.x, r.y, r.z, e);
}
function d0(e, n) {
  var t = Z(n);
  if (e in n0)
    return C0(n0[e], t);
  if (e === E.Pluto) {
    const s = oe(t);
    return new G(s.x, s.y, s.z, t);
  }
  if (e === E.Sun)
    return new G(0, 0, 0, t);
  if (e === E.Moon) {
    var r = C0(n0.Earth, t), i = J0(t);
    return new G(r.x + i.x, r.y + i.y, r.z + i.z, t);
  }
  if (e === E.EMB) {
    const s = C0(n0.Earth, t), c = J0(t), a = 1 + Ot;
    return new G(s.x + c.x / a, s.y + c.y / a, s.z + c.z / a, t);
  }
  if (e === E.SSB)
    return ne(t);
  const o = Ln(e);
  if (o) {
    const s = new Jt(o.dec, 15 * o.ra, o.dist);
    return le(s, t);
  }
  throw `HelioVector: Unknown body "${e}"`;
}
function ae(e, n) {
  let t = n, r = 0;
  for (let i = 0; i < 10; ++i) {
    const o = e(t), s = o.Length() / Mt;
    if (s > 1)
      throw "Object is too distant for light-travel solver.";
    const c = n.AddDays(-s);
    if (r = Math.abs(c.tt - t.tt), r < 1e-9)
      return o;
    t = c;
  }
  throw `Light-travel time solver did not converge: dt = ${r}`;
}
class se {
  constructor(n, t, r, i) {
    this.observerBody = n, this.targetBody = t, this.aberration = r, this.observerPos = i;
  }
  Position(n) {
    this.aberration && (this.observerPos = d0(this.observerBody, n));
    const t = d0(this.targetBody, n);
    return new G(t.x - this.observerPos.x, t.y - this.observerPos.y, t.z - this.observerPos.z, n);
  }
}
function ce(e, n, t, r) {
  const i = Z(e);
  if (Ln(t)) {
    const c = d0(t, i), a = d0(n, i);
    return new G(c.x - a.x, c.y - a.y, c.z - a.z, i);
  }
  let o;
  o = d0(n, i);
  const s = new se(n, t, r, o);
  return ae((c) => s.Position(c), i);
}
function ue(e, n, t) {
  const r = Z(n);
  switch (e) {
    case E.Earth:
      return new G(0, 0, 0, r);
    case E.Moon:
      return J0(r);
    default:
      const i = ce(r, E.Earth, e, t);
      return i.t = r, i;
  }
}
var Nn;
(function(e) {
  e[e.Pericenter = 0] = "Pericenter", e[e.Apocenter = 1] = "Apocenter";
})(Nn || (Nn = {}));
function jn(e, n) {
  return new a0([
    [
      n.rot[0][0] * e.rot[0][0] + n.rot[1][0] * e.rot[0][1] + n.rot[2][0] * e.rot[0][2],
      n.rot[0][1] * e.rot[0][0] + n.rot[1][1] * e.rot[0][1] + n.rot[2][1] * e.rot[0][2],
      n.rot[0][2] * e.rot[0][0] + n.rot[1][2] * e.rot[0][1] + n.rot[2][2] * e.rot[0][2]
    ],
    [
      n.rot[0][0] * e.rot[1][0] + n.rot[1][0] * e.rot[1][1] + n.rot[2][0] * e.rot[1][2],
      n.rot[0][1] * e.rot[1][0] + n.rot[1][1] * e.rot[1][1] + n.rot[2][1] * e.rot[1][2],
      n.rot[0][2] * e.rot[1][0] + n.rot[1][2] * e.rot[1][1] + n.rot[2][2] * e.rot[1][2]
    ],
    [
      n.rot[0][0] * e.rot[2][0] + n.rot[1][0] * e.rot[2][1] + n.rot[2][0] * e.rot[2][2],
      n.rot[0][1] * e.rot[2][0] + n.rot[1][1] * e.rot[2][1] + n.rot[2][1] * e.rot[2][2],
      n.rot[0][2] * e.rot[2][0] + n.rot[1][2] * e.rot[2][1] + n.rot[2][2] * e.rot[2][2]
    ]
  ]);
}
function le(e, n) {
  n = Z(n);
  const t = e.lat * o0, r = e.lon * o0, i = e.dist * Math.cos(t);
  return new G(i * Math.cos(r), i * Math.sin(r), e.dist * Math.sin(t), n);
}
function de(e) {
  e = Z(e);
  const n = kn(e, $.From2000), t = Yt(e, $.From2000);
  return jn(n, t);
}
var Dn;
(function(e) {
  e.Penumbral = "penumbral", e.Partial = "partial", e.Annular = "annular", e.Total = "total";
})(Dn || (Dn = {}));
var Pn;
(function(e) {
  e[e.Invalid = 0] = "Invalid", e[e.Ascending = 1] = "Ascending", e[e.Descending = -1] = "Descending";
})(Pn || (Pn = {}));
const _e = /* @__PURE__ */ new U();
function me(e) {
  const n = Math.cos(e), t = Math.sin(e);
  return new a0([
    [n, -t, 0],
    [t, n, 0],
    [0, 0, 1]
  ]);
}
function m0(e) {
  return e instanceof j ? e : new j(e instanceof Date ? e : new Date(e));
}
function fe(e, n = new U()) {
  const t = m0(e), r = de(t), i = me(Zt(t) * (-Math.PI / 12)), { rot: o } = jn(r, i);
  return n.set(
    o[0][0],
    o[0][1],
    o[0][2],
    0,
    o[1][0],
    o[1][1],
    o[1][2],
    0,
    o[2][0],
    o[2][1],
    o[2][2],
    0,
    0,
    0,
    0,
    1
  );
}
function vn(e, n, t) {
  const { x: r, y: i, z: o } = ue(e, n, !1);
  return t.set(r, i, o).normalize();
}
function qn(e, n, t) {
  const r = fe(n, _e);
  return vn(e, n, t).applyMatrix4(r);
}
function Xe(e, n = new p()) {
  return vn(E.Sun, m0(e), n);
}
function Be(e, n = new p()) {
  return vn(E.Moon, m0(e), n);
}
function Ze(e, n = new p()) {
  return qn(E.Sun, m0(e), n);
}
function Ye(e, n = new p()) {
  return qn(E.Moon, m0(e), n);
}
function Xn(e) {
  return Math.sqrt(Math.max(e, 0));
}
function he(e) {
  return Math.max(e, 0);
}
function ve(e, n, t) {
  const { bottomRadius: r } = e;
  return t < 0 && n * n * (t * t - 1) + r * r >= 0;
}
function ge(e, n, t) {
  const { topRadius: r } = e, i = n * n * (t * t - 1) + r * r;
  return he(-n * t + Xn(i));
}
function I0(e, n) {
  return 0.5 / n + e * (1 - 1 / n);
}
var pe = process.env.NODE_ENV === "production", Un = "Invariant failed";
function Te(e, n) {
  if (!e) {
    if (pe)
      throw new Error(Un);
    var t = Un;
    throw new Error(t);
  }
}
const Re = /* @__PURE__ */ new p(), Gn = /* @__PURE__ */ new p(), Ee = /* @__PURE__ */ new p();
function y0(e, n, t) {
  const r = n * 4;
  return t.set(e[r], e[r + 1], e[r + 2]);
}
function Bn(e, n, t) {
  const { data: r, width: i, height: o } = e.image;
  Te(r instanceof Float32Array);
  const s = wn(n.x, 0, 1) * (i - 1), c = wn(n.y, 0, 1) * (o - 1), a = Math.floor(s), l = Math.floor(c), d = s - a, _ = c - l, f = d, T = _, h = a % i, v = (h + 1) % i, x = l % o, y = (x + 1) % o, N = y0(r, x * i + h, Re), D = y0(r, x * i + v, Gn), P = N.lerp(D, f), O = y0(r, y * i + h, Gn), L = y0(r, y * i + v, Ee), b = O.lerp(L, f);
  return t.copy(P.lerp(b, T));
}
function Se(e, n, t, r) {
  const { topRadius: i, bottomRadius: o } = e, s = Math.sqrt(i * i - o * o), c = Xn(n * n - o * o), a = ge(e, n, t), l = i - n, d = c + s, _ = (a - l) / (d - l), f = c / s;
  return r.set(
    I0(_, U0),
    I0(f, G0)
  );
}
const xe = /* @__PURE__ */ new p(), j0 = /* @__PURE__ */ new p(), we = /* @__PURE__ */ new sn();
function Ae(e, n, t, r = new it(), {
  ellipsoid: i = _0.WGS84,
  correctAltitude: o = !0,
  photometric: s = !0
} = {}, c = X.DEFAULT) {
  const a = xe.copy(n);
  if (o) {
    const v = i.projectOnSurface(
      n,
      j0
    );
    v != null && a.sub(
      i.getOsculatingSphereCenter(
        v,
        c.bottomRadius,
        j0
      )
    );
  }
  const l = j0;
  let d = a.length(), _ = a.dot(t);
  const { topRadius: f } = c, T = -_ - Math.sqrt(_ * _ - d * d + f * f);
  if (T > 0 && (d = f, _ += T), d > f)
    l.set(1, 1, 1);
  else {
    const v = _ / d;
    if (ve(c, d, v))
      l.set(0, 0, 0);
    else {
      const y = Se(c, d, v, we);
      Bn(e, y, l);
    }
  }
  const h = l.multiply(c.solarIrradiance);
  return s && h.multiply(c.sunRadianceToRelativeLuminance), r.setFromVector3(h);
}
function ye(e) {
  var n = [];
  if (e.length === 0)
    return "";
  if (typeof e[0] != "string")
    throw new TypeError("Url must be a string. Received " + e[0]);
  if (e[0].match(/^[^/:]+:\/*$/) && e.length > 1) {
    var t = e.shift();
    e[0] = t + e[0];
  }
  e[0].match(/^file:\/\/\//) ? e[0] = e[0].replace(/^([^/:]+):\/*/, "$1:///") : e[0] = e[0].replace(/^([^/:]+):\/*/, "$1://");
  for (var r = 0; r < e.length; r++) {
    var i = e[r];
    if (typeof i != "string")
      throw new TypeError("Url must be a string. Received " + i);
    i !== "" && (r > 0 && (i = i.replace(/^[\/]+/, "")), r < e.length - 1 ? i = i.replace(/[\/]+$/, "") : i = i.replace(/[\/]+$/, "/"), n.push(i));
  }
  var o = n.join("/");
  o = o.replace(/\/(\?|&|#[^!])/g, "$1");
  var s = o.split("?");
  return o = s.shift() + (s.length > 0 ? "?" : "") + s.join("&"), o;
}
function Ce() {
  var e;
  return typeof arguments[0] == "object" ? e = arguments[0] : e = [].slice.call(arguments), ye(e);
}
class Ke extends ot {
  constructor() {
    super(...arguments);
    g(this, "useHalfFloat", !1);
  }
  load(t, r, i, o) {
    const s = {}, c = (a, { Loader: l, width: d, height: _, depth: f, suffix: T = "" }) => {
      const h = new l(this.manager);
      h.setRequestHeader(this.requestHeader), h.setPath(this.path), h.setWithCredentials(this.withCredentials), h.load(
        Ce(t, `${a}${T}.bin`),
        (v) => {
          v.image.width = d, v.image.height = _, v instanceof at && f != null && (v.image.depth = f), this.useHalfFloat && (v.internalFormat = "RGBA16F"), s[`${a}Texture`] = v, s.irradianceTexture != null && s.scatteringTexture != null && s.transmittanceTexture != null && r(s);
        },
        i,
        o
      );
    };
    c("irradiance", {
      Loader: An,
      width: D0,
      height: P0
    }), c("scattering", {
      Loader: vt,
      width: Tt,
      height: Rt,
      depth: Et,
      suffix: this.useHalfFloat ? "" : "_float"
    }), c("transmittance", {
      Loader: An,
      width: U0,
      height: G0
    });
  }
}
function Me({ topRadius: e, bottomRadius: n }, t, r, i) {
  const o = (t - n) / (e - n), s = r * 0.5 + 0.5;
  return i.set(
    I0(s, D0),
    I0(o, P0)
  );
}
const Ie = 1 / Math.sqrt(Math.PI), q0 = Math.sqrt(3) / (2 * Math.sqrt(Math.PI)), Ne = /* @__PURE__ */ new p(), X0 = /* @__PURE__ */ new p(), De = /* @__PURE__ */ new sn(), Pe = {
  ellipsoid: _0.WGS84,
  correctAltitude: !0,
  photometric: !0
};
class Je extends st {
  constructor(t, r = X.DEFAULT) {
    super();
    g(this, "atmosphere");
    g(this, "irradianceTexture");
    g(this, "ellipsoid");
    g(this, "correctAltitude");
    g(this, "photometric");
    g(this, "sunDirection");
    const {
      irradianceTexture: i = null,
      ellipsoid: o,
      correctAltitude: s,
      photometric: c,
      sunDirection: a
    } = { ...Pe, ...t };
    this.atmosphere = r, this.irradianceTexture = i, this.ellipsoid = o, this.correctAltitude = s, this.photometric = c, this.sunDirection = (a == null ? void 0 : a.clone()) ?? new p();
  }
  update() {
    if (this.irradianceTexture == null)
      return;
    const t = this.getWorldPosition(Ne);
    if (this.correctAltitude) {
      const l = this.ellipsoid.projectOnSurface(
        t,
        X0
      );
      l != null && t.sub(
        this.ellipsoid.getOsculatingSphereCenter(
          l,
          this.atmosphere.bottomRadius,
          X0
        )
      );
    }
    const r = t.length(), i = t.dot(this.sunDirection) / r, o = Me(this.atmosphere, r, i, De), s = Bn(this.irradianceTexture, o, X0);
    this.photometric && s.multiply(this.atmosphere.skyRadianceToRelativeLuminance);
    const c = this.ellipsoid.getSurfaceNormal(t), a = this.sh.coefficients;
    a[0].copy(s).multiplyScalar(Ie), a[1].copy(s).multiplyScalar(q0 * c.y), a[2].copy(s).multiplyScalar(q0 * c.z), a[3].copy(s).multiplyScalar(q0 * c.x);
  }
}
var Ue = `uniform vec3 sunDirection;
uniform vec3 moonDirection;
uniform float moonAngularRadius;
uniform float lunarRadianceScale;

in vec3 vWorldPosition;
in vec3 vWorldDirection;
in vec3 vEllipsoidCenter;

layout(location = 0) out vec4 outputColor;

#include <mrt_layout>

void main() {
  vec3 viewPosition = vWorldPosition - vEllipsoidCenter;
  vec3 rayDirection = normalize(vWorldDirection);

  outputColor.rgb = getSkyRadiance(
    viewPosition,
    rayDirection,
    sunDirection,
    moonDirection,
    moonAngularRadius,
    lunarRadianceScale
  );
  outputColor.a = 1.0;

  #include <mrt_output>
}`, Ge = `uniform mat4 inverseProjectionMatrix;
uniform mat4 inverseViewMatrix;
uniform vec3 cameraPosition;
uniform vec3 ellipsoidCenter;

layout(location = 0) in vec3 position;

out vec3 vWorldPosition;
out vec3 vWorldDirection;
out vec3 vEllipsoidCenter;

void getCameraRay(out vec3 origin, out vec3 direction) {
  bool isPerspective = inverseProjectionMatrix[2][3] != 0.0; 

  if (isPerspective) {
    
    vec4 viewPosition = inverseProjectionMatrix * vec4(position, 1.0);
    vec4 worldDirection = inverseViewMatrix * vec4(viewPosition.xyz, 0.0);
    origin = cameraPosition;
    direction = worldDirection.xyz;
  } else {
    
    vec4 nearPoint = inverseProjectionMatrix * vec4(position.xy, -1.0, 1.0);
    vec4 farPoint = inverseProjectionMatrix * vec4(position.xy, -0.9, 1.0);
    nearPoint /= nearPoint.w;
    farPoint /= farPoint.w;

    
    vec4 worldDirection =
      inverseViewMatrix * vec4(farPoint.xyz - nearPoint.xyz, 0.0);
    vec4 worldOrigin = inverseViewMatrix * nearPoint;

    
    direction = worldDirection.xyz;
    origin = worldOrigin.xyz;
  }
}

void main() {
  vec3 direction, origin;
  getCameraRay(origin, direction);

  vWorldPosition = origin.xyz * METER_TO_UNIT_LENGTH;
  vWorldDirection = direction.xyz;
  vEllipsoidCenter = ellipsoidCenter * METER_TO_UNIT_LENGTH;

  gl_Position = vec4(position.xy, 1.0, 1.0);
}`;
const Oe = {
  ...mn,
  sun: !0,
  moon: !0,
  moonAngularRadius: 45e-4,
  // â‰ˆ 15.5 arcminutes
  lunarRadianceScale: 1
};
class Qe extends zn {
  constructor(n) {
    const {
      sun: t,
      moon: r,
      moonDirection: i,
      moonAngularRadius: o,
      lunarRadianceScale: s,
      ...c
    } = { ...Oe, ...n };
    super({
      glslVersion: On,
      vertexShader: (
        /* glsl */
        `
        precision highp float;
        precision highp sampler3D;
        ${i0}
        ${Ge}
      `
      ),
      fragmentShader: (
        /* glsl */
        `
        precision highp float;
        precision highp sampler3D;
        ${i0}
        ${_n}
        ${bn}
        ${Ue}
      `
      ),
      ...c,
      uniforms: {
        inverseProjectionMatrix: new m(new U()),
        inverseViewMatrix: new m(new U()),
        moonDirection: new m((i == null ? void 0 : i.clone()) ?? new p()),
        moonAngularRadius: new m(o),
        lunarRadianceScale: new m(s),
        ...c.uniforms
      },
      defines: {
        PERSPECTIVE_CAMERA: "1"
      },
      depthTest: !0
    }), this.sun = t, this.moon = r;
  }
  onBeforeRender(n, t, r, i, o, s) {
    super.onBeforeRender(n, t, r, i, o, s);
    const c = this.uniforms;
    c.inverseProjectionMatrix.value.copy(r.projectionMatrixInverse), c.inverseViewMatrix.value.copy(r.matrixWorld);
    const a = r.isPerspectiveCamera === !0;
    this.defines.PERSPECTIVE_CAMERA != null !== a && (a ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0);
  }
  get sun() {
    return this.defines.SUN != null;
  }
  set sun(n) {
    n !== this.sun && (n ? this.defines.SUN = "1" : delete this.defines.SUN, this.needsUpdate = !0);
  }
  get moon() {
    return this.defines.MOON != null;
  }
  set moon(n) {
    n !== this.moon && (n ? this.defines.MOON = "1" : delete this.defines.MOON, this.needsUpdate = !0);
  }
  get moonDirection() {
    return this.uniforms.moonDirection.value;
  }
  get moonAngularRadius() {
    return this.uniforms.moonAngularRadius.value;
  }
  set moonAngularRadius(n) {
    this.uniforms.moonAngularRadius.value = n;
  }
  get lunarRadianceScale() {
    return this.uniforms.lunarRadianceScale.value;
  }
  set lunarRadianceScale(n) {
    this.uniforms.lunarRadianceScale.value = n;
  }
}
class nr extends ct {
  constructor(n) {
    super();
    const t = new Int16Array(n), r = new Uint8Array(n), i = new Sn(t, 5), o = new Sn(r, 10);
    this.setAttribute(
      "position",
      new k0(i, 3, 0, !0)
    ), this.setAttribute(
      "magnitude",
      new k0(o, 1, 6, !0)
    ), this.setAttribute(
      "color",
      new k0(o, 3, 7, !0)
    ), this.boundingSphere = new ut(new p(), 1);
  }
}
var be = `uniform vec3 sunDirection;

in vec3 vWorldPosition;
in vec3 vWorldDirection;
in vec3 vEllipsoidCenter;

layout(location = 0) out vec4 outputColor;

#include <mrt_layout>

in vec3 vColor;

void main() {
  #ifndef PERSPECTIVE_CAMERA
  outputColor = vec4(0.0);
  discard; 
  #endif

  #ifdef BACKGROUND
  vec3 viewDirection = normalize(vWorldDirection);
  vec3 transmittance;
  vec3 radiance = GetSkyRadiance(
    vWorldPosition - vEllipsoidCenter,
    viewDirection,
    0.0,
    sunDirection,
    transmittance
  );
  radiance += transmittance * vColor;
  outputColor = vec4(radiance, 1.0);
  #else
  outputColor = vec4(vColor, 1.0);
  #endif 

  #include <mrt_output>
}`, ze = `#define saturate(x) clamp(x, 0.0, 1.0)

uniform mat4 projectionMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 viewMatrix;
uniform mat4 matrixWorld;
uniform vec3 cameraPosition;
uniform float cameraFar;
uniform vec3 ellipsoidCenter;
uniform float pointSize;
uniform vec2 magnitudeRange;
uniform float radianceScale;

layout(location = 0) in vec3 position;
layout(location = 1) in float magnitude;
layout(location = 2) in vec3 color;

out vec3 vWorldPosition;
out vec3 vWorldDirection;
out vec3 vEllipsoidCenter;
out vec3 vColor;

void main() {
  
  float m = mix(magnitudeRange.x, magnitudeRange.y, magnitude);
  vec3 v = pow(vec3(10.0), -vec3(magnitudeRange, m) / 2.5);
  vColor = vec3(radianceScale * color);
  vColor *= saturate((v.z - v.y) / (v.x - v.y));

  #ifdef BACKGROUND
  vec3 worldDirection = normalize(matrixWorld * vec4(position, 1.0)).xyz;
  vWorldDirection = worldDirection;
  vWorldPosition = cameraPosition * METER_TO_UNIT_LENGTH;
  vEllipsoidCenter = ellipsoidCenter * METER_TO_UNIT_LENGTH;
  gl_Position =
    projectionMatrix *
    viewMatrix *
    vec4(cameraPosition + worldDirection * cameraFar, 1.0);
  #else
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  #endif 

  gl_PointSize = pointSize;
}`;
const Le = {
  ...mn,
  pointSize: 1,
  radianceScale: 1,
  background: !0
};
class tr extends zn {
  constructor(t) {
    const { pointSize: r, radianceScale: i, background: o, ...s } = {
      ...Le,
      ...t
    };
    super({
      glslVersion: On,
      vertexShader: (
        /* glsl */
        `
        precision highp float;
        precision highp sampler3D;
        ${i0}
        ${ze}
      `
      ),
      fragmentShader: (
        /* glsl */
        `
        precision highp float;
        precision highp sampler3D;
        ${i0}
        ${_n}
        ${be}
      `
      ),
      ...s,
      uniforms: {
        projectionMatrix: new m(new U()),
        modelViewMatrix: new m(new U()),
        viewMatrix: new m(new U()),
        matrixWorld: new m(new U()),
        cameraFar: new m(0),
        pointSize: new m(0),
        magnitudeRange: new m(new sn(-2, 8)),
        radianceScale: new m(i),
        ...s.uniforms
      },
      defines: {
        PERSPECTIVE_CAMERA: "1"
      }
    });
    g(this, "pointSize");
    this.pointSize = r, this.background = o;
  }
  onBeforeRender(t, r, i, o, s, c) {
    super.onBeforeRender(t, r, i, o, s, c);
    const a = this.uniforms;
    a.projectionMatrix.value.copy(i.projectionMatrix), a.modelViewMatrix.value.copy(i.modelViewMatrix), a.viewMatrix.value.copy(i.matrixWorldInverse), a.matrixWorld.value.copy(s.matrixWorld), a.cameraFar.value = i.far, a.pointSize.value = this.pointSize * t.getPixelRatio();
    const l = i.isPerspectiveCamera === !0;
    this.defines.PERSPECTIVE_CAMERA != null !== l && (l ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0);
  }
  get magnitudeRange() {
    return this.uniforms.magnitudeScale.value;
  }
  get radianceScale() {
    return this.uniforms.radianceScale.value;
  }
  set radianceScale(t) {
    this.uniforms.radianceScale.value = t;
  }
  get background() {
    return this.defines.BACKGROUND != null;
  }
  set background(t) {
    t !== this.background && (t ? this.defines.BACKGROUND = "1" : delete this.defines.BACKGROUND, this.needsUpdate = !0);
  }
}
const Fe = /* @__PURE__ */ new p(), He = {
  ellipsoid: _0.WGS84,
  correctAltitude: !0,
  photometric: !0,
  distance: 1
};
class er extends lt {
  constructor(t, r = X.DEFAULT) {
    super();
    g(this, "atmosphere");
    g(this, "transmittanceTexture");
    g(this, "ellipsoid");
    g(this, "correctAltitude");
    g(this, "photometric");
    g(this, "sunDirection");
    g(this, "distance");
    const {
      irradianceTexture: i = null,
      ellipsoid: o,
      correctAltitude: s,
      photometric: c,
      sunDirection: a,
      distance: l
    } = { ...He, ...t };
    this.atmosphere = r, this.transmittanceTexture = i, this.ellipsoid = o, this.correctAltitude = s, this.photometric = c, this.sunDirection = (a == null ? void 0 : a.clone()) ?? new p(), this.distance = l;
  }
  update() {
    this.position.copy(this.sunDirection).normalize().multiplyScalar(this.distance).add(this.target.position), this.transmittanceTexture != null && Ae(
      this.transmittanceTexture,
      this.target.getWorldPosition(Fe),
      this.sunDirection,
      this.color,
      {
        ellipsoid: this.ellipsoid,
        correctAltitude: this.correctAltitude,
        photometric: this.photometric
      },
      this.atmosphere
    );
  }
}
export {
  qe as A,
  He as B,
  er as C,
  D0 as I,
  e0 as M,
  Ke as P,
  cn as S,
  U0 as T,
  At as a,
  mn as b,
  zn as c,
  X as d,
  Xe as e,
  Be as f,
  fe as g,
  Ze as h,
  Ye as i,
  P0 as j,
  un as k,
  ln as l,
  dn as m,
  Tt as n,
  Rt as o,
  Et as p,
  G0 as q,
  je as r,
  Ae as s,
  Pe as t,
  Je as u,
  Oe as v,
  Qe as w,
  nr as x,
  Le as y,
  tr as z
};
//# sourceMappingURL=shared.js.map
