<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TilesRenderer DRACO Test</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            padding: 20px;
        }
        h1 { margin-bottom: 20px; font-size: 20px; }
        .section {
            background: #2a2a3e;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }
        .section h2 { font-size: 16px; margin-bottom: 12px; color: #4a9eff; }
        .log {
            background: #111;
            border-radius: 4px;
            padding: 12px;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .log .info { color: #88f; }
        .log .success { color: #8f8; }
        .log .error { color: #f88; }
        .log .warn { color: #ff8; }
        button {
            background: #4a9eff;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            margin: 8px 4px 8px 0;
        }
        #canvas-container {
            width: 100%;
            height: 400px;
            background: #111;
            border-radius: 8px;
            margin-top: 16px;
        }
    </style>
</head>
<body>
    <h1>TilesRenderer + DRACO Test</h1>

    <div class="section">
        <h2>Test TilesRenderer with your tileset</h2>
        <button onclick="runTest()">Run TilesRenderer Test</button>
        <button onclick="clearLog()">Clear Log</button>
        <div id="log" class="log"></div>
        <div id="canvas-container"></div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const TILESET_URL = 'https://connor-haley.github.io/site3d-ar-test/tiles/tileset.json';
        
        const logEl = document.getElementById('log');
        
        function log(msg, type = 'info') {
            const time = new Date().toLocaleTimeString();
            logEl.innerHTML += `<span class="${type}">[${time}] ${msg}</span>\n`;
            logEl.scrollTop = logEl.scrollHeight;
            console.log(msg);
        }
        
        window.clearLog = () => { logEl.innerHTML = ''; };

        let scene, camera, renderer, controls;

        function initScene() {
            if (scene) return;
            
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 100000);
            camera.position.set(0, 500, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(100, 200, 100);
            scene.add(dirLight);
            
            // Add axes helper
            scene.add(new THREE.AxesHelper(100));
            
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();
            
            log('Three.js scene initialized', 'success');
        }

        window.runTest = async function() {
            initScene();
            log('Starting TilesRenderer test...', 'info');
            
            // Dynamic import of 3d-tiles-renderer
            log('Loading 3d-tiles-renderer library...', 'info');
            const { TilesRenderer } = await import('https://cdn.jsdelivr.net/npm/3d-tiles-renderer@0.3.34/+esm');
            log('3d-tiles-renderer loaded', 'success');
            
            // Setup DRACO
            log('Setting up DRACO loader...', 'info');
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
            dracoLoader.setDecoderConfig({ type: 'js' });
            
            const gltfLoader = new GLTFLoader();
            gltfLoader.setDRACOLoader(dracoLoader);
            log('DRACO + GLTF loaders configured', 'success');
            
            // Create TilesRenderer
            log(`Creating TilesRenderer for: ${TILESET_URL}`, 'info');
            const tilesRenderer = new TilesRenderer(TILESET_URL);
            
            // Register the handler
            tilesRenderer.manager.addHandler(/\.gltf$|\.glb$/i, gltfLoader);
            log('Registered GLB handler with DRACO support', 'success');
            
            // Configure
            tilesRenderer.setCamera(camera);
            tilesRenderer.setResolutionFromRenderer(camera, renderer);
            tilesRenderer.errorTarget = 100;
            tilesRenderer.maxDepth = 15;
            
            // Events
            tilesRenderer.addEventListener('load-tile-set', () => {
                log('EVENT: load-tile-set fired', 'success');
                log(`Root children: ${tilesRenderer.root?.children?.length || 0}`, 'info');
                
                // Log root bounding volume
                if (tilesRenderer.root?.boundingVolume) {
                    log(`Root bounding volume: ${JSON.stringify(tilesRenderer.root.boundingVolume)}`, 'info');
                }
            });
            
            tilesRenderer.addEventListener('load-content', (event) => {
                const uri = event.tile?.content?.uri || 'unknown';
                log(`EVENT: load-content - ${uri}`, 'success');
            });
            
            tilesRenderer.addEventListener('load-model', (event) => {
                log(`EVENT: load-model fired`, 'success');
            });
            
            tilesRenderer.addEventListener('error', (event) => {
                log(`EVENT: error - ${JSON.stringify(event)}`, 'error');
            });
            
            // Add to scene
            scene.add(tilesRenderer.group);
            log('TilesRenderer group added to scene', 'info');
            
            // Update loop
            let frameCount = 0;
            let lastMeshCount = 0;
            
            const update = () => {
                tilesRenderer.setCamera(camera);
                tilesRenderer.update();
                frameCount++;
                
                // Check mesh count every 30 frames
                if (frameCount % 30 === 0) {
                    let meshCount = 0;
                    let totalVerts = 0;
                    tilesRenderer.group.traverse(obj => {
                        if (obj.isMesh) {
                            meshCount++;
                            totalVerts += obj.geometry.attributes.position?.count || 0;
                        }
                    });
                    
                    if (meshCount !== lastMeshCount) {
                        log(`Meshes: ${meshCount}, Vertices: ${totalVerts.toLocaleString()}`, 'success');
                        lastMeshCount = meshCount;
                        
                        // Auto-fit camera on first mesh
                        if (meshCount > 0 && frameCount < 100) {
                            const box = new THREE.Box3().setFromObject(tilesRenderer.group);
                            if (!box.isEmpty()) {
                                const center = box.getCenter(new THREE.Vector3());
                                const size = box.getSize(new THREE.Vector3());
                                log(`Bounding box center: ${center.x.toFixed(0)}, ${center.y.toFixed(0)}, ${center.z.toFixed(0)}`, 'info');
                                log(`Bounding box size: ${size.x.toFixed(0)}, ${size.y.toFixed(0)}, ${size.z.toFixed(0)}`, 'info');
                                
                                // Position camera to see the content
                                const maxDim = Math.max(size.x, size.y, size.z);
                                camera.position.copy(center);
                                camera.position.z += maxDim * 1.5;
                                camera.position.y += maxDim * 0.5;
                                controls.target.copy(center);
                                controls.update();
                                log('Camera repositioned to view content', 'success');
                            }
                        }
                    }
                    
                    // Log stats
                    const stats = tilesRenderer.stats;
                    if (stats && frameCount % 60 === 0) {
                        log(`Stats: downloading=${stats.downloading}, parsing=${stats.parsing}, visible=${stats.visible}`, 'info');
                    }
                }
                
                // Keep updating
                if (frameCount < 600) { // 10 seconds at 60fps
                    requestAnimationFrame(update);
                } else {
                    log('Test complete (10 seconds elapsed)', 'info');
                    
                    // Final summary
                    let finalMeshCount = 0;
                    let finalVerts = 0;
                    tilesRenderer.group.traverse(obj => {
                        if (obj.isMesh) {
                            finalMeshCount++;
                            finalVerts += obj.geometry.attributes.position?.count || 0;
                        }
                    });
                    log(`FINAL: ${finalMeshCount} meshes, ${finalVerts.toLocaleString()} vertices`, finalMeshCount > 0 ? 'success' : 'error');
                }
            };
            
            update();
        };
        
        log('Page loaded. Click "Run TilesRenderer Test" to begin.', 'info');
    </script>
</body>
</html>
