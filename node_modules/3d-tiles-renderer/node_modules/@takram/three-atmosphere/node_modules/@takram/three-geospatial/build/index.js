var Tt = Object.defineProperty;
var St = (e, t, n) => t in e ? Tt(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var c = (e, t, n) => St(e, typeof t != "symbol" ? t + "" : t, n);
import { Loader as R, FileLoader as Pt, BufferAttribute as J, Box3 as Ot, Vector3 as f, Sphere as Mt, BufferGeometry as At, DataTexture as H, FloatType as I, Data3DTexture as zt, RGBAFormat as Et, ClampToEdgeWrapping as k, LinearFilter as tt, MathUtils as u, Matrix4 as It, Quaternion as Ct, Ray as Lt, Vector2 as ut } from "three";
import { E as et, G as m } from "./shared.js";
import { a as wr } from "./shared.js";
var Nt = `float reverseLogDepth(const float depth, const float near, const float far) {
  #ifdef USE_LOGDEPTHBUF
  float d = pow(2.0, depth * log2(far + 1.0)) - 1.0;
  float a = far / (far - near);
  float b = far * near / (near - far);
  return a + b / d;
  #else
  return depth;
  #endif 
}

float linearizeDepth(const float depth, const float near, const float far) {
  float ndc = depth * 2.0 - 1.0;
  return 2.0 * near * far / (far + near - ndc * (far - near));
}`, Dt = `vec2 signNotZero(vec2 v) {
  return vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);
}

vec2 packNormalToVec2(vec3 v) {
  vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));
  return v.z <= 0.0
    ? (1.0 - abs(p.yx)) * signNotZero(p)
    : p;
}

vec3 unpackVec2ToNormal(vec2 e) {
  vec3 v = vec3(e.xy, 1.0 - abs(e.x) - abs(e.y));
  if (v.z < 0.0) {
    v.xy = (1.0 - abs(v.yx)) * signNotZero(v.xy);
  }
  return normalize(v);
}`, Ft = `vec3 screenToView(
  const vec2 uv,
  const float depth,
  const float viewZ,
  const mat4 projectionMatrix,
  const mat4 inverseProjectionMatrix
) {
  vec4 clip = vec4(vec3(uv, depth) * 2.0 - 1.0, 1.0);
  float clipW = projectionMatrix[2][3] * viewZ + projectionMatrix[3][3];
  clip *= clipW;
  return (inverseProjectionMatrix * clip).xyz;
}`, $t = process.env.NODE_ENV === "production", nt = "Invariant failed";
function jt(e, t) {
  if (!e) {
    if ($t)
      throw new Error(nt);
    var n = nt;
    throw new Error(n);
  }
}
class Gt extends R {
  load(t, n, r, i) {
    const a = new Pt(this.manager);
    a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(this.withCredentials), a.load(
      t,
      (s) => {
        jt(s instanceof ArrayBuffer);
        try {
          n(s);
        } catch (o) {
          i != null ? i(o) : console.error(o), this.manager.itemError(t);
        }
      },
      r,
      i
    );
  }
}
function Xn(e) {
}
var Ut = typeof global == "object" && global && global.Object === Object && global, Rt = typeof self == "object" && self && self.Object === Object && self, B = Ut || Rt || Function("return this")(), p = B.Symbol, dt = Object.prototype, Ht = dt.hasOwnProperty, Bt = dt.toString, x = p ? p.toStringTag : void 0;
function qt(e) {
  var t = Ht.call(e, x), n = e[x];
  try {
    e[x] = void 0;
    var r = !0;
  } catch {
  }
  var i = Bt.call(e);
  return r && (t ? e[x] = n : delete e[x]), i;
}
var Vt = Object.prototype, Wt = Vt.toString;
function Xt(e) {
  return Wt.call(e);
}
var Zt = "[object Null]", Yt = "[object Undefined]", rt = p ? p.toStringTag : void 0;
function q(e) {
  return e == null ? e === void 0 ? Yt : Zt : rt && rt in Object(e) ? qt(e) : Xt(e);
}
function V(e) {
  return e != null && typeof e == "object";
}
var Kt = "[object Symbol]";
function W(e) {
  return typeof e == "symbol" || V(e) && q(e) == Kt;
}
function Qt(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length, i = Array(r); ++n < r; )
    i[n] = t(e[n], n, e);
  return i;
}
var P = Array.isArray, Jt = 1 / 0, it = p ? p.prototype : void 0, at = it ? it.toString : void 0;
function ft(e) {
  if (typeof e == "string")
    return e;
  if (P(e))
    return Qt(e, ft) + "";
  if (W(e))
    return at ? at.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -Jt ? "-0" : t;
}
function A(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
function kt(e) {
  return e;
}
var te = "[object AsyncFunction]", ee = "[object Function]", ne = "[object GeneratorFunction]", re = "[object Proxy]";
function ie(e) {
  if (!A(e))
    return !1;
  var t = q(e);
  return t == ee || t == ne || t == te || t == re;
}
var j = B["__core-js_shared__"], st = function() {
  var e = /[^.]+$/.exec(j && j.keys && j.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function ae(e) {
  return !!st && st in e;
}
var se = Function.prototype, oe = se.toString;
function ce(e) {
  if (e != null) {
    try {
      return oe.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var he = /[\\^$.*+?()[\]{}|]/g, le = /^\[object .+?Constructor\]$/, ue = Function.prototype, de = Object.prototype, fe = ue.toString, pe = de.hasOwnProperty, ye = RegExp(
  "^" + fe.call(pe).replace(he, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function ge(e) {
  if (!A(e) || ae(e))
    return !1;
  var t = ie(e) ? ye : le;
  return t.test(ce(e));
}
function we(e, t) {
  return e == null ? void 0 : e[t];
}
function X(e, t) {
  var n = we(e, t);
  return ge(n) ? n : void 0;
}
function ve(e, t, n) {
  switch (n.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, n[0]);
    case 2:
      return e.call(t, n[0], n[1]);
    case 3:
      return e.call(t, n[0], n[1], n[2]);
  }
  return e.apply(t, n);
}
var me = 800, xe = 16, _e = Date.now;
function be(e) {
  var t = 0, n = 0;
  return function() {
    var r = _e(), i = xe - (r - n);
    if (n = r, i > 0) {
      if (++t >= me)
        return arguments[0];
    } else
      t = 0;
    return e.apply(void 0, arguments);
  };
}
function Te(e) {
  return function() {
    return e;
  };
}
var z = function() {
  try {
    var e = X(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch {
  }
}(), Se = z ? function(e, t) {
  return z(e, "toString", {
    configurable: !0,
    enumerable: !1,
    value: Te(t),
    writable: !0
  });
} : kt, Pe = be(Se), Oe = 9007199254740991, Me = /^(?:0|[1-9]\d*)$/;
function pt(e, t) {
  var n = typeof e;
  return t = t ?? Oe, !!t && (n == "number" || n != "symbol" && Me.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
function Ae(e, t, n) {
  t == "__proto__" && z ? z(e, t, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : e[t] = n;
}
function yt(e, t) {
  return e === t || e !== e && t !== t;
}
var ze = Object.prototype, Ee = ze.hasOwnProperty;
function Ie(e, t, n) {
  var r = e[t];
  (!(Ee.call(e, t) && yt(r, n)) || n === void 0 && !(t in e)) && Ae(e, t, n);
}
var ot = Math.max;
function Ce(e, t, n) {
  return t = ot(t === void 0 ? e.length - 1 : t, 0), function() {
    for (var r = arguments, i = -1, a = ot(r.length - t, 0), s = Array(a); ++i < a; )
      s[i] = r[t + i];
    i = -1;
    for (var o = Array(t + 1); ++i < t; )
      o[i] = r[i];
    return o[t] = n(s), ve(e, this, o);
  };
}
var Le = 9007199254740991;
function Ne(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= Le;
}
var De = "[object Arguments]";
function ct(e) {
  return V(e) && q(e) == De;
}
var gt = Object.prototype, Fe = gt.hasOwnProperty, $e = gt.propertyIsEnumerable, wt = ct(/* @__PURE__ */ function() {
  return arguments;
}()) ? ct : function(e) {
  return V(e) && Fe.call(e, "callee") && !$e.call(e, "callee");
}, je = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Ge = /^\w*$/;
function Ue(e, t) {
  if (P(e))
    return !1;
  var n = typeof e;
  return n == "number" || n == "symbol" || n == "boolean" || e == null || W(e) ? !0 : Ge.test(e) || !je.test(e) || t != null && e in Object(t);
}
var T = X(Object, "create");
function Re() {
  this.__data__ = T ? T(null) : {}, this.size = 0;
}
function He(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var Be = "__lodash_hash_undefined__", qe = Object.prototype, Ve = qe.hasOwnProperty;
function We(e) {
  var t = this.__data__;
  if (T) {
    var n = t[e];
    return n === Be ? void 0 : n;
  }
  return Ve.call(t, e) ? t[e] : void 0;
}
var Xe = Object.prototype, Ze = Xe.hasOwnProperty;
function Ye(e) {
  var t = this.__data__;
  return T ? t[e] !== void 0 : Ze.call(t, e);
}
var Ke = "__lodash_hash_undefined__";
function Qe(e, t) {
  var n = this.__data__;
  return this.size += this.has(e) ? 0 : 1, n[e] = T && t === void 0 ? Ke : t, this;
}
function g(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
g.prototype.clear = Re;
g.prototype.delete = He;
g.prototype.get = We;
g.prototype.has = Ye;
g.prototype.set = Qe;
function Je() {
  this.__data__ = [], this.size = 0;
}
function C(e, t) {
  for (var n = e.length; n--; )
    if (yt(e[n][0], t))
      return n;
  return -1;
}
var ke = Array.prototype, tn = ke.splice;
function en(e) {
  var t = this.__data__, n = C(t, e);
  if (n < 0)
    return !1;
  var r = t.length - 1;
  return n == r ? t.pop() : tn.call(t, n, 1), --this.size, !0;
}
function nn(e) {
  var t = this.__data__, n = C(t, e);
  return n < 0 ? void 0 : t[n][1];
}
function rn(e) {
  return C(this.__data__, e) > -1;
}
function an(e, t) {
  var n = this.__data__, r = C(n, e);
  return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this;
}
function v(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
v.prototype.clear = Je;
v.prototype.delete = en;
v.prototype.get = nn;
v.prototype.has = rn;
v.prototype.set = an;
var sn = X(B, "Map");
function on() {
  this.size = 0, this.__data__ = {
    hash: new g(),
    map: new (sn || v)(),
    string: new g()
  };
}
function cn(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function L(e, t) {
  var n = e.__data__;
  return cn(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
function hn(e) {
  var t = L(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function ln(e) {
  return L(this, e).get(e);
}
function un(e) {
  return L(this, e).has(e);
}
function dn(e, t) {
  var n = L(this, e), r = n.size;
  return n.set(e, t), this.size += n.size == r ? 0 : 1, this;
}
function w(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
w.prototype.clear = on;
w.prototype.delete = hn;
w.prototype.get = ln;
w.prototype.has = un;
w.prototype.set = dn;
var fn = "Expected a function";
function Z(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(fn);
  var n = function() {
    var r = arguments, i = t ? t.apply(this, r) : r[0], a = n.cache;
    if (a.has(i))
      return a.get(i);
    var s = e.apply(this, r);
    return n.cache = a.set(i, s) || a, s;
  };
  return n.cache = new (Z.Cache || w)(), n;
}
Z.Cache = w;
var pn = 500;
function yn(e) {
  var t = Z(e, function(r) {
    return n.size === pn && n.clear(), r;
  }), n = t.cache;
  return t;
}
var gn = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, wn = /\\(\\)?/g, vn = yn(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(gn, function(n, r, i, a) {
    t.push(i ? a.replace(wn, "$1") : r || n);
  }), t;
});
function mn(e) {
  return e == null ? "" : ft(e);
}
function N(e, t) {
  return P(e) ? e : Ue(e, t) ? [e] : vn(mn(e));
}
var xn = 1 / 0;
function Y(e) {
  if (typeof e == "string" || W(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -xn ? "-0" : t;
}
function _n(e, t) {
  t = N(t, e);
  for (var n = 0, r = t.length; e != null && n < r; )
    e = e[Y(t[n++])];
  return n && n == r ? e : void 0;
}
function bn(e, t) {
  for (var n = -1, r = t.length, i = e.length; ++n < r; )
    e[i + n] = t[n];
  return e;
}
var ht = p ? p.isConcatSpreadable : void 0;
function Tn(e) {
  return P(e) || wt(e) || !!(ht && e && e[ht]);
}
function Sn(e, t, n, r, i) {
  var a = -1, s = e.length;
  for (n || (n = Tn), i || (i = []); ++a < s; ) {
    var o = e[a];
    n(o) ? bn(i, o) : i[i.length] = o;
  }
  return i;
}
function Pn(e) {
  var t = e == null ? 0 : e.length;
  return t ? Sn(e) : [];
}
function On(e) {
  return Pe(Ce(e, void 0, Pn), e + "");
}
function Mn(e, t) {
  return e != null && t in Object(e);
}
function An(e, t, n) {
  t = N(t, e);
  for (var r = -1, i = t.length, a = !1; ++r < i; ) {
    var s = Y(t[r]);
    if (!(a = e != null && n(e, s)))
      break;
    e = e[s];
  }
  return a || ++r != i ? a : (i = e == null ? 0 : e.length, !!i && Ne(i) && pt(s, i) && (P(e) || wt(e)));
}
function zn(e, t) {
  return e != null && An(e, t, Mn);
}
function En(e, t, n, r) {
  if (!A(e))
    return e;
  t = N(t, e);
  for (var i = -1, a = t.length, s = a - 1, o = e; o != null && ++i < a; ) {
    var h = Y(t[i]), l = n;
    if (h === "__proto__" || h === "constructor" || h === "prototype")
      return e;
    if (i != s) {
      var y = o[h];
      l = void 0, l === void 0 && (l = A(y) ? y : pt(t[i + 1]) ? [] : {});
    }
    Ie(o, h, l), o = o[h];
  }
  return e;
}
function In(e, t, n) {
  for (var r = -1, i = t.length, a = {}; ++r < i; ) {
    var s = t[r], o = _n(e, s);
    n(o, s) && En(a, N(s, e), o);
  }
  return a;
}
function Cn(e, t) {
  return In(e, t, function(n, r) {
    return zn(e, r);
  });
}
var Ln = On(function(e, t) {
  return e == null ? {} : Cn(e, t);
});
function Zn(e) {
  var t;
  return [
    Ln(e, ["attributes", "index", "boundingBox", "boundingSphere"]),
    [
      ...Object.values(e.attributes).map(
        (n) => n.array.buffer
      ),
      (t = e.index) == null ? void 0 : t.array.buffer
    ].filter((n) => n != null)
  ];
}
function Yn(e, t = new At()) {
  for (const [n, r] of Object.entries(e.attributes))
    t.setAttribute(
      n,
      new J(
        r.array,
        r.itemSize,
        r.normalized
      )
    );
  if (t.index = e.index != null ? new J(
    e.index.array,
    e.index.itemSize,
    e.index.normalized
  ) : null, e.boundingBox != null) {
    const { min: n, max: r } = e.boundingBox;
    t.boundingBox = new Ot(
      new f(n.x, n.y, n.z),
      new f(r.x, r.y, r.z)
    );
  }
  if (e.boundingSphere != null) {
    const { center: n, radius: r } = e.boundingSphere;
    t.boundingSphere = new Mt(
      new f(n.x, n.y, n.z),
      r
    );
  }
  return t;
}
function K(e, t, n, r = !0) {
  const i = new DataView(e), a = new t(i.byteLength / t.BYTES_PER_ELEMENT);
  for (let s = 0, o = 0; s < a.length; ++s, o += t.BYTES_PER_ELEMENT)
    a[s] = i[n](o, r);
  return a;
}
function Nn(e, t) {
  return K(e, Int16Array, "getInt16", t);
}
function Dn(e, t) {
  return K(e, Uint16Array, "getUint16", t);
}
function Fn(e, t) {
  return K(e, Float32Array, "getFloat32", t);
}
class Q extends R {
  load(t, n, r, i) {
    const a = new Gt(this.manager);
    a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(this.withCredentials), a.load(
      t,
      (s) => {
        try {
          n(this.parseTypedArray(s));
        } catch (o) {
          i != null ? i(o) : console.error(o), this.manager.itemError(t);
        }
      },
      r,
      i
    );
  }
}
class $n extends Q {
  constructor() {
    super(...arguments);
    c(this, "parseTypedArray", Nn);
  }
}
class jn extends Q {
  constructor() {
    super(...arguments);
    c(this, "parseTypedArray", Dn);
  }
}
class vt extends Q {
  constructor() {
    super(...arguments);
    c(this, "parseTypedArray", Fn);
  }
}
const D = {
  format: Et,
  wrapS: k,
  wrapT: k,
  minFilter: tt,
  magFilter: tt
};
class F extends R {
  constructor() {
    super(...arguments);
    c(this, "parameters");
  }
  load(n, r, i, a) {
    const s = new this.Texture(), o = new this.TypedArrayLoader(this.manager);
    o.setRequestHeader(this.requestHeader), o.setPath(this.path), o.setWithCredentials(this.withCredentials), o.load(
      n,
      (h) => {
        s.image.data = h, Object.assign(s, this.parameters), s.needsUpdate = !0, r(s);
      },
      i,
      a
    );
  }
}
class Kn extends F {
  constructor() {
    super(...arguments);
    c(this, "Texture", H);
    c(this, "TypedArrayLoader", $n);
    c(this, "parameters", {
      ...D,
      type: I
    });
  }
}
class Qn extends F {
  constructor() {
    super(...arguments);
    c(this, "Texture", H);
    c(this, "TypedArrayLoader", jn);
    c(this, "parameters", {
      ...D,
      type: I
    });
  }
}
class Jn extends F {
  constructor() {
    super(...arguments);
    c(this, "Texture", H);
    c(this, "TypedArrayLoader", vt);
    c(this, "parameters", {
      ...D,
      type: I
    });
  }
}
class kn extends F {
  constructor() {
    super(...arguments);
    c(this, "Texture", zt);
    c(this, "TypedArrayLoader", vt);
    c(this, "parameters", {
      ...D,
      type: I
    });
  }
}
const Gn = u.clamp, tr = u.euclideanModulo, er = u.inverseLerp, nr = u.lerp, rr = u.degToRad, ir = u.radToDeg, ar = u.isPowerOfTwo, sr = u.ceilPowerOfTwo, or = u.floorPowerOfTwo, cr = u.normalize;
function hr(e, t, n) {
  return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * (3 - 2 * n));
}
function lr(e) {
  return Math.min(Math.max(e, 0), 1);
}
function ur(e, t, n, r = n) {
  const i = Math.abs(e - t);
  return i <= r || i <= n * Math.max(Math.abs(e), Math.abs(t));
}
const G = 1e-6, O = /* @__PURE__ */ new f(), M = /* @__PURE__ */ new f(), d = /* @__PURE__ */ new f(), _ = /* @__PURE__ */ new f(), U = /* @__PURE__ */ new f(), Un = /* @__PURE__ */ new f(), Rn = /* @__PURE__ */ new It(), Hn = /* @__PURE__ */ new Ct(), Bn = /* @__PURE__ */ new Lt();
class mt {
  constructor(t = 0, n = 0, r = 0, i = 0) {
    // Distance from the target.
    c(this, "_distance");
    // Radians from the local east direction relative from true north, measured
    // clockwise (90 degrees is true north, and -90 is true south).
    c(this, "heading");
    // Radians from the local horizon plane, measured with positive values looking
    // up (90 degrees is straight up, -90 is straight down).
    c(this, "_pitch");
    c(this, "roll");
    this.distance = t, this.heading = n, this.pitch = r, this.roll = i;
  }
  get distance() {
    return this._distance;
  }
  set distance(t) {
    this._distance = Math.max(t, G);
  }
  get pitch() {
    return this._pitch;
  }
  set pitch(t) {
    this._pitch = Gn(t, -Math.PI / 2 + G, Math.PI / 2 - G);
  }
  set(t, n, r, i) {
    return this.distance = t, this.heading = n, this.pitch = r, i != null && (this.roll = i), this;
  }
  clone() {
    return new mt(this.distance, this.heading, this.pitch, this.roll);
  }
  copy(t) {
    return this.distance = t.distance, this.heading = t.heading, this.pitch = t.pitch, this.roll = t.roll, this;
  }
  equals(t) {
    return t.distance === this.distance && t.heading === this.heading && t.pitch === this.pitch && t.roll === this.roll;
  }
  decompose(t, n, r, i, a = et.WGS84) {
    a.getEastNorthUpVectors(
      t,
      O,
      M,
      d
    ), i == null || i.copy(d);
    const s = _.copy(O).multiplyScalar(Math.cos(this.heading)).add(
      U.copy(M).multiplyScalar(Math.sin(this.heading))
    ).multiplyScalar(Math.cos(this.pitch)).add(U.copy(d).multiplyScalar(Math.sin(this.pitch))).normalize().multiplyScalar(this.distance);
    if (n.copy(t).sub(s), this.roll !== 0) {
      const o = _.copy(t).sub(n).normalize();
      d.applyQuaternion(
        Hn.setFromAxisAngle(o, this.roll)
      );
    }
    r.setFromRotationMatrix(
      Rn.lookAt(n, t, d)
    );
  }
  setFromCamera(t, n = et.WGS84) {
    const r = _.setFromMatrixPosition(t.matrixWorld), i = U.set(0, 0, 0.5).unproject(t).sub(r).normalize(), a = n.getIntersection(Bn.set(r, i));
    if (a == null)
      return;
    this.distance = r.distanceTo(a), n.getEastNorthUpVectors(
      a,
      O,
      M,
      d
    ), this.heading = Math.atan2(
      M.dot(i),
      O.dot(i)
    ), this.pitch = Math.asin(d.dot(i));
    const s = _.copy(t.up).applyQuaternion(t.quaternion), o = Un.copy(i).multiplyScalar(-s.dot(i)).add(s).normalize(), h = _.copy(i).multiplyScalar(-d.dot(i)).add(d).normalize(), l = h.dot(o), y = i.dot(h.cross(o));
    return this.roll = Math.atan2(y, l), this;
  }
}
const b = class b {
  constructor(t = 0, n = 0, r = 0, i = 0) {
    this.west = t, this.south = n, this.east = r, this.north = i;
  }
  get width() {
    let t = this.east;
    return t < this.west && (t += Math.PI * 2), t - this.west;
  }
  get height() {
    return this.north - this.south;
  }
  set(t, n, r, i) {
    return this.west = t, this.south = n, this.east = r, this.north = i, this;
  }
  clone() {
    return new b(this.west, this.south, this.east, this.north);
  }
  copy(t) {
    return this.west = t.west, this.south = t.south, this.east = t.east, this.north = t.north, this;
  }
  equals(t) {
    return t.west === this.west && t.south === this.south && t.east === this.east && t.north === this.north;
  }
  at(t, n, r = new m()) {
    return r.set(
      this.west + (this.east - this.west) * t,
      this.north + (this.south - this.north) * n
    );
  }
  fromArray(t, n = 0) {
    return this.west = t[n], this.south = t[n + 1], this.east = t[n + 2], this.north = t[n + 3], this;
  }
  toArray(t = [], n = 0) {
    return t[n] = this.west, t[n + 1] = this.south, t[n + 2] = this.east, t[n + 3] = this.north, t;
  }
  *[Symbol.iterator]() {
    yield this.west, yield this.south, yield this.east, yield this.north;
  }
};
c(b, "MAX", /* @__PURE__ */ new b(
  m.MIN_LONGITUDE,
  m.MIN_LATITUDE,
  m.MAX_LONGITUDE,
  m.MAX_LATITUDE
));
let E = b;
function* xt(e, t, n, r, i) {
  if (n >= r)
    return;
  const a = 2 ** n, s = n + 1, o = 2 ** s, h = Math.floor(e / a * o), l = Math.floor(t / a * o), y = [
    [h, l, s],
    [h + 1, l, s],
    [h, l + 1, s],
    [h + 1, l + 1, s]
  ];
  if (s < r)
    for (const $ of y)
      for (const bt of xt(...$, r, i))
        yield bt;
  else
    for (const $ of y)
      yield (i ?? new S()).set(...$);
}
class S {
  constructor(t = 0, n = 0, r = 0) {
    this.x = t, this.y = n, this.z = r;
  }
  set(t, n, r) {
    return this.x = t, this.y = n, r != null && (this.z = r), this;
  }
  clone() {
    return new S(this.x, this.y, this.z);
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z;
  }
  getParent(t = new S()) {
    const n = 2 ** this.z, r = this.x / n, i = this.y / n, a = this.z - 1, s = 2 ** a;
    return t.set(Math.floor(r * s), Math.floor(i * s), a);
  }
  *traverseChildren(t, n) {
    const { x: r, y: i, z: a } = this;
    for (const s of xt(r, i, a, a + t, n))
      yield s;
  }
  fromArray(t, n = 0) {
    return this.x = t[n], this.y = t[n + 1], this.z = t[n + 2], this;
  }
  toArray(t = [], n = 0) {
    return t[n] = this.x, t[n + 1] = this.y, t[n + 2] = this.z, t;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const lt = /* @__PURE__ */ new ut();
class _t {
  constructor(t = 2, n = 1, r = E.MAX) {
    this.width = t, this.height = n, this.rectangle = r;
  }
  clone() {
    return new _t(this.width, this.height, this.rectangle.clone());
  }
  copy(t) {
    return this.width = t.width, this.height = t.height, this.rectangle.copy(t.rectangle), this;
  }
  getSize(t, n = new ut()) {
    return n.set(this.width << t, this.height << t);
  }
  // Reference: https://github.com/CesiumGS/cesium/blob/1.122/packages/engine/Source/Core/GeographicTilingScheme.js#L210
  getTile(t, n, r = new S()) {
    const i = this.getSize(n, lt), a = this.rectangle.width / i.x, s = this.rectangle.height / i.y;
    let o = t.longitude;
    this.rectangle.east < this.rectangle.west && (o += Math.PI * 2);
    let h = Math.floor((o - this.rectangle.west) / a);
    h >= i.x && (h = i.x - 1);
    let l = Math.floor((t.latitude - this.rectangle.south) / s);
    return l >= i.y && (l = i.y - 1), r.x = h, r.y = l, r.z = n, r;
  }
  // Reference: https://github.com/CesiumGS/cesium/blob/1.122/packages/engine/Source/Core/GeographicTilingScheme.js#L169
  getRectangle(t, n = new E()) {
    const r = this.getSize(t.z, lt), i = this.rectangle.width / r.x, a = this.rectangle.height / r.y;
    return n.west = t.x * i + this.rectangle.west, n.east = (t.x + 1) * i + this.rectangle.west, n.north = this.rectangle.north - (r.y - t.y - 1) * a, n.south = this.rectangle.north - (r.y - t.y) * a, n;
  }
}
const dr = Nt, fr = Dt, pr = Ft;
export {
  Gt as ArrayBufferLoader,
  F as DataLoader,
  et as Ellipsoid,
  wr as EllipsoidGeometry,
  vt as Float32ArrayLoader,
  Jn as Float32Data2DLoader,
  kn as Float32Data3DLoader,
  m as Geodetic,
  $n as Int16ArrayLoader,
  Kn as Int16Data2DLoader,
  mt as PointOfView,
  E as Rectangle,
  S as TileCoordinate,
  _t as TilingScheme,
  Q as TypedArrayLoader,
  jn as Uint16ArrayLoader,
  Qn as Uint16Data2DLoader,
  Xn as assertType,
  sr as ceilPowerOfTwo,
  Gn as clamp,
  ur as closeTo,
  ir as degrees,
  dr as depthShader,
  tr as euclideanModulo,
  or as floorPowerOfTwo,
  Yn as fromBufferGeometryLike,
  er as inverseLerp,
  ar as isPowerOfTwo,
  nr as lerp,
  cr as normalize,
  fr as packingShader,
  Fn as parseFloat32Array,
  Nn as parseInt16Array,
  K as parseTypedArray,
  Dn as parseUint16Array,
  rr as radians,
  lr as saturate,
  hr as smoothstep,
  Zn as toBufferGeometryLike,
  pr as transformShader
};
//# sourceMappingURL=index.js.map
